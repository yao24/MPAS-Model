










module seaice_core_interface

   use mpas_derived_types
   use mpas_pool_routines
   use mpas_dmpar
   use mpas_io_units
   use seaice_core
   use seaice_analysis_driver
   use mpas_log, only: mpas_log_write

   public

   contains

   !***********************************************************************
   !
   !  routine seaice_setup_core
   !
   !> \brief   Seaice core setup routine
   !> \author  Doug Jacobsen
   !> \date    03/18/2015
   !> \details
   !>  This routine is intended to setup the necessary variables within a core_type
   !>  for the ocean core.
   !
   !-----------------------------------------------------------------------
   subroutine seaice_setup_core(core)!{{{
      type (core_type), pointer :: core

      core % core_init => seaice_core_init
      core % core_run => seaice_core_run
      core % core_finalize => seaice_core_finalize
      core % define_packages => seaice_define_packages
      core % setup_packages => seaice_setup_packages
      core % setup_decompositions => seaice_setup_decompositions
      core % setup_clock => seaice_setup_clock
      core % setup_log => seaice_setup_log
      core % get_mesh_stream => seaice_get_mesh_stream
      core % setup_immutable_streams => seaice_setup_immutable_streams
      core % setup_derived_dimensions => seaice_setup_derived_dimensions
      core % setup_decomposed_dimensions => seaice_setup_decomposed_dimensions
      core % setup_block => seaice_setup_block
      core % setup_namelist => seaice_setup_namelists

      core % Conventions = 'MPAS'
      core % source = 'MPAS'
       core % modelName = 'mpas'
       core % coreName = 'seaice'
       core % modelVersion = '7.0'
       core % executableName = 'seaice_model'
       core % git_version = 'v7.0-661-g383f5082-dirty'

   end subroutine seaice_setup_core!}}}

   !***********************************************************************
   !
   !  routine seaice_setup_domain
   !
   !> \brief   Seaice domain setup routine
   !> \author  Doug Jacobsen
   !> \date    03/18/2015
   !> \details
   !>  This routine is intended to setup the necessary variables within a domain_type
   !>  for the ocean core.
   !
   !-----------------------------------------------------------------------
   subroutine seaice_setup_domain(domain)!{{{
      type (domain_type), pointer :: domain

       domain % namelist_filename = 'namelist.seaice'
       domain % streams_filename = 'streams.seaice'

   end subroutine seaice_setup_domain!}}}

   !***********************************************************************
   !
   !  function seaice_setup_packages
   !
   !> \brief   Pacakge setup routine
   !> \author  Doug Jacobsen
   !> \date    03/12/2015
   !> \details
   !>  This function is intended to correctly configure the packages for this MPAS
   !>   core. It can use any Fortran logic to properly configure packages, and it
   !>   can also make use of any namelist options. All variables in the model are
   !>   *not* allocated until after this routine is called.
   !
   !-----------------------------------------------------------------------
   function seaice_setup_packages(configPool, packagePool, iocontext) result(ierr)!{{{

      use mpas_derived_types

      implicit none

      type (mpas_pool_type), intent(inout) :: configPool
      type (mpas_pool_type), intent(inout) :: packagePool
      type (mpas_io_context_type), intent(inout) :: iocontext

      integer :: ierr

      ierr = 0

      ! dynamics
      call setup_packages_dynamics(configPool, packagePool, ierr)

      ! column physics
      call setup_packages_column_physics(configPool, packagePool, ierr)

      ! set up analysis member packages
      call seaice_analysis_setup_packages(configPool, packagePool, iocontext, ierr)

      ! icebergs
      call setup_packages_bergs(configPool, packagePool, ierr)

      ! testing system test
      call setup_packages_other(configPool, packagePool, ierr)

   end function seaice_setup_packages!}}}

   !***********************************************************************
   !
   !  routine setup_packages_dynamics
   !
   !> \brief
   !> \author  Adrian K. Turner
   !> \date    9th Feburary 2015
   !> \details
   !>
   !
   !-----------------------------------------------------------------------

   subroutine setup_packages_dynamics(configPool, packagePool, ierr)!{{{

     type (mpas_pool_type), intent(in) :: configPool
     type (mpas_pool_type), intent(in) :: packagePool
     integer, intent(out) :: ierr

     logical, pointer :: &
          config_use_velocity_solver

     character(len=strKIND), pointer :: &
          config_strain_scheme, &
          config_stress_divergence_scheme

     logical, pointer :: &
          pkgWeakActive, &
          pkgVariationalActive, &
          pkgWeakVariationalActive

     !pkgWeak
     !pkgVariational

     call MPAS_pool_get_config(configPool, "config_use_velocity_solver", config_use_velocity_solver)
     call MPAS_pool_get_config(configPool, "config_strain_scheme", config_strain_scheme)
     call MPAS_pool_get_config(configPool, "config_stress_divergence_scheme", config_stress_divergence_scheme)

     call MPAS_pool_get_package(packagePool, "pkgWeakActive", pkgWeakActive)
     call MPAS_pool_get_package(packagePool, "pkgVariationalActive", pkgVariationalActive)
     call MPAS_pool_get_package(packagePool, "pkgWeakVariationalActive", pkgWeakVariationalActive)

     ! is the velocity solver on
     if (config_use_velocity_solver) then

        ! stress divergence scheme
        if (trim(config_strain_scheme)            == "weak" .or. &
            trim(config_stress_divergence_scheme) == "weak") then

           ! weak stress divergence scheme
           pkgWeakActive = .true.

        endif

        if (trim(config_strain_scheme)            == "variational" .or. &
            trim(config_stress_divergence_scheme) == "variational") then

           ! variational stress divergence scheme
           pkgVariationalActive = .true.

        endif

        if (trim(config_strain_scheme)            == "weak" .and. &
            trim(config_stress_divergence_scheme) == "variational") then

           ! weak strain / variational stress divergence
           pkgWeakVariationalActive = .true.

        endif

     endif ! config_use_velocity_solver

   end subroutine setup_packages_dynamics!}}}

   !***********************************************************************
   !
   !  routine setup_packages_dynamics
   !
   !> \brief
   !> \author  Adrian K. Turner
   !> \date    9th Feburary 2015
   !> \details
   !>
   !
   !-----------------------------------------------------------------------

   subroutine setup_packages_column_physics(configPool, packagePool, ierr)!{{{

     type (mpas_pool_type), intent(in) :: configPool
     type (mpas_pool_type), intent(in) :: packagePool
     integer, intent(out) :: ierr

     ! column physics package packages
     logical, pointer :: &
          config_use_column_package, &
          config_use_column_biogeochemistry

     logical, pointer :: &
          pkgColumnPackageActive, &
          pkgColumnBiogeochemistryActive

     ! column tracers
     logical, pointer :: &
          config_use_ice_age, &
          config_use_first_year_ice, &
          config_use_level_ice, &
          config_use_cesm_meltponds, &
          config_use_level_meltponds, &
          config_use_topo_meltponds, &
          config_use_aerosols, &
          config_use_brine, &
          config_use_vertical_zsalinity, &
          config_use_vertical_biochemistry, &
          config_use_vertical_tracers, &
          config_use_skeletal_biochemistry, &
          config_use_nitrate, &
          config_use_carbon, &
          config_use_chlorophyll, &
          config_use_ammonium, &
          config_use_silicate, &
          config_use_DMS, &
          config_use_nonreactive, &
          config_use_humics, &
          config_use_DON, &
          config_use_iron, &
          config_use_zaerosols, &
          config_use_snow_grain_radius, &
          config_use_effective_snow_density

     logical, pointer :: &
          pkgColumnTracerIceAgeActive, &
          pkgColumnTracerFirstYearIceActive, &
          pkgColumnTracerLevelIceActive, &
          pkgColumnTracerPondsActive, &
          pkgColumnTracerLidThicknessActive, &
          pkgColumnTracerAerosolsActive, &
          pkgTracerBrineActive, &
          pkgTracerMobileFractionActive, &
          pkgTracerSkeletalAlgaeActive, &
          pkgTracerSkeletalNitrateActive, &
          pkgTracerSkeletalCarbonActive, &
          pkgTracerSkeletalAmmoniumActive, &
          pkgTracerSkeletalSilicateActive, &
          pkgTracerSkeletalDMSActive, &
          pkgTracerSkeletalNonreactiveActive, &
          pkgTracerSkeletalHumicsActive, &
          pkgTracerSkeletalDONActive, &
          pkgTracerSkeletalIronActive, &
          pkgTracerVerticalAlgaeActive, &
          pkgTracerVerticalNitrateActive, &
          pkgTracerVerticalCarbonActive, &
          pkgTracerVerticalAmmoniumActive, &
          pkgTracerVerticalSilicateActive, &
          pkgTracerVerticalDMSActive, &
          pkgTracerVerticalNonreactiveActive, &
          pkgTracerVerticalHumicsActive, &
          pkgTracerVerticalDONActive, &
          pkgTracerVerticalIronActive, &
          pkgTracerZAerosolsActive, &
          pkgTracerZSalinityActive, &
          pkgColumnTracerEffectiveSnowDensityActive, &
          pkgColumnTracerSnowGrainRadiusActive

     ! other packages
     logical, pointer :: &
          config_use_form_drag

     logical, pointer :: &
          pkgColumnFormDragActive

     logical :: &
          use_meltponds

     ierr = 0

     !-----------------------------------------------------------------------
     ! column main routines
     !-----------------------------------------------------------------------

     !pkgColumnPackage
     !pkgColumnBiogeochemistry

     call MPAS_pool_get_config(configPool, "config_use_column_package", config_use_column_package)
     call MPAS_pool_get_config(configPool, "config_use_column_biogeochemistry", config_use_column_biogeochemistry)

     call MPAS_pool_get_package(packagePool, "pkgColumnPackageActive", pkgColumnPackageActive)
     call MPAS_pool_get_package(packagePool, "pkgColumnBiogeochemistryActive", pkgColumnBiogeochemistryActive)

     pkgColumnPackageActive         = config_use_column_package
     pkgColumnBiogeochemistryActive = (config_use_column_biogeochemistry .and. config_use_column_package)

     !pkgColumnPackageActive         = .true.
     !pkgColumnBiogeochemistryActive = .true.

     !-----------------------------------------------------------------------
     ! tracers
     !-----------------------------------------------------------------------

     !pkgColumnTracerIceAge
     !pkgColumnTracerFirstYearIce
     !pkgColumnTracerLevelIce
     !pkgColumnTracerPonds
     !pkgColumnTracerLidThickness
     !pkgColumnTracerAerosols
     !pkgTracerBrine
     !pkgTracerMobileFraction
     !pkgTracerSkeletalAlgae
     !pkgTracerSkeletalNitrate
     !pkgTracerSkeletalCarbon
     !pkgTracerSkeletalAmmonium
     !pkgTracerSkeletalSilicate
     !pkgTracerSkeletalDMS
     !pkgTracerSkeletalNonreactive
     !pkgTracerSkeletalHumics
     !pkgTracerSkeletalDON
     !pkgTracerSkeletalIron
     !pkgTracerVerticalAlgae
     !pkgTracerVerticalNitrate
     !pkgTracerVerticalCarbon
     !pkgTracerVerticalAmmonium
     !pkgTracerVerticalSilicate
     !pkgTracerVerticalDMS
     !pkgTracerVerticalNonreactive
     !pkgTracerVerticalHumics
     !pkgTracerVerticalDON
     !pkgTracerVerticalIron
     !pkgTracerZAerosols
     !pkgTracerZSalinity
     !pkgColumnTracerEffectiveSnowDensity
     !pkgColumnTracerSnowGrainRadius

     call MPAS_pool_get_config(configPool, "config_use_ice_age", config_use_ice_age)
     call MPAS_pool_get_config(configPool, "config_use_first_year_ice", config_use_first_year_ice)
     call MPAS_pool_get_config(configPool, "config_use_level_ice", config_use_level_ice)
     call MPAS_pool_get_config(configPool, "config_use_cesm_meltponds", config_use_cesm_meltponds)
     call MPAS_pool_get_config(configPool, "config_use_level_meltponds", config_use_level_meltponds)
     call MPAS_pool_get_config(configPool, "config_use_topo_meltponds", config_use_topo_meltponds)
     call MPAS_pool_get_config(configPool, "config_use_aerosols", config_use_aerosols)
     call MPAS_pool_get_config(configPool, "config_use_brine", config_use_brine)
     call MPAS_pool_get_config(configPool, "config_use_vertical_zsalinity", config_use_vertical_zsalinity)
     call MPAS_pool_get_config(configPool, "config_use_vertical_tracers", config_use_vertical_tracers)
     call MPAS_pool_get_config(configPool, "config_use_skeletal_biochemistry", config_use_skeletal_biochemistry)
     call MPAS_pool_get_config(configPool, "config_use_vertical_biochemistry", config_use_vertical_biochemistry)
     call MPAS_pool_get_config(configPool, "config_use_nitrate", config_use_nitrate)
     call MPAS_pool_get_config(configPool, "config_use_carbon", config_use_carbon)
     call MPAS_pool_get_config(configPool, "config_use_chlorophyll", config_use_chlorophyll)
     call MPAS_pool_get_config(configPool, "config_use_ammonium", config_use_ammonium)
     call MPAS_pool_get_config(configPool, "config_use_silicate", config_use_silicate)
     call MPAS_pool_get_config(configPool, "config_use_DMS", config_use_DMS)
     call MPAS_pool_get_config(configPool, "config_use_nonreactive", config_use_nonreactive)
     call MPAS_pool_get_config(configPool, "config_use_humics", config_use_humics)
     call MPAS_pool_get_config(configPool, "config_use_DON", config_use_DON)
     call MPAS_pool_get_config(configPool, "config_use_iron", config_use_iron)
     call MPAS_pool_get_config(configPool, "config_use_zaerosols", config_use_zaerosols)
     call MPAS_pool_get_config(configPool, "config_use_effective_snow_density", config_use_effective_snow_density)
     call MPAS_pool_get_config(configPool, "config_use_snow_grain_radius", config_use_snow_grain_radius)

     call MPAS_pool_get_package(packagePool, "pkgColumnTracerIceAgeActive", pkgColumnTracerIceAgeActive)
     call MPAS_pool_get_package(packagePool, "pkgColumnTracerFirstYearIceActive", pkgColumnTracerFirstYearIceActive)
     call MPAS_pool_get_package(packagePool, "pkgColumnTracerLevelIceActive", pkgColumnTracerLevelIceActive)
     call MPAS_pool_get_package(packagePool, "pkgColumnTracerPondsActive", pkgColumnTracerPondsActive)
     call MPAS_pool_get_package(packagePool, "pkgColumnTracerLidThicknessActive", pkgColumnTracerLidThicknessActive)
     call MPAS_pool_get_package(packagePool, "pkgColumnTracerAerosolsActive", pkgColumnTracerAerosolsActive)
     call MPAS_pool_get_package(packagePool, "pkgTracerBrineActive", pkgTracerBrineActive)
     call MPAS_pool_get_package(packagePool, "pkgTracerMobileFractionActive", pkgTracerMobileFractionActive)
     call MPAS_pool_get_package(packagePool, "pkgTracerSkeletalAlgaeActive", pkgTracerSkeletalAlgaeActive)
     call MPAS_pool_get_package(packagePool, "pkgTracerSkeletalNitrateActive", pkgTracerSkeletalNitrateActive)
     call MPAS_pool_get_package(packagePool, "pkgTracerSkeletalCarbonActive", pkgTracerSkeletalCarbonActive)
     call MPAS_pool_get_package(packagePool, "pkgTracerSkeletalAmmoniumActive", pkgTracerSkeletalAmmoniumActive)
     call MPAS_pool_get_package(packagePool, "pkgTracerSkeletalSilicateActive", pkgTracerSkeletalSilicateActive)
     call MPAS_pool_get_package(packagePool, "pkgTracerSkeletalDMSActive", pkgTracerSkeletalDMSActive)
     call MPAS_pool_get_package(packagePool, "pkgTracerSkeletalNonreactiveActive", pkgTracerSkeletalNonreactiveActive)
     call MPAS_pool_get_package(packagePool, "pkgTracerSkeletalHumicsActive", pkgTracerSkeletalHumicsActive)
     call MPAS_pool_get_package(packagePool, "pkgTracerSkeletalDONActive", pkgTracerSkeletalDONActive)
     call MPAS_pool_get_package(packagePool, "pkgTracerSkeletalIronActive", pkgTracerSkeletalIronActive)
     call MPAS_pool_get_package(packagePool, "pkgTracerVerticalAlgaeActive", pkgTracerVerticalAlgaeActive)
     call MPAS_pool_get_package(packagePool, "pkgTracerVerticalNitrateActive", pkgTracerVerticalNitrateActive)
     call MPAS_pool_get_package(packagePool, "pkgTracerVerticalCarbonActive", pkgTracerVerticalCarbonActive)
     call MPAS_pool_get_package(packagePool, "pkgTracerVerticalAmmoniumActive", pkgTracerVerticalAmmoniumActive)
     call MPAS_pool_get_package(packagePool, "pkgTracerVerticalSilicateActive", pkgTracerVerticalSilicateActive)
     call MPAS_pool_get_package(packagePool, "pkgTracerVerticalDMSActive", pkgTracerVerticalDMSActive)
     call MPAS_pool_get_package(packagePool, "pkgTracerVerticalNonreactiveActive", pkgTracerVerticalNonreactiveActive)
     call MPAS_pool_get_package(packagePool, "pkgTracerVerticalHumicsActive", pkgTracerVerticalHumicsActive)
     call MPAS_pool_get_package(packagePool, "pkgTracerVerticalDONActive", pkgTracerVerticalDONActive)
     call MPAS_pool_get_package(packagePool, "pkgTracerVerticalIronActive", pkgTracerVerticalIronActive)
     call MPAS_pool_get_package(packagePool, "pkgTracerZAerosolsActive", pkgTracerZAerosolsActive)
     call MPAS_pool_get_package(packagePool, "pkgTracerZSalinityActive", pkgTracerZSalinityActive)
     call MPAS_pool_get_package(packagePool, "pkgColumnTracerEffectiveSnowDensityActive", pkgColumnTracerEffectiveSnowDensityActive)
     call MPAS_pool_get_package(packagePool, "pkgColumnTracerSnowGrainRadiusActive", pkgColumnTracerSnowGrainRadiusActive)

     use_meltponds = (config_use_cesm_meltponds .or. config_use_level_meltponds .or. config_use_topo_meltponds)

     pkgColumnTracerIceAgeActive       = config_use_ice_age
     pkgColumnTracerFirstYearIceActive = config_use_first_year_ice
     pkgColumnTracerLevelIceActive     = config_use_level_ice
     pkgColumnTracerPondsActive        = use_meltponds
     pkgColumnTracerLidThicknessActive = (config_use_level_meltponds .or. config_use_topo_meltponds)
     pkgColumnTracerAerosolsActive     = config_use_aerosols

     pkgTracerBrineActive                = config_use_brine
     pkgTracerMobileFractionActive       = config_use_vertical_tracers
     pkgTracerSkeletalAlgaeActive        = config_use_skeletal_biochemistry
     pkgTracerSkeletalNitrateActive      = (config_use_skeletal_biochemistry .and. config_use_nitrate)
     pkgTracerSkeletalCarbonActive       = (config_use_skeletal_biochemistry .and. config_use_carbon)
     pkgTracerSkeletalAmmoniumActive     = (config_use_skeletal_biochemistry .and. config_use_ammonium)
     pkgTracerSkeletalSilicateActive     = (config_use_skeletal_biochemistry .and. config_use_silicate)
     pkgTracerSkeletalDMSActive          = (config_use_skeletal_biochemistry .and. config_use_DMS)
     pkgTracerSkeletalNonreactiveActive  = (config_use_skeletal_biochemistry .and. config_use_nonreactive)
     pkgTracerSkeletalHumicsActive       = (config_use_skeletal_biochemistry .and. config_use_humics)
     pkgTracerSkeletalDONActive          = (config_use_skeletal_biochemistry .and. config_use_DON)
     pkgTracerSkeletalIronActive         = (config_use_skeletal_biochemistry .and. config_use_iron)
     pkgTracerVerticalAlgaeActive        = (config_use_vertical_tracers .and. config_use_vertical_biochemistry)
     pkgTracerVerticalNitrateActive      = (config_use_vertical_tracers .and. config_use_nitrate)
     pkgTracerVerticalCarbonActive       = (config_use_vertical_tracers .and. config_use_carbon)
     pkgTracerVerticalAmmoniumActive     = (config_use_vertical_tracers .and. config_use_ammonium)
     pkgTracerVerticalSilicateActive     = (config_use_vertical_tracers .and. config_use_silicate)
     pkgTracerVerticalDMSActive          = (config_use_vertical_tracers .and. config_use_DMS)
     pkgTracerVerticalNonreactiveActive  = (config_use_vertical_tracers .and. config_use_nonreactive)
     pkgTracerVerticalHumicsActive       = (config_use_vertical_tracers .and. config_use_humics)
     pkgTracerVerticalDONActive          = (config_use_vertical_tracers .and. config_use_DON)
     pkgTracerVerticalIronActive         = (config_use_vertical_tracers .and. config_use_iron)
     pkgTracerZAerosolsActive            = config_use_zaerosols
     pkgTracerZSalinityActive            = config_use_vertical_zsalinity

     pkgColumnTracerEffectiveSnowDensityActive = config_use_effective_snow_density
     pkgColumnTracerSnowGrainRadiusActive = config_use_snow_grain_radius

     if (.not. config_use_column_package) then
        pkgColumnTracerIceAgeActive       = .false.
        pkgColumnTracerFirstYearIceActive = .false.
        pkgColumnTracerLevelIceActive     = .false.
        pkgColumnTracerPondsActive        = .false.
        pkgColumnTracerLidThicknessActive = .false.
        pkgColumnTracerAerosolsActive     = .false.
        pkgTracerBrineActive                = .false.
        pkgTracerMobileFractionActive       = .false.
        pkgTracerSkeletalAlgaeActive        = .false.
        pkgTracerSkeletalNitrateActive      = .false.
        pkgTracerSkeletalCarbonActive       = .false.
        pkgTracerSkeletalAmmoniumActive     = .false.
        pkgTracerSkeletalSilicateActive     = .false.
        pkgTracerSkeletalDMSActive          = .false.
        pkgTracerSkeletalNonreactiveActive  = .false.
        pkgTracerSkeletalHumicsActive       = .false.
        pkgTracerSkeletalDONActive          = .false.
        pkgTracerSkeletalIronActive         = .false.
        pkgTracerVerticalAlgaeActive        = .false.
        pkgTracerVerticalNitrateActive      = .false.
        pkgTracerVerticalCarbonActive       = .false.
        pkgTracerVerticalAmmoniumActive     = .false.
        pkgTracerVerticalSilicateActive     = .false.
        pkgTracerVerticalDMSActive          = .false.
        pkgTracerVerticalNonreactiveActive  = .false.
        pkgTracerVerticalHumicsActive       = .false.
        pkgTracerVerticalDONActive          = .false.
        pkgTracerVerticalIronActive         = .false.
        pkgTracerZAerosolsActive            = .false.
        pkgTracerZSalinityActive            = .false.
        pkgColumnTracerEffectiveSnowDensityActive = .false.
        pkgColumnTracerSnowGrainRadiusActive      = .false.
     endif

     if (.not. config_use_column_biogeochemistry .and. config_use_column_package) then
        pkgTracerBrineActive                = .false.
        pkgTracerMobileFractionActive       = .false.
        pkgTracerSkeletalAlgaeActive        = .false.
        pkgTracerSkeletalNitrateActive      = .false.
        pkgTracerSkeletalCarbonActive       = .false.
        pkgTracerSkeletalAmmoniumActive     = .false.
        pkgTracerSkeletalSilicateActive     = .false.
        pkgTracerSkeletalDMSActive          = .false.
        pkgTracerSkeletalNonreactiveActive  = .false.
        pkgTracerSkeletalHumicsActive       = .false.
        pkgTracerSkeletalDONActive          = .false.
        pkgTracerSkeletalIronActive         = .false.
        pkgTracerVerticalAlgaeActive        = .false.
        pkgTracerVerticalNitrateActive      = .false.
        pkgTracerVerticalCarbonActive       = .false.
        pkgTracerVerticalAmmoniumActive     = .false.
        pkgTracerVerticalSilicateActive     = .false.
        pkgTracerVerticalDMSActive          = .false.
        pkgTracerVerticalNonreactiveActive  = .false.
        pkgTracerVerticalHumicsActive       = .false.
        pkgTracerVerticalDONActive          = .false.
        pkgTracerVerticalIronActive         = .false.
        pkgTracerZAerosolsActive            = .false.
        pkgTracerZSalinityActive            = .false.
     endif

     !pkgColumnTracerIceAgeActive       = .true.
     !pkgColumnTracerFirstYearIceActive = .true.
     !pkgColumnTracerLevelIceActive     = .true.
     !pkgColumnTracerPondsActive        = .true.
     !pkgColumnTracerLidThicknessActive = .true.
     !pkgColumnTracerAerosolsActive     = .true.
     !pkgColumnTracerArrayStandInActive = .true.

     !-----------------------------------------------------------------------
     ! other column packages
     !-----------------------------------------------------------------------

     !pkgColumnFormDrag

     ! form drag
     call MPAS_pool_get_config(configPool, "config_use_form_drag", config_use_form_drag)
     call MPAS_pool_get_package(packagePool, "pkgColumnFormDragActive", pkgColumnFormDragActive)
     pkgColumnFormDragActive = (config_use_column_package .and. config_use_form_drag)

     !pkgColumnFormDragActive = .true.

   end subroutine setup_packages_column_physics!}}}

   !***********************************************************************
   !
   !  routine setup_packages_bergs
   !
   !> \brief   Setup icebergs package
   !> \author  Darin Comeau
   !> \date    19 May 2017
   !> \details This routine is intended to set the icebergs package PkgBergs
   !> as active/deactive based on the namelist option config_use_bergs.
   !
   !-----------------------------------------------------------------------

   subroutine setup_packages_bergs(configPool, packagePool, ierr)!{{{

     type (mpas_pool_type), intent(in) :: configPool
     type (mpas_pool_type), intent(in) :: packagePool
     integer, intent(out) :: ierr

          ! icebergs package
     logical, pointer :: &
          config_use_data_icebergs

     logical, pointer :: &
          pkgBergsActive

     ierr = 0

     !-----------------------------------------------------------------------
     ! iceberg routines
     !-----------------------------------------------------------------------

     call MPAS_pool_get_config(configPool, "config_use_data_icebergs", config_use_data_icebergs)
     call MPAS_pool_get_package(packagePool, "pkgBergsActive", pkgBergsActive)
     pkgBergsActive = config_use_data_icebergs

   end subroutine setup_packages_bergs!}}}

   !***********************************************************************
   !
   !  routine setup_packages_other
   !
   !> \brief
   !> \author  Adrian K. Turner
   !> \date    9th Feburary 2015
   !> \details
   !>
   !
   !-----------------------------------------------------------------------

   subroutine setup_packages_other(configPool, packagePool, ierr)!{{{

     type (mpas_pool_type), intent(in) :: configPool
     type (mpas_pool_type), intent(in) :: packagePool
     integer, intent(out) :: ierr

     logical, pointer :: &
          config_use_forcing, &
          config_use_data_icebergs, &
          config_testing_system_test, &
          config_use_snicar_ad, &
          config_use_prescribed_ice, &
          config_use_special_boundaries_velocity, &
          config_use_special_boundaries_velocity_masks, &
          config_use_special_boundaries_zero_tracers

     logical, pointer :: &
          pkgForcingActive, &
          pkgTestingSystemTestActive, &
          pkgSnicarActive, &
          pkgPrescribedActive, &
          pkgSpecialBoundariesActive

     ierr = 0

     ! pkgForcing

     call MPAS_pool_get_config(configPool, "config_use_forcing", config_use_forcing)
     call MPAS_pool_get_config(configPool, "config_use_data_icebergs", config_use_data_icebergs)

     call MPAS_pool_get_package(packagePool, "pkgForcingActive", pkgForcingActive)

     ! see if we are using the forcing system
     if (config_use_forcing .or. config_use_data_icebergs) then

        pkgForcingActive = .true.

     endif

     !pkgTestingSystemTest

     call MPAS_pool_get_config(configPool, "config_testing_system_test", config_testing_system_test)

     call MPAS_pool_get_package(packagePool, "pkgTestingSystemTestActive", pkgTestingSystemTestActive)

     ! see if we are testing the testing system
     if (config_testing_system_test) then
        pkgTestingSystemTestActive = .true.
     endif

     ! pkgSnicar
     call MPAS_pool_get_config(configPool, "config_use_snicar_ad", config_use_snicar_ad)
     call MPAS_pool_get_package(packagePool, "pkgSnicarActive", pkgSnicarActive)
     ! see if we are using the snicar_ad system
     pkgSnicarActive = .true.

     ! pkgPrescribed
     call MPAS_pool_get_config(configPool, "config_use_prescribed_ice", config_use_prescribed_ice)
     call MPAS_pool_get_package(packagePool, "pkgPrescribedActive", pkgPrescribedActive)
     if (config_use_prescribed_ice) then
        pkgPrescribedActive = .true.
     endif

     ! pkgSpecialBoundaries
     call MPAS_pool_get_config(configPool, "config_use_special_boundaries_velocity", config_use_special_boundaries_velocity)
     call MPAS_pool_get_config(configPool, "config_use_special_boundaries_velocity_masks", config_use_special_boundaries_velocity_masks)
     call MPAS_pool_get_config(configPool, "config_use_special_boundaries_zero_tracers", config_use_special_boundaries_zero_tracers)
     call MPAS_pool_get_package(packagePool, "pkgSpecialBoundariesActive", pkgSpecialBoundariesActive)
     if (config_use_special_boundaries_velocity .or. &
         config_use_special_boundaries_velocity_masks .or. &
         config_use_special_boundaries_zero_tracers) then
        pkgSpecialBoundariesActive = .true.
     endif

   end subroutine setup_packages_other!}}}

   !***********************************************************************
   !
   !  routine seaice_setup_decompositions
   !
   !> \brief   Decomposition setup routine
   !> \author  Doug Jacobsen
   !> \date    04/08/2015
   !> \details
   !>  This routine is intended to create the decomposition list within a
   !>  domain type, and register any decompositons the core wants within it.
   !
   !-----------------------------------------------------------------------
   function seaice_setup_decompositions(decompList) result(ierr)!{{{

      use mpas_derived_types
      use mpas_decomp

      implicit none

      type (mpas_decomp_list), pointer :: decompList

      integer :: ierr
      procedure (mpas_decomp_function), pointer :: decompFunc

      ierr = 0

      nullify(decompList)

      call mpas_decomp_create_decomp_list(decompList)

      decompFunc => mpas_uniform_decomp

      if ( associated(decompList) ) then
         call mpas_log_write(' It is associated (decompList that is)')
      end if

      call mpas_decomp_register_method(decompList, 'uniform', decompFunc, iErr)

      if ( iErr == MPAS_DECOMP_NOERR ) then
         iErr = 0
      end if

   end function seaice_setup_decompositions!}}}


   !***********************************************************************
   !
   !  function seaice_setup_clock
   !
   !> \brief   Pacakge setup routine
   !> \author  Michael Duda
   !> \date    6 August 2014
   !> \details
   !>  The purpose of this function is to allow the core to set up a simulation
   !>  clock that will be used by the I/O subsystem for timing reads and writes
   !>  of I/O streams.
   !>  This function is called from the superstructure after the framework
   !>  has been initialized but before any fields have been allocated and
   !>  initial fields have been read from input files. However, all namelist
   !>  options are available.
   !
   !-----------------------------------------------------------------------
   function seaice_setup_clock(core_clock, configs) result(ierr)!{{{

      use mpas_derived_types

      implicit none

      type (MPAS_Clock_type), intent(inout) :: core_clock
      type (mpas_pool_type), intent(inout) :: configs
      integer :: ierr

      call seaice_simulation_clock_init(core_clock, configs, ierr)

   end function seaice_setup_clock!}}}

   !***********************************************************************
   !
   !  function seaice_setup_log
   !
   !> \brief   Log setup routine
   !> \author  Matt Hoffman, Adrian K. Turner
   !> \date    21 March 2017
   !> \details
   !>  The purpose of this routine is to set up the logging manager
   !>  and allow the core to specify details of the configuration.
   !
   !-----------------------------------------------------------------------
   function seaice_setup_log(logInfo, domain, unitNumbers) result(iErr)!{{{

      use mpas_derived_types
      use mpas_log

      implicit none

      type (mpas_log_type), intent(inout), pointer :: logInfo    !< logging information object to set up
      type (domain_type), intent(in), pointer :: domain          !< domain object to provide info for setting up log manager
      integer, dimension(2), intent(in), optional :: unitNumbers !< Fortran unit numbers to use for output and error logs
      integer :: iErr

      ! Local variables
      integer :: local_err

      iErr = 0

      ! Initialize log manager
      call mpas_log_init(logInfo, domain, unitNumbers=unitNumbers, err=local_err)
      iErr = ior(iErr, local_err)

      ! Set core specific options here
      ! (At present, there are not any.  There could eventually be choices about the file naming conventions
      !  or other settings controlling behavior.)

      ! After core has had a chance to modify log defaults, open the output log
      call mpas_log_open(err=local_err)
      iErr = ior(iErr, local_err)

   end function seaice_setup_log!}}}

   !***********************************************************************
   !
   !  function seaice_get_mesh_stream
   !
   !> \brief   Returns the name of the stream containing mesh information
   !> \author  Michael Duda
   !> \date    8 August 2014
   !> \details
   !>  This function returns the name of the I/O stream containing dimensions,
   !>  attributes, and mesh fields needed by the framework bootstrapping
   !>  routine. At the time this routine is called, only namelist options
   !>  are available.
   !
   !-----------------------------------------------------------------------
   function seaice_get_mesh_stream(configs, stream) result(ierr)!{{{

      use mpas_derived_types
      use mpas_pool_routines

      implicit none

      type (mpas_pool_type), intent(inout) :: configs
      character(len=StrKIND), intent(out) :: stream
      integer :: ierr

      logical, pointer :: config_do_restart
      character(len=strKIND), pointer :: config_initial_condition_type

      ierr = 0

      call mpas_pool_get_config(configs, 'config_initial_condition_type', config_initial_condition_type)
      call mpas_pool_get_config(configs, 'config_do_restart', config_do_restart)

      if (.not. associated(config_do_restart)) then
         write(stream,'(a)') ''
         ierr = 1
      else
         if (config_do_restart) then
            write(stream,'(a)') 'restart'
         else
            if (trim(config_initial_condition_type) == "restart") then
               write(stream,'(a)') 'restart_ic'
            else
               write(stream,'(a)') 'input'
            end if
         endif
      endif

   end function seaice_get_mesh_stream!}}}


   !***********************************************************************
   !
   !  function seaice_setup_block
   !
   !> \brief   Ocean block setup function
   !> \author  Doug Jacobsen
   !> \date    03/18/2015
   !> \details
   !>  This function is a wrapper function to properly setup a block to be a
   !>  ocean core block.
   !
   !-----------------------------------------------------------------------
   function seaice_setup_block(block) result(iErr)!{{{
      use mpas_derived_types
      type (block_type), pointer :: block
      integer :: iErr

      iErr = 0
      call seaice_generate_structs(block, block % structs, block % dimensions, block % packages)
   end function seaice_setup_block!}}}

function seaice_setup_immutable_streams(manager) result(iErr)

   use MPAS_derived_types, only : MPAS_streamManager_type, &
                                  MPAS_STREAM_INPUT_OUTPUT, MPAS_STREAM_INPUT, &
                                  MPAS_STREAM_OUTPUT, MPAS_STREAM_NONE, MPAS_STREAM_PROPERTY_IMMUTABLE
   use MPAS_stream_manager, only : MPAS_stream_mgr_create_stream, MPAS_stream_mgr_set_property, &
                                   MPAS_stream_mgr_add_field, MPAS_stream_mgr_add_pool
   use mpas_io_units

   implicit none

   type (MPAS_streamManager_type), pointer :: manager
   character (len=StrKIND) :: packages
   integer :: iErr

   iErr = 0

   call MPAS_stream_mgr_create_stream(manager, 'mesh', MPAS_STREAM_NONE, 'mesh_variables.nc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'latCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'lonCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'xCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'yCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'zCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'indexToCellID', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'latEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'lonEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'xEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'yEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'zEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'indexToEdgeID', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'latVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'lonVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'xVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'yVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'zVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'indexToVertexID', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'cellsOnEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'nEdgesOnCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'nEdgesOnEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'edgesOnCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'edgesOnEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'dvEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'dcEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'areaCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'areaTriangle', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'cellsOnCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'verticesOnCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'verticesOnEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'edgesOnVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'cellsOnVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'mesh', 'kiteAreasOnVertex', ierr=ierr)
   call MPAS_stream_mgr_set_property(manager, 'mesh', MPAS_STREAM_PROPERTY_IMMUTABLE, .true., ierr=ierr)

   call MPAS_stream_mgr_create_stream(manager, 'input', MPAS_STREAM_INPUT, 'grid.nc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'latCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'lonCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'xCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'yCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'zCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'indexToCellID', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'latEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'lonEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'xEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'yEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'zEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'indexToEdgeID', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'latVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'lonVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'xVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'yVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'zVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'indexToVertexID', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'cellsOnEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'nEdgesOnCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'nEdgesOnEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'edgesOnCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'edgesOnEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'dvEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'dcEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'areaCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'areaTriangle', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'cellsOnCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'verticesOnCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'verticesOnEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'edgesOnVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'cellsOnVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'kiteAreasOnVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'fVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'input', 'fEdge', ierr=ierr)
   call MPAS_stream_mgr_set_property(manager, 'input', MPAS_STREAM_PROPERTY_IMMUTABLE, .true., ierr=ierr)

   call MPAS_stream_mgr_create_stream(manager, 'regions', MPAS_STREAM_INPUT, 'regions.nc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'regions', 'regionCellMasks', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'regions', 'regionNames', ierr=ierr)
   call MPAS_stream_mgr_set_property(manager, 'regions', MPAS_STREAM_PROPERTY_IMMUTABLE, .true., ierr=ierr)

   call MPAS_stream_mgr_create_stream(manager, 'restart_contents', MPAS_STREAM_NONE, 'restart_variables.nc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'fVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'iceAreaCategory', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'iceVolumeCategory', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'snowVolumeCategory', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'surfaceTemperature', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'iceEnthalpy', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'iceSalinity', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'snowEnthalpy', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'snowIceMass', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'snowLiquidMass', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'snowGrainRadius', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'snowDensity', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'iceAge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'firstYearIceArea', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'levelIceArea', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'levelIceVolume', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'pondArea', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'pondDepth', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'pondLidThickness', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'snowScatteringAerosol', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'snowBodyAerosol', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'iceScatteringAerosol', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'iceBodyAerosol', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'uVelocity', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'vVelocity', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'stress11weak', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'stress22weak', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'stress12weak', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'stress11var', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'stress22var', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'stress12var', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'solveVelocityPrevious', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'freezeOnset', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'snowfallRate', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'pondSnowDepthDifference', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'pondLidMeltFluxFraction', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'solarZenithAngleCosine', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'shortwaveScalingFactor', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'shortwaveVisibleDirectDown', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'shortwaveVisibleDiffuseDown', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'shortwaveIRDirectDown', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'shortwaveIRDiffuseDown', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'oceanStressCellU', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'oceanStressCellV', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'seaSurfaceTemperature', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'freezingMeltingPotential', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'airOceanDragCoefficientRatio', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'skeletalAlgaeConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'skeletalDOCConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'skeletalDICConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'skeletalDONConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'skeletalNitrateConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'skeletalSilicateConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'skeletalAmmoniumConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'skeletalDMSConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'skeletalDMSPpConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'skeletalDMSPdConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'skeletalNonreactiveConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'skeletalHumicsConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'skeletalParticulateIronConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'skeletalDissolvedIronConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'verticalAlgaeConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'verticalDOCConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'verticalDICConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'verticalDONConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'verticalNitrateConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'verticalSilicateConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'verticalAmmoniumConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'verticalDMSConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'verticalDMSPpConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'verticalDMSPdConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'verticalNonreactiveConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'verticalHumicsConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'verticalParticulateIronConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'verticalDissolvedIronConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'verticalAerosolsConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'verticalSalinity', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'brineFraction', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'mobileFraction', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'newlyFormedIce', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'maximumIcePresence', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'testArrayRegression', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'testArrayParallelism', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'testArrayRestartability', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'forcingGroupNames', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_contents', 'forcingGroupRestartTimes', ierr=ierr)
   call MPAS_stream_mgr_set_property(manager, 'restart_contents', MPAS_STREAM_PROPERTY_IMMUTABLE, .true., ierr=ierr)

   call MPAS_stream_mgr_create_stream(manager, 'restart', MPAS_STREAM_INPUT_OUTPUT, 'restarts/restart.$Y-$M-$D_$h.$m.$s.nc', &
ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'latCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'lonCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'xCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'yCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'zCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'indexToCellID', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'latEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'lonEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'xEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'yEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'zEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'indexToEdgeID', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'latVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'lonVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'xVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'yVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'zVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'indexToVertexID', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'cellsOnEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'nEdgesOnCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'nEdgesOnEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'edgesOnCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'edgesOnEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'dvEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'dcEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'areaCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'areaTriangle', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'cellsOnCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'verticesOnCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'verticesOnEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'edgesOnVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'cellsOnVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'kiteAreasOnVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'fVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'iceAreaCategory', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'iceVolumeCategory', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'snowVolumeCategory', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'surfaceTemperature', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'iceEnthalpy', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'iceSalinity', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'snowEnthalpy', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'snowIceMass', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'snowLiquidMass', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'snowGrainRadius', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'snowDensity', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'iceAge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'firstYearIceArea', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'levelIceArea', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'levelIceVolume', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'pondArea', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'pondDepth', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'pondLidThickness', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'snowScatteringAerosol', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'snowBodyAerosol', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'iceScatteringAerosol', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'iceBodyAerosol', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'uVelocity', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'vVelocity', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'stress11weak', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'stress22weak', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'stress12weak', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'stress11var', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'stress22var', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'stress12var', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'solveVelocityPrevious', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'freezeOnset', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'snowfallRate', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'pondSnowDepthDifference', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'pondLidMeltFluxFraction', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'solarZenithAngleCosine', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'shortwaveScalingFactor', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'shortwaveVisibleDirectDown', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'shortwaveVisibleDiffuseDown', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'shortwaveIRDirectDown', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'shortwaveIRDiffuseDown', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'oceanStressCellU', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'oceanStressCellV', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'seaSurfaceTemperature', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'freezingMeltingPotential', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'airOceanDragCoefficientRatio', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'skeletalAlgaeConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'skeletalDOCConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'skeletalDICConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'skeletalDONConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'skeletalNitrateConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'skeletalSilicateConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'skeletalAmmoniumConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'skeletalDMSConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'skeletalDMSPpConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'skeletalDMSPdConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'skeletalNonreactiveConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'skeletalHumicsConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'skeletalParticulateIronConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'skeletalDissolvedIronConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'verticalAlgaeConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'verticalDOCConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'verticalDICConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'verticalDONConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'verticalNitrateConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'verticalSilicateConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'verticalAmmoniumConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'verticalDMSConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'verticalDMSPpConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'verticalDMSPdConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'verticalNonreactiveConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'verticalHumicsConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'verticalParticulateIronConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'verticalDissolvedIronConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'verticalAerosolsConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'verticalSalinity', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'brineFraction', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'mobileFraction', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'newlyFormedIce', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'maximumIcePresence', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'testArrayRegression', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'testArrayParallelism', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'testArrayRestartability', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'forcingGroupNames', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'forcingGroupRestartTimes', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'xtime', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart', 'simulationStartTime', ierr=ierr)
   call MPAS_stream_mgr_set_property(manager, 'restart', MPAS_STREAM_PROPERTY_IMMUTABLE, .true., ierr=ierr)

   call MPAS_stream_mgr_create_stream(manager, 'restart_ic', MPAS_STREAM_INPUT, 'seaice_ic.nc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'latCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'lonCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'xCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'yCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'zCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'indexToCellID', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'latEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'lonEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'xEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'yEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'zEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'indexToEdgeID', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'latVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'lonVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'xVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'yVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'zVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'indexToVertexID', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'cellsOnEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'nEdgesOnCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'nEdgesOnEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'edgesOnCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'edgesOnEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'dvEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'dcEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'areaCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'areaTriangle', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'cellsOnCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'verticesOnCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'verticesOnEdge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'edgesOnVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'cellsOnVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'kiteAreasOnVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'fVertex', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'iceAreaCategory', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'iceVolumeCategory', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'snowVolumeCategory', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'surfaceTemperature', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'iceEnthalpy', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'iceSalinity', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'snowEnthalpy', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'snowIceMass', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'snowLiquidMass', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'snowGrainRadius', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'snowDensity', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'iceAge', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'firstYearIceArea', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'levelIceArea', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'levelIceVolume', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'pondArea', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'pondDepth', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'pondLidThickness', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'snowScatteringAerosol', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'snowBodyAerosol', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'iceScatteringAerosol', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'iceBodyAerosol', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'uVelocity', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'vVelocity', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'stress11weak', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'stress22weak', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'stress12weak', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'stress11var', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'stress22var', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'stress12var', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'solveVelocityPrevious', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'freezeOnset', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'snowfallRate', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'pondSnowDepthDifference', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'pondLidMeltFluxFraction', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'solarZenithAngleCosine', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'shortwaveScalingFactor', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'shortwaveVisibleDirectDown', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'shortwaveVisibleDiffuseDown', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'shortwaveIRDirectDown', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'shortwaveIRDiffuseDown', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'oceanStressCellU', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'oceanStressCellV', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'seaSurfaceTemperature', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'freezingMeltingPotential', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'airOceanDragCoefficientRatio', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'skeletalAlgaeConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'skeletalDOCConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'skeletalDICConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'skeletalDONConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'skeletalNitrateConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'skeletalSilicateConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'skeletalAmmoniumConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'skeletalDMSConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'skeletalDMSPpConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'skeletalDMSPdConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'skeletalNonreactiveConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'skeletalHumicsConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'skeletalParticulateIronConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'skeletalDissolvedIronConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'verticalAlgaeConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'verticalDOCConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'verticalDICConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'verticalDONConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'verticalNitrateConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'verticalSilicateConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'verticalAmmoniumConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'verticalDMSConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'verticalDMSPpConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'verticalDMSPdConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'verticalNonreactiveConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'verticalHumicsConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'verticalParticulateIronConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'verticalDissolvedIronConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'verticalAerosolsConc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'verticalSalinity', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'brineFraction', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'mobileFraction', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'newlyFormedIce', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'maximumIcePresence', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'testArrayRegression', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'testArrayParallelism', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'testArrayRestartability', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'forcingGroupNames', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'restart_ic', 'forcingGroupRestartTimes', ierr=ierr)
   call MPAS_stream_mgr_set_property(manager, 'restart_ic', MPAS_STREAM_PROPERTY_IMMUTABLE, .true., ierr=ierr)

   call MPAS_stream_mgr_create_stream(manager, 'LYqSixHourlyForcing', MPAS_STREAM_INPUT, &
'forcing/atmosphere_forcing_six_hourly.$Y.nc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'LYqSixHourlyForcing', 'airTemperature', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'LYqSixHourlyForcing', 'airSpecificHumidity', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'LYqSixHourlyForcing', 'uAirVelocity', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'LYqSixHourlyForcing', 'vAirVelocity', ierr=ierr)
   call MPAS_stream_mgr_set_property(manager, 'LYqSixHourlyForcing', MPAS_STREAM_PROPERTY_IMMUTABLE, .true., ierr=ierr)

   call MPAS_stream_mgr_create_stream(manager, 'LYqMonthlyForcing', MPAS_STREAM_INPUT, 'forcing/atmosphere_forcing_monthly.nc', &
ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'LYqMonthlyForcing', 'cloudFraction', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'LYqMonthlyForcing', 'rainfallRate', ierr=ierr)
   call MPAS_stream_mgr_set_property(manager, 'LYqMonthlyForcing', MPAS_STREAM_PROPERTY_IMMUTABLE, .true., ierr=ierr)

   call MPAS_stream_mgr_create_stream(manager, 'NCARMonthlySSTForcing', MPAS_STREAM_INPUT, 'forcing/ocean_forcing_monthly.nc', &
ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'NCARMonthlySSTForcing', 'seaSurfaceTemperature', ierr=ierr)
   call MPAS_stream_mgr_set_property(manager, 'NCARMonthlySSTForcing', MPAS_STREAM_PROPERTY_IMMUTABLE, .true., ierr=ierr)

   call MPAS_stream_mgr_create_stream(manager, 'NCARMonthlyForcing', MPAS_STREAM_INPUT, 'forcing/ocean_forcing_monthly.nc', &
ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'NCARMonthlyForcing', 'seaSurfaceSalinity', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'NCARMonthlyForcing', 'uOceanVelocity', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'NCARMonthlyForcing', 'vOceanVelocity', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'NCARMonthlyForcing', 'seaSurfaceTiltU', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'NCARMonthlyForcing', 'seaSurfaceTiltV', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'NCARMonthlyForcing', 'oceanMixedLayerDepth', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'NCARMonthlyForcing', 'oceanHeatFluxConvergence', ierr=ierr)
   call MPAS_stream_mgr_set_property(manager, 'NCARMonthlyForcing', MPAS_STREAM_PROPERTY_IMMUTABLE, .true., ierr=ierr)

   call MPAS_stream_mgr_create_stream(manager, 'prescribedIceForcing', MPAS_STREAM_INPUT, 'forcing/ice_coverage.nc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'prescribedIceForcing', 'iceCoverage', ierr=ierr)
   call MPAS_stream_mgr_set_property(manager, 'prescribedIceForcing', MPAS_STREAM_PROPERTY_IMMUTABLE, .true., ierr=ierr)

   call MPAS_stream_mgr_create_stream(manager, 'StandardAerosolsInput', MPAS_STREAM_INPUT, 'standard_optics_mpas_cice.nc', &
ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'StandardAerosolsInput', 'aerosolAsymmetryParameter', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'StandardAerosolsInput', 'aerosolMassExtinctionCrossSection', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'StandardAerosolsInput', 'aerosolSingleScatterAlbedo', ierr=ierr)
   call MPAS_stream_mgr_set_property(manager, 'StandardAerosolsInput', MPAS_STREAM_PROPERTY_IMMUTABLE, .true., ierr=ierr)

   call MPAS_stream_mgr_create_stream(manager, 'ModalAerosolsInput', MPAS_STREAM_INPUT, &
'snicar_optics_5bnd_mam_c140303_mpas_cice.nc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'ModalAerosolsInput', 'modalAsymmetryParameter', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'ModalAerosolsInput', 'modalBCabsorptionParameter', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'ModalAerosolsInput', 'modalMassExtinctionCrossSection', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'ModalAerosolsInput', 'modalSingleScatterAlbedo', ierr=ierr)
   call MPAS_stream_mgr_set_property(manager, 'ModalAerosolsInput', MPAS_STREAM_PROPERTY_IMMUTABLE, .true., ierr=ierr)

   call MPAS_stream_mgr_create_stream(manager, 'SnicarInput', MPAS_STREAM_INPUT, 'snicar_optics_5bnd_snow_and_aerosols.nc', &
ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'SnicarInput', 'iceAsymmetryParameterDirect', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'SnicarInput', 'iceAsymmetryParameterDiffuse', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'SnicarInput', 'iceSingleScatterAlbedoDirect', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'SnicarInput', 'iceSingleScatterAlbedoDiffuse', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'SnicarInput', 'iceMassExtinctionCrossSectionDirect', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'SnicarInput', 'iceMassExtinctionCrossSectionDiffuse', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'SnicarInput', 'modalAsymmetryParameter5band', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'SnicarInput', 'modalBCabsorptionParameter5band', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'SnicarInput', 'modalMassExtinctionCrossSection5band', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'SnicarInput', 'modalSingleScatterAlbedo5band', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'SnicarInput', 'aerosolAsymmetryParameter5band', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'SnicarInput', 'aerosolMassExtinctionCrossSection5band', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'SnicarInput', 'aerosolSingleScatterAlbedo5band', ierr=ierr)
   call MPAS_stream_mgr_set_property(manager, 'SnicarInput', MPAS_STREAM_PROPERTY_IMMUTABLE, .true., ierr=ierr)

   call MPAS_stream_mgr_create_stream(manager, 'SnowAgingPropertiesInput', MPAS_STREAM_INPUT, &
'snicar_drdt_bst_fit_60_c04182019.nc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'SnowAgingPropertiesInput', 'snowEmpiricalGrowthParameterTau', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'SnowAgingPropertiesInput', 'snowEmpiricalGrowthParameterKappa', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'SnowAgingPropertiesInput', 'snowPropertyRate', ierr=ierr)
   call MPAS_stream_mgr_set_property(manager, 'SnowAgingPropertiesInput', MPAS_STREAM_PROPERTY_IMMUTABLE, .true., ierr=ierr)

   call MPAS_stream_mgr_create_stream(manager, 'pointLocationsInput', MPAS_STREAM_INPUT, 'points.nc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'pointLocationsInput', 'pointCellGlobalID', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'pointLocationsInput', 'pointVertexGlobalID', ierr=ierr)
   call MPAS_stream_mgr_set_property(manager, 'pointLocationsInput', MPAS_STREAM_PROPERTY_IMMUTABLE, .true., ierr=ierr)

   call MPAS_stream_mgr_create_stream(manager, 'abort_contents', MPAS_STREAM_NONE, 'abort_variables.nc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'iceAreaCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'iceVolumeCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'snowVolumeCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'surfaceTemperatureCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'uVelocityGeo', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'vVelocityGeo', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'shortwaveDown', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'longwaveDown', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'seaSurfaceTemperature', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'seaSurfaceSalinity', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'uOceanVelocityVertexGeo', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'vOceanVelocityVertexGeo', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'freezingMeltingPotential', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'shortwaveScalingFactor', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'airTemperature', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'congelation', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'frazilFormation', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'snowiceFormation', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'snowMelt', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'surfaceIceMelt', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'basalIceMelt', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'lateralIceMelt', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'airStressVertexUGeo', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'airStressVertexVGeo', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'icePressure', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'divergence', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'shear', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'principalStress1Var', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'principalStress2Var', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'iceVolumeTendencyThermodynamics', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'iceVolumeTendencyTransport', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'iceAreaTendencyThermodynamics', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'iceAreaTendencyTransport', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'iceAgeTendencyThermodynamics', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'iceAgeTendencyTransport', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'iceAgeCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'firstYearIceAreaCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'levelIceAreaCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'levelIceVolumeCell', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'ridgedIceAreaAverage', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'ridgedIceVolumeAverage', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'bulkSalinity', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'broadbandAlbedo', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'absorbedShortwaveFluxInitialArea', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'latentHeatFluxInitialArea', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'sensibleHeatFluxInitialArea', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'longwaveUpInitialArea', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'evaporativeWaterFluxInitialArea', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'meltPondAreaFinalArea', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'meltPondDepthFinalArea', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'abort_contents', 'meltPondLidThicknessFinalArea', ierr=ierr)
   call MPAS_stream_mgr_set_property(manager, 'abort_contents', MPAS_STREAM_PROPERTY_IMMUTABLE, .true., ierr=ierr)

   call MPAS_stream_mgr_create_stream(manager, 'conservationCheckRestart', MPAS_STREAM_INPUT_OUTPUT, &
'restarts/restart.AM.conservationCheck.$Y-$M-$D_$h.$m.$s.nc', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'conservationCheckRestart', 'performConservationPrecompute', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'conservationCheckRestart', 'initialEnergy', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'conservationCheckRestart', 'accumulatedSurfaceHeatFlux', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'conservationCheckRestart', 'accumulatedOceanHeatFlux', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'conservationCheckRestart', 'accumulatedFreezingPotential', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'conservationCheckRestart', 'accumulatedSnowfallHeat', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'conservationCheckRestart', 'accumulatedLatentHeat', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'conservationCheckRestart', 'initialMass', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'conservationCheckRestart', 'accumulatedRainfallRate', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'conservationCheckRestart', 'accumulatedSnowfallRate', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'conservationCheckRestart', 'accumulatedEvaporation', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'conservationCheckRestart', 'accumulatedFreshWater', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'conservationCheckRestart', 'accumulatedFrazilWater', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'conservationCheckRestart', 'initialSalt', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'conservationCheckRestart', 'accumulatedOceanSaltFlux', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'conservationCheckRestart', 'accumulatedFrazilSaltFlux', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'conservationCheckRestart', 'initialCarbon', ierr=ierr)
   call MPAS_stream_mgr_add_field(manager, 'conservationCheckRestart', 'accumulatedOceanCarbonFlux', ierr=ierr)
   call MPAS_stream_mgr_set_property(manager, 'conservationCheckRestart', MPAS_STREAM_PROPERTY_IMMUTABLE, .true., ierr=ierr)

end function seaice_setup_immutable_streams



   function seaice_setup_derived_dimensions(readDimensions, dimensionPool, configPool) result(iErr)

      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_log, only : mpas_log_write

      implicit none

      type (mpas_pool_type), intent(inout) :: readDimensions !< Input: Pool to pull read dimensions from
      type (mpas_pool_type), intent(inout) :: configPool !< Input: Pool containing namelist options with configs
      type (mpas_pool_type), intent(inout) :: dimensionPool !< Input/Output: Pool to add dimensions into

      integer :: iErr, errLevel

      integer, pointer :: nCells
      integer, pointer :: nEdges
      integer, pointer :: maxEdges
      integer, pointer :: maxEdges2
      integer, pointer :: nVertices
      integer, pointer :: ONE
      integer, pointer :: TWO
      integer, pointer :: R3
      integer, pointer :: FIFTEEN
      integer, pointer :: TWENTYONE
      integer, pointer :: vertexDegree
      integer, pointer :: nCategories
      integer, pointer :: nIceLayers
      integer, pointer :: nSnowLayers
      integer, pointer :: nHemispheres
      integer, pointer :: nQuadPoints
      integer, pointer :: nTriPerEdgeRemap
      integer, pointer :: maxCellsPerEdgeRemap
      integer, pointer :: maxEdgesPerEdgeRemap
      integer, pointer :: maxVerticesPerEdgeRemap
      integer, pointer :: nIceLayersP1
      integer, pointer :: nCategoriesP1
      integer, pointer :: nAerosols
      integer, pointer :: nSpectralIntervals
      integer, pointer :: nGrainAgingTemperature
      integer, pointer :: nGrainAgingTempGradient
      integer, pointer :: nGrainAgingSnowDensity
      integer, pointer :: nBioLayers
      integer, pointer :: nBioLayersP1
      integer, pointer :: nBioLayersP2
      integer, pointer :: nBioLayersP3
      integer, pointer :: maxAlgaeType
      integer, pointer :: maxDOCType
      integer, pointer :: maxDICType
      integer, pointer :: maxDONType
      integer, pointer :: maxIronType
      integer, pointer :: maxBCType
      integer, pointer :: maxDustType
      integer, pointer :: maxAerosolType
      integer, pointer :: nModal1
      integer, pointer :: nModal2
      integer, pointer :: nAlgae
      integer, pointer :: nDOC
      integer, pointer :: nDIC
      integer, pointer :: nDON
      integer, pointer :: nParticulateIron
      integer, pointer :: nDissolvedIron
      integer, pointer :: nzAerosols
      integer, pointer :: nShortwaveBio
      integer, pointer :: nAlgaeLayers
      integer, pointer :: nAlgaeIceLayers
      integer, pointer :: nAlgaeSnowLayers
      integer, pointer :: nDOCLayers
      integer, pointer :: nDOCIceLayers
      integer, pointer :: nDOCSnowLayers
      integer, pointer :: nDICLayers
      integer, pointer :: nDICIceLayers
      integer, pointer :: nDICSnowLayers
      integer, pointer :: nDONLayers
      integer, pointer :: nDONIceLayers
      integer, pointer :: nDONSnowLayers
      integer, pointer :: nParticulateIronLayers
      integer, pointer :: nPartIronIceLayers
      integer, pointer :: nPartIronSnowLayers
      integer, pointer :: nDissolvedIronLayers
      integer, pointer :: nDisIronIceLayers
      integer, pointer :: nDisIronSnowLayers
      integer, pointer :: nzAerosolsLayers
      integer, pointer :: nzAerosolsSnowLayers
      integer, pointer :: nzAerosolsIceLayers
      integer, pointer :: nZBGCTracers
      integer, pointer :: nRegions
      integer, pointer :: nPoints
      integer, pointer :: nPointGroups
      integer, pointer :: maxPointsInGroup
      integer, pointer :: nForcingGroupsMax
      integer, pointer :: nSpectralIntervalsSNICAR
      integer, pointer :: nSnowGrainRadiusSNICAR
      integer, pointer :: nProcs
      integer, pointer :: nMonths
      integer, pointer :: config_nCategories
      integer, pointer :: config_nIceLayers
      integer, pointer :: config_nSnowLayers
      integer, pointer :: config_AM_loadBalance_nProcs

      iErr = 0
      errLevel = mpas_pool_get_error_level()
      call mpas_pool_set_error_level(MPAS_POOL_SILENT)

      nullify(config_nCategories)
      call mpas_pool_get_config(configPool, 'config_nCategories', config_nCategories)
      nullify(config_nIceLayers)
      call mpas_pool_get_config(configPool, 'config_nIceLayers', config_nIceLayers)
      nullify(config_nSnowLayers)
      call mpas_pool_get_config(configPool, 'config_nSnowLayers', config_nSnowLayers)
      nullify(config_AM_loadBalance_nProcs)
      call mpas_pool_get_config(configPool, 'config_AM_loadBalance_nProcs', config_AM_loadBalance_nProcs)

      nullify(nCells)
      call mpas_pool_get_dimension(dimensionPool, 'nCells', nCells)
      nullify(nEdges)
      call mpas_pool_get_dimension(dimensionPool, 'nEdges', nEdges)
      nullify(maxEdges)
      call mpas_pool_get_dimension(dimensionPool, 'maxEdges', maxEdges)
      nullify(maxEdges2)
      call mpas_pool_get_dimension(dimensionPool, 'maxEdges2', maxEdges2)
      nullify(nVertices)
      call mpas_pool_get_dimension(dimensionPool, 'nVertices', nVertices)
      nullify(ONE)
      call mpas_pool_get_dimension(dimensionPool, 'ONE', ONE)
      nullify(TWO)
      call mpas_pool_get_dimension(dimensionPool, 'TWO', TWO)
      nullify(R3)
      call mpas_pool_get_dimension(dimensionPool, 'R3', R3)
      nullify(FIFTEEN)
      call mpas_pool_get_dimension(dimensionPool, 'FIFTEEN', FIFTEEN)
      nullify(TWENTYONE)
      call mpas_pool_get_dimension(dimensionPool, 'TWENTYONE', TWENTYONE)
      nullify(vertexDegree)
      call mpas_pool_get_dimension(dimensionPool, 'vertexDegree', vertexDegree)
      nullify(nCategories)
      call mpas_pool_get_dimension(dimensionPool, 'nCategories', nCategories)
      nullify(nIceLayers)
      call mpas_pool_get_dimension(dimensionPool, 'nIceLayers', nIceLayers)
      nullify(nSnowLayers)
      call mpas_pool_get_dimension(dimensionPool, 'nSnowLayers', nSnowLayers)
      nullify(nHemispheres)
      call mpas_pool_get_dimension(dimensionPool, 'nHemispheres', nHemispheres)
      nullify(nQuadPoints)
      call mpas_pool_get_dimension(dimensionPool, 'nQuadPoints', nQuadPoints)
      nullify(nTriPerEdgeRemap)
      call mpas_pool_get_dimension(dimensionPool, 'nTriPerEdgeRemap', nTriPerEdgeRemap)
      nullify(maxCellsPerEdgeRemap)
      call mpas_pool_get_dimension(dimensionPool, 'maxCellsPerEdgeRemap', maxCellsPerEdgeRemap)
      nullify(maxEdgesPerEdgeRemap)
      call mpas_pool_get_dimension(dimensionPool, 'maxEdgesPerEdgeRemap', maxEdgesPerEdgeRemap)
      nullify(maxVerticesPerEdgeRemap)
      call mpas_pool_get_dimension(dimensionPool, 'maxVerticesPerEdgeRemap', maxVerticesPerEdgeRemap)
      nullify(nIceLayersP1)
      call mpas_pool_get_dimension(dimensionPool, 'nIceLayersP1', nIceLayersP1)
      nullify(nCategoriesP1)
      call mpas_pool_get_dimension(dimensionPool, 'nCategoriesP1', nCategoriesP1)
      nullify(nAerosols)
      call mpas_pool_get_dimension(dimensionPool, 'nAerosols', nAerosols)
      nullify(nSpectralIntervals)
      call mpas_pool_get_dimension(dimensionPool, 'nSpectralIntervals', nSpectralIntervals)
      nullify(nGrainAgingTemperature)
      call mpas_pool_get_dimension(dimensionPool, 'nGrainAgingTemperature', nGrainAgingTemperature)
      nullify(nGrainAgingTempGradient)
      call mpas_pool_get_dimension(dimensionPool, 'nGrainAgingTempGradient', nGrainAgingTempGradient)
      nullify(nGrainAgingSnowDensity)
      call mpas_pool_get_dimension(dimensionPool, 'nGrainAgingSnowDensity', nGrainAgingSnowDensity)
      nullify(nBioLayers)
      call mpas_pool_get_dimension(dimensionPool, 'nBioLayers', nBioLayers)
      nullify(nBioLayersP1)
      call mpas_pool_get_dimension(dimensionPool, 'nBioLayersP1', nBioLayersP1)
      nullify(nBioLayersP2)
      call mpas_pool_get_dimension(dimensionPool, 'nBioLayersP2', nBioLayersP2)
      nullify(nBioLayersP3)
      call mpas_pool_get_dimension(dimensionPool, 'nBioLayersP3', nBioLayersP3)
      nullify(maxAlgaeType)
      call mpas_pool_get_dimension(dimensionPool, 'maxAlgaeType', maxAlgaeType)
      nullify(maxDOCType)
      call mpas_pool_get_dimension(dimensionPool, 'maxDOCType', maxDOCType)
      nullify(maxDICType)
      call mpas_pool_get_dimension(dimensionPool, 'maxDICType', maxDICType)
      nullify(maxDONType)
      call mpas_pool_get_dimension(dimensionPool, 'maxDONType', maxDONType)
      nullify(maxIronType)
      call mpas_pool_get_dimension(dimensionPool, 'maxIronType', maxIronType)
      nullify(maxBCType)
      call mpas_pool_get_dimension(dimensionPool, 'maxBCType', maxBCType)
      nullify(maxDustType)
      call mpas_pool_get_dimension(dimensionPool, 'maxDustType', maxDustType)
      nullify(maxAerosolType)
      call mpas_pool_get_dimension(dimensionPool, 'maxAerosolType', maxAerosolType)
      nullify(nModal1)
      call mpas_pool_get_dimension(dimensionPool, 'nModal1', nModal1)
      nullify(nModal2)
      call mpas_pool_get_dimension(dimensionPool, 'nModal2', nModal2)
      nullify(nAlgae)
      call mpas_pool_get_dimension(dimensionPool, 'nAlgae', nAlgae)
      nullify(nDOC)
      call mpas_pool_get_dimension(dimensionPool, 'nDOC', nDOC)
      nullify(nDIC)
      call mpas_pool_get_dimension(dimensionPool, 'nDIC', nDIC)
      nullify(nDON)
      call mpas_pool_get_dimension(dimensionPool, 'nDON', nDON)
      nullify(nParticulateIron)
      call mpas_pool_get_dimension(dimensionPool, 'nParticulateIron', nParticulateIron)
      nullify(nDissolvedIron)
      call mpas_pool_get_dimension(dimensionPool, 'nDissolvedIron', nDissolvedIron)
      nullify(nzAerosols)
      call mpas_pool_get_dimension(dimensionPool, 'nzAerosols', nzAerosols)
      nullify(nShortwaveBio)
      call mpas_pool_get_dimension(dimensionPool, 'nShortwaveBio', nShortwaveBio)
      nullify(nAlgaeLayers)
      call mpas_pool_get_dimension(dimensionPool, 'nAlgaeLayers', nAlgaeLayers)
      nullify(nAlgaeIceLayers)
      call mpas_pool_get_dimension(dimensionPool, 'nAlgaeIceLayers', nAlgaeIceLayers)
      nullify(nAlgaeSnowLayers)
      call mpas_pool_get_dimension(dimensionPool, 'nAlgaeSnowLayers', nAlgaeSnowLayers)
      nullify(nDOCLayers)
      call mpas_pool_get_dimension(dimensionPool, 'nDOCLayers', nDOCLayers)
      nullify(nDOCIceLayers)
      call mpas_pool_get_dimension(dimensionPool, 'nDOCIceLayers', nDOCIceLayers)
      nullify(nDOCSnowLayers)
      call mpas_pool_get_dimension(dimensionPool, 'nDOCSnowLayers', nDOCSnowLayers)
      nullify(nDICLayers)
      call mpas_pool_get_dimension(dimensionPool, 'nDICLayers', nDICLayers)
      nullify(nDICIceLayers)
      call mpas_pool_get_dimension(dimensionPool, 'nDICIceLayers', nDICIceLayers)
      nullify(nDICSnowLayers)
      call mpas_pool_get_dimension(dimensionPool, 'nDICSnowLayers', nDICSnowLayers)
      nullify(nDONLayers)
      call mpas_pool_get_dimension(dimensionPool, 'nDONLayers', nDONLayers)
      nullify(nDONIceLayers)
      call mpas_pool_get_dimension(dimensionPool, 'nDONIceLayers', nDONIceLayers)
      nullify(nDONSnowLayers)
      call mpas_pool_get_dimension(dimensionPool, 'nDONSnowLayers', nDONSnowLayers)
      nullify(nParticulateIronLayers)
      call mpas_pool_get_dimension(dimensionPool, 'nParticulateIronLayers', nParticulateIronLayers)
      nullify(nPartIronIceLayers)
      call mpas_pool_get_dimension(dimensionPool, 'nPartIronIceLayers', nPartIronIceLayers)
      nullify(nPartIronSnowLayers)
      call mpas_pool_get_dimension(dimensionPool, 'nPartIronSnowLayers', nPartIronSnowLayers)
      nullify(nDissolvedIronLayers)
      call mpas_pool_get_dimension(dimensionPool, 'nDissolvedIronLayers', nDissolvedIronLayers)
      nullify(nDisIronIceLayers)
      call mpas_pool_get_dimension(dimensionPool, 'nDisIronIceLayers', nDisIronIceLayers)
      nullify(nDisIronSnowLayers)
      call mpas_pool_get_dimension(dimensionPool, 'nDisIronSnowLayers', nDisIronSnowLayers)
      nullify(nzAerosolsLayers)
      call mpas_pool_get_dimension(dimensionPool, 'nzAerosolsLayers', nzAerosolsLayers)
      nullify(nzAerosolsSnowLayers)
      call mpas_pool_get_dimension(dimensionPool, 'nzAerosolsSnowLayers', nzAerosolsSnowLayers)
      nullify(nzAerosolsIceLayers)
      call mpas_pool_get_dimension(dimensionPool, 'nzAerosolsIceLayers', nzAerosolsIceLayers)
      nullify(nZBGCTracers)
      call mpas_pool_get_dimension(dimensionPool, 'nZBGCTracers', nZBGCTracers)
      nullify(nRegions)
      call mpas_pool_get_dimension(dimensionPool, 'nRegions', nRegions)
      nullify(nPoints)
      call mpas_pool_get_dimension(dimensionPool, 'nPoints', nPoints)
      nullify(nPointGroups)
      call mpas_pool_get_dimension(dimensionPool, 'nPointGroups', nPointGroups)
      nullify(maxPointsInGroup)
      call mpas_pool_get_dimension(dimensionPool, 'maxPointsInGroup', maxPointsInGroup)
      nullify(nForcingGroupsMax)
      call mpas_pool_get_dimension(dimensionPool, 'nForcingGroupsMax', nForcingGroupsMax)
      nullify(nSpectralIntervalsSNICAR)
      call mpas_pool_get_dimension(dimensionPool, 'nSpectralIntervalsSNICAR', nSpectralIntervalsSNICAR)
      nullify(nSnowGrainRadiusSNICAR)
      call mpas_pool_get_dimension(dimensionPool, 'nSnowGrainRadiusSNICAR', nSnowGrainRadiusSNICAR)
      nullify(nProcs)
      call mpas_pool_get_dimension(dimensionPool, 'nProcs', nProcs)
      nullify(nMonths)
      call mpas_pool_get_dimension(dimensionPool, 'nMonths', nMonths)

call mpas_log_write('Assigning remaining dimensions from definitions in Registry.xml ...')
      if ( .not. associated(nCells) ) then
         allocate(nCells)
         nCells = MPAS_MISSING_DIM
         call mpas_pool_add_dimension(dimensionPool, 'nCells', nCells)
      end if

      if ( .not. associated(nEdges) ) then
         allocate(nEdges)
         nEdges = MPAS_MISSING_DIM
         call mpas_pool_add_dimension(dimensionPool, 'nEdges', nEdges)
      end if

      if ( .not. associated(maxEdges) ) then
         allocate(maxEdges)
         maxEdges = MPAS_MISSING_DIM
         call mpas_pool_add_dimension(dimensionPool, 'maxEdges', maxEdges)
      end if

      if ( .not. associated(maxEdges2) ) then
         allocate(maxEdges2)
         maxEdges2 = MPAS_MISSING_DIM
         call mpas_pool_add_dimension(dimensionPool, 'maxEdges2', maxEdges2)
      end if

      if ( .not. associated(nVertices) ) then
         allocate(nVertices)
         nVertices = MPAS_MISSING_DIM
         call mpas_pool_add_dimension(dimensionPool, 'nVertices', nVertices)
      end if

      call mpas_pool_get_dimension(dimensionPool, 'ONE', ONE)
      if ( .not. associated(ONE) ) then
         allocate(ONE)
         ONE = 1
call mpas_log_write('       ONE = $i', intArgs=(/1/))
         call mpas_pool_add_dimension(dimensionPool, 'ONE', ONE)
          else if ( ONE == MPAS_MISSING_DIM ) then
         ONE = 1
          end if

      call mpas_pool_get_dimension(dimensionPool, 'TWO', TWO)
      if ( .not. associated(TWO) ) then
         allocate(TWO)
         TWO = 2
call mpas_log_write('       TWO = $i', intArgs=(/2/))
         call mpas_pool_add_dimension(dimensionPool, 'TWO', TWO)
          else if ( TWO == MPAS_MISSING_DIM ) then
         TWO = 2
          end if

      call mpas_pool_get_dimension(dimensionPool, 'R3', R3)
      if ( .not. associated(R3) ) then
         allocate(R3)
         R3 = 3
call mpas_log_write('       R3 = $i', intArgs=(/3/))
         call mpas_pool_add_dimension(dimensionPool, 'R3', R3)
          else if ( R3 == MPAS_MISSING_DIM ) then
         R3 = 3
          end if

      call mpas_pool_get_dimension(dimensionPool, 'FIFTEEN', FIFTEEN)
      if ( .not. associated(FIFTEEN) ) then
         allocate(FIFTEEN)
         FIFTEEN = 15
call mpas_log_write('       FIFTEEN = $i', intArgs=(/15/))
         call mpas_pool_add_dimension(dimensionPool, 'FIFTEEN', FIFTEEN)
          else if ( FIFTEEN == MPAS_MISSING_DIM ) then
         FIFTEEN = 15
          end if

      call mpas_pool_get_dimension(dimensionPool, 'TWENTYONE', TWENTYONE)
      if ( .not. associated(TWENTYONE) ) then
         allocate(TWENTYONE)
         TWENTYONE = 21
call mpas_log_write('       TWENTYONE = $i', intArgs=(/21/))
         call mpas_pool_add_dimension(dimensionPool, 'TWENTYONE', TWENTYONE)
          else if ( TWENTYONE == MPAS_MISSING_DIM ) then
         TWENTYONE = 21
          end if

      if ( .not. associated(vertexDegree) ) then
         allocate(vertexDegree)
         vertexDegree = MPAS_MISSING_DIM
         call mpas_pool_add_dimension(dimensionPool, 'vertexDegree', vertexDegree)
      end if

      call mpas_pool_get_dimension(dimensionPool, 'nCategories', nCategories)
      if ( .not. associated(nCategories) ) then
         allocate(nCategories)
         nCategories = config_nCategories
call mpas_log_write('       nCategories = $i (config_nCategories)', intArgs=(/config_nCategories/))
         call mpas_pool_add_dimension(dimensionPool, 'nCategories', nCategories)
          else if ( nCategories == MPAS_MISSING_DIM ) then
         nCategories = config_nCategories
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nIceLayers', nIceLayers)
      if ( .not. associated(nIceLayers) ) then
         allocate(nIceLayers)
         nIceLayers = config_nIceLayers
call mpas_log_write('       nIceLayers = $i (config_nIceLayers)', intArgs=(/config_nIceLayers/))
         call mpas_pool_add_dimension(dimensionPool, 'nIceLayers', nIceLayers)
          else if ( nIceLayers == MPAS_MISSING_DIM ) then
         nIceLayers = config_nIceLayers
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nSnowLayers', nSnowLayers)
      if ( .not. associated(nSnowLayers) ) then
         allocate(nSnowLayers)
         nSnowLayers = config_nSnowLayers
call mpas_log_write('       nSnowLayers = $i (config_nSnowLayers)', intArgs=(/config_nSnowLayers/))
         call mpas_pool_add_dimension(dimensionPool, 'nSnowLayers', nSnowLayers)
          else if ( nSnowLayers == MPAS_MISSING_DIM ) then
         nSnowLayers = config_nSnowLayers
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nHemispheres', nHemispheres)
      if ( .not. associated(nHemispheres) ) then
         allocate(nHemispheres)
         nHemispheres = 3
call mpas_log_write('       nHemispheres = $i', intArgs=(/3/))
         call mpas_pool_add_dimension(dimensionPool, 'nHemispheres', nHemispheres)
          else if ( nHemispheres == MPAS_MISSING_DIM ) then
         nHemispheres = 3
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nQuadPoints', nQuadPoints)
      if ( .not. associated(nQuadPoints) ) then
         allocate(nQuadPoints)
         nQuadPoints = 6
call mpas_log_write('       nQuadPoints = $i', intArgs=(/6/))
         call mpas_pool_add_dimension(dimensionPool, 'nQuadPoints', nQuadPoints)
          else if ( nQuadPoints == MPAS_MISSING_DIM ) then
         nQuadPoints = 6
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nTriPerEdgeRemap', nTriPerEdgeRemap)
      if ( .not. associated(nTriPerEdgeRemap) ) then
         allocate(nTriPerEdgeRemap)
         nTriPerEdgeRemap = 6
call mpas_log_write('       nTriPerEdgeRemap = $i', intArgs=(/6/))
         call mpas_pool_add_dimension(dimensionPool, 'nTriPerEdgeRemap', nTriPerEdgeRemap)
          else if ( nTriPerEdgeRemap == MPAS_MISSING_DIM ) then
         nTriPerEdgeRemap = 6
          end if

      call mpas_pool_get_dimension(dimensionPool, 'maxCellsPerEdgeRemap', maxCellsPerEdgeRemap)
      if ( .not. associated(maxCellsPerEdgeRemap) ) then
         allocate(maxCellsPerEdgeRemap)
         maxCellsPerEdgeRemap = 6
call mpas_log_write('       maxCellsPerEdgeRemap = $i', intArgs=(/6/))
         call mpas_pool_add_dimension(dimensionPool, 'maxCellsPerEdgeRemap', maxCellsPerEdgeRemap)
          else if ( maxCellsPerEdgeRemap == MPAS_MISSING_DIM ) then
         maxCellsPerEdgeRemap = 6
          end if

      call mpas_pool_get_dimension(dimensionPool, 'maxEdgesPerEdgeRemap', maxEdgesPerEdgeRemap)
      if ( .not. associated(maxEdgesPerEdgeRemap) ) then
         allocate(maxEdgesPerEdgeRemap)
         maxEdgesPerEdgeRemap = 6
call mpas_log_write('       maxEdgesPerEdgeRemap = $i', intArgs=(/6/))
         call mpas_pool_add_dimension(dimensionPool, 'maxEdgesPerEdgeRemap', maxEdgesPerEdgeRemap)
          else if ( maxEdgesPerEdgeRemap == MPAS_MISSING_DIM ) then
         maxEdgesPerEdgeRemap = 6
          end if

      call mpas_pool_get_dimension(dimensionPool, 'maxVerticesPerEdgeRemap', maxVerticesPerEdgeRemap)
      if ( .not. associated(maxVerticesPerEdgeRemap) ) then
         allocate(maxVerticesPerEdgeRemap)
         maxVerticesPerEdgeRemap = 8
call mpas_log_write('       maxVerticesPerEdgeRemap = $i', intArgs=(/8/))
         call mpas_pool_add_dimension(dimensionPool, 'maxVerticesPerEdgeRemap', maxVerticesPerEdgeRemap)
          else if ( maxVerticesPerEdgeRemap == MPAS_MISSING_DIM ) then
         maxVerticesPerEdgeRemap = 8
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nIceLayersP1', nIceLayersP1)
      if ( .not. associated(nIceLayersP1) ) then
         allocate(nIceLayersP1)
         nIceLayersP1 = nIceLayers+1
call mpas_log_write('       nIceLayersP1 = $i', intArgs=(/nIceLayers+1/))
         call mpas_pool_add_dimension(dimensionPool, 'nIceLayersP1', nIceLayersP1)
          else if ( nIceLayersP1 == MPAS_MISSING_DIM ) then
         nIceLayersP1 = nIceLayers+1
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nCategoriesP1', nCategoriesP1)
      if ( .not. associated(nCategoriesP1) ) then
         allocate(nCategoriesP1)
         nCategoriesP1 = nCategories+1
call mpas_log_write('       nCategoriesP1 = $i', intArgs=(/nCategories+1/))
         call mpas_pool_add_dimension(dimensionPool, 'nCategoriesP1', nCategoriesP1)
          else if ( nCategoriesP1 == MPAS_MISSING_DIM ) then
         nCategoriesP1 = nCategories+1
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nAerosols', nAerosols)
      if ( .not. associated(nAerosols) ) then
         allocate(nAerosols)
         nAerosols = 0
call mpas_log_write('       nAerosols = $i', intArgs=(/0/))
         call mpas_pool_add_dimension(dimensionPool, 'nAerosols', nAerosols)
          else if ( nAerosols == MPAS_MISSING_DIM ) then
         nAerosols = 0
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nSpectralIntervals', nSpectralIntervals)
      if ( .not. associated(nSpectralIntervals) ) then
         allocate(nSpectralIntervals)
         nSpectralIntervals = 3
call mpas_log_write('       nSpectralIntervals = $i', intArgs=(/3/))
         call mpas_pool_add_dimension(dimensionPool, 'nSpectralIntervals', nSpectralIntervals)
          else if ( nSpectralIntervals == MPAS_MISSING_DIM ) then
         nSpectralIntervals = 3
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nGrainAgingTemperature', nGrainAgingTemperature)
      if ( .not. associated(nGrainAgingTemperature) ) then
         allocate(nGrainAgingTemperature)
         nGrainAgingTemperature = 11
call mpas_log_write('       nGrainAgingTemperature = $i', intArgs=(/11/))
         call mpas_pool_add_dimension(dimensionPool, 'nGrainAgingTemperature', nGrainAgingTemperature)
          else if ( nGrainAgingTemperature == MPAS_MISSING_DIM ) then
         nGrainAgingTemperature = 11
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nGrainAgingTempGradient', nGrainAgingTempGradient)
      if ( .not. associated(nGrainAgingTempGradient) ) then
         allocate(nGrainAgingTempGradient)
         nGrainAgingTempGradient = 31
call mpas_log_write('       nGrainAgingTempGradient = $i', intArgs=(/31/))
         call mpas_pool_add_dimension(dimensionPool, 'nGrainAgingTempGradient', nGrainAgingTempGradient)
          else if ( nGrainAgingTempGradient == MPAS_MISSING_DIM ) then
         nGrainAgingTempGradient = 31
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nGrainAgingSnowDensity', nGrainAgingSnowDensity)
      if ( .not. associated(nGrainAgingSnowDensity) ) then
         allocate(nGrainAgingSnowDensity)
         nGrainAgingSnowDensity = 8
call mpas_log_write('       nGrainAgingSnowDensity = $i', intArgs=(/8/))
         call mpas_pool_add_dimension(dimensionPool, 'nGrainAgingSnowDensity', nGrainAgingSnowDensity)
          else if ( nGrainAgingSnowDensity == MPAS_MISSING_DIM ) then
         nGrainAgingSnowDensity = 8
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nBioLayers', nBioLayers)
      if ( .not. associated(nBioLayers) ) then
         allocate(nBioLayers)
         nBioLayers = 7
call mpas_log_write('       nBioLayers = $i', intArgs=(/7/))
         call mpas_pool_add_dimension(dimensionPool, 'nBioLayers', nBioLayers)
          else if ( nBioLayers == MPAS_MISSING_DIM ) then
         nBioLayers = 7
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nBioLayersP1', nBioLayersP1)
      if ( .not. associated(nBioLayersP1) ) then
         allocate(nBioLayersP1)
         nBioLayersP1 = nBioLayers+1
call mpas_log_write('       nBioLayersP1 = $i', intArgs=(/nBioLayers+1/))
         call mpas_pool_add_dimension(dimensionPool, 'nBioLayersP1', nBioLayersP1)
          else if ( nBioLayersP1 == MPAS_MISSING_DIM ) then
         nBioLayersP1 = nBioLayers+1
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nBioLayersP2', nBioLayersP2)
      if ( .not. associated(nBioLayersP2) ) then
         allocate(nBioLayersP2)
         nBioLayersP2 = nBioLayers+2
call mpas_log_write('       nBioLayersP2 = $i', intArgs=(/nBioLayers+2/))
         call mpas_pool_add_dimension(dimensionPool, 'nBioLayersP2', nBioLayersP2)
          else if ( nBioLayersP2 == MPAS_MISSING_DIM ) then
         nBioLayersP2 = nBioLayers+2
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nBioLayersP3', nBioLayersP3)
      if ( .not. associated(nBioLayersP3) ) then
         allocate(nBioLayersP3)
         nBioLayersP3 = nBioLayers+3
call mpas_log_write('       nBioLayersP3 = $i', intArgs=(/nBioLayers+3/))
         call mpas_pool_add_dimension(dimensionPool, 'nBioLayersP3', nBioLayersP3)
          else if ( nBioLayersP3 == MPAS_MISSING_DIM ) then
         nBioLayersP3 = nBioLayers+3
          end if

      call mpas_pool_get_dimension(dimensionPool, 'maxAlgaeType', maxAlgaeType)
      if ( .not. associated(maxAlgaeType) ) then
         allocate(maxAlgaeType)
         maxAlgaeType = 3
call mpas_log_write('       maxAlgaeType = $i', intArgs=(/3/))
         call mpas_pool_add_dimension(dimensionPool, 'maxAlgaeType', maxAlgaeType)
          else if ( maxAlgaeType == MPAS_MISSING_DIM ) then
         maxAlgaeType = 3
          end if

      call mpas_pool_get_dimension(dimensionPool, 'maxDOCType', maxDOCType)
      if ( .not. associated(maxDOCType) ) then
         allocate(maxDOCType)
         maxDOCType = 3
call mpas_log_write('       maxDOCType = $i', intArgs=(/3/))
         call mpas_pool_add_dimension(dimensionPool, 'maxDOCType', maxDOCType)
          else if ( maxDOCType == MPAS_MISSING_DIM ) then
         maxDOCType = 3
          end if

      call mpas_pool_get_dimension(dimensionPool, 'maxDICType', maxDICType)
      if ( .not. associated(maxDICType) ) then
         allocate(maxDICType)
         maxDICType = 1
call mpas_log_write('       maxDICType = $i', intArgs=(/1/))
         call mpas_pool_add_dimension(dimensionPool, 'maxDICType', maxDICType)
          else if ( maxDICType == MPAS_MISSING_DIM ) then
         maxDICType = 1
          end if

      call mpas_pool_get_dimension(dimensionPool, 'maxDONType', maxDONType)
      if ( .not. associated(maxDONType) ) then
         allocate(maxDONType)
         maxDONType = 1
call mpas_log_write('       maxDONType = $i', intArgs=(/1/))
         call mpas_pool_add_dimension(dimensionPool, 'maxDONType', maxDONType)
          else if ( maxDONType == MPAS_MISSING_DIM ) then
         maxDONType = 1
          end if

      call mpas_pool_get_dimension(dimensionPool, 'maxIronType', maxIronType)
      if ( .not. associated(maxIronType) ) then
         allocate(maxIronType)
         maxIronType = 2
call mpas_log_write('       maxIronType = $i', intArgs=(/2/))
         call mpas_pool_add_dimension(dimensionPool, 'maxIronType', maxIronType)
          else if ( maxIronType == MPAS_MISSING_DIM ) then
         maxIronType = 2
          end if

      call mpas_pool_get_dimension(dimensionPool, 'maxBCType', maxBCType)
      if ( .not. associated(maxBCType) ) then
         allocate(maxBCType)
         maxBCType = 2
call mpas_log_write('       maxBCType = $i', intArgs=(/2/))
         call mpas_pool_add_dimension(dimensionPool, 'maxBCType', maxBCType)
          else if ( maxBCType == MPAS_MISSING_DIM ) then
         maxBCType = 2
          end if

      call mpas_pool_get_dimension(dimensionPool, 'maxDustType', maxDustType)
      if ( .not. associated(maxDustType) ) then
         allocate(maxDustType)
         maxDustType = 4
call mpas_log_write('       maxDustType = $i', intArgs=(/4/))
         call mpas_pool_add_dimension(dimensionPool, 'maxDustType', maxDustType)
          else if ( maxDustType == MPAS_MISSING_DIM ) then
         maxDustType = 4
          end if

      call mpas_pool_get_dimension(dimensionPool, 'maxAerosolType', maxAerosolType)
      if ( .not. associated(maxAerosolType) ) then
         allocate(maxAerosolType)
         maxAerosolType = maxBCType+maxDustType
call mpas_log_write('       maxAerosolType = $i', intArgs=(/maxBCType+maxDustType/))
         call mpas_pool_add_dimension(dimensionPool, 'maxAerosolType', maxAerosolType)
          else if ( maxAerosolType == MPAS_MISSING_DIM ) then
         maxAerosolType = maxBCType+maxDustType
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nModal1', nModal1)
      if ( .not. associated(nModal1) ) then
         allocate(nModal1)
         nModal1 = 10
call mpas_log_write('       nModal1 = $i', intArgs=(/10/))
         call mpas_pool_add_dimension(dimensionPool, 'nModal1', nModal1)
          else if ( nModal1 == MPAS_MISSING_DIM ) then
         nModal1 = 10
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nModal2', nModal2)
      if ( .not. associated(nModal2) ) then
         allocate(nModal2)
         nModal2 = 8
call mpas_log_write('       nModal2 = $i', intArgs=(/8/))
         call mpas_pool_add_dimension(dimensionPool, 'nModal2', nModal2)
          else if ( nModal2 == MPAS_MISSING_DIM ) then
         nModal2 = 8
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nAlgae', nAlgae)
      if ( .not. associated(nAlgae) ) then
         allocate(nAlgae)
         nAlgae = 3
call mpas_log_write('       nAlgae = $i', intArgs=(/3/))
         call mpas_pool_add_dimension(dimensionPool, 'nAlgae', nAlgae)
          else if ( nAlgae == MPAS_MISSING_DIM ) then
         nAlgae = 3
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nDOC', nDOC)
      if ( .not. associated(nDOC) ) then
         allocate(nDOC)
         nDOC = 2
call mpas_log_write('       nDOC = $i', intArgs=(/2/))
         call mpas_pool_add_dimension(dimensionPool, 'nDOC', nDOC)
          else if ( nDOC == MPAS_MISSING_DIM ) then
         nDOC = 2
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nDIC', nDIC)
      if ( .not. associated(nDIC) ) then
         allocate(nDIC)
         nDIC = 1
call mpas_log_write('       nDIC = $i', intArgs=(/1/))
         call mpas_pool_add_dimension(dimensionPool, 'nDIC', nDIC)
          else if ( nDIC == MPAS_MISSING_DIM ) then
         nDIC = 1
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nDON', nDON)
      if ( .not. associated(nDON) ) then
         allocate(nDON)
         nDON = 1
call mpas_log_write('       nDON = $i', intArgs=(/1/))
         call mpas_pool_add_dimension(dimensionPool, 'nDON', nDON)
          else if ( nDON == MPAS_MISSING_DIM ) then
         nDON = 1
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nParticulateIron', nParticulateIron)
      if ( .not. associated(nParticulateIron) ) then
         allocate(nParticulateIron)
         nParticulateIron = 1
call mpas_log_write('       nParticulateIron = $i', intArgs=(/1/))
         call mpas_pool_add_dimension(dimensionPool, 'nParticulateIron', nParticulateIron)
          else if ( nParticulateIron == MPAS_MISSING_DIM ) then
         nParticulateIron = 1
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nDissolvedIron', nDissolvedIron)
      if ( .not. associated(nDissolvedIron) ) then
         allocate(nDissolvedIron)
         nDissolvedIron = 1
call mpas_log_write('       nDissolvedIron = $i', intArgs=(/1/))
         call mpas_pool_add_dimension(dimensionPool, 'nDissolvedIron', nDissolvedIron)
          else if ( nDissolvedIron == MPAS_MISSING_DIM ) then
         nDissolvedIron = 1
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nzAerosols', nzAerosols)
      if ( .not. associated(nzAerosols) ) then
         allocate(nzAerosols)
         nzAerosols = 3
call mpas_log_write('       nzAerosols = $i', intArgs=(/3/))
         call mpas_pool_add_dimension(dimensionPool, 'nzAerosols', nzAerosols)
          else if ( nzAerosols == MPAS_MISSING_DIM ) then
         nzAerosols = 3
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nShortwaveBio', nShortwaveBio)
      if ( .not. associated(nShortwaveBio) ) then
         allocate(nShortwaveBio)
         nShortwaveBio = (nIceLayers+nSnowLayers+2)*(ONE+nzAerosols)
call mpas_log_write('       nShortwaveBio = $i', intArgs=(/(nIceLayers+nSnowLayers+2)*(ONE+nzAerosols)/))
         call mpas_pool_add_dimension(dimensionPool, 'nShortwaveBio', nShortwaveBio)
          else if ( nShortwaveBio == MPAS_MISSING_DIM ) then
         nShortwaveBio = (nIceLayers+nSnowLayers+2)*(ONE+nzAerosols)
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nAlgaeLayers', nAlgaeLayers)
      if ( .not. associated(nAlgaeLayers) ) then
         allocate(nAlgaeLayers)
         nAlgaeLayers = nBioLayersP3*nAlgae
call mpas_log_write('       nAlgaeLayers = $i', intArgs=(/nBioLayersP3*nAlgae/))
         call mpas_pool_add_dimension(dimensionPool, 'nAlgaeLayers', nAlgaeLayers)
          else if ( nAlgaeLayers == MPAS_MISSING_DIM ) then
         nAlgaeLayers = nBioLayersP3*nAlgae
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nAlgaeIceLayers', nAlgaeIceLayers)
      if ( .not. associated(nAlgaeIceLayers) ) then
         allocate(nAlgaeIceLayers)
         nAlgaeIceLayers = nBioLayersP1*nAlgae
call mpas_log_write('       nAlgaeIceLayers = $i', intArgs=(/nBioLayersP1*nAlgae/))
         call mpas_pool_add_dimension(dimensionPool, 'nAlgaeIceLayers', nAlgaeIceLayers)
          else if ( nAlgaeIceLayers == MPAS_MISSING_DIM ) then
         nAlgaeIceLayers = nBioLayersP1*nAlgae
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nAlgaeSnowLayers', nAlgaeSnowLayers)
      if ( .not. associated(nAlgaeSnowLayers) ) then
         allocate(nAlgaeSnowLayers)
         nAlgaeSnowLayers = TWO*nAlgae
call mpas_log_write('       nAlgaeSnowLayers = $i', intArgs=(/TWO*nAlgae/))
         call mpas_pool_add_dimension(dimensionPool, 'nAlgaeSnowLayers', nAlgaeSnowLayers)
          else if ( nAlgaeSnowLayers == MPAS_MISSING_DIM ) then
         nAlgaeSnowLayers = TWO*nAlgae
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nDOCLayers', nDOCLayers)
      if ( .not. associated(nDOCLayers) ) then
         allocate(nDOCLayers)
         nDOCLayers = nBioLayersP3*nDOC
call mpas_log_write('       nDOCLayers = $i', intArgs=(/nBioLayersP3*nDOC/))
         call mpas_pool_add_dimension(dimensionPool, 'nDOCLayers', nDOCLayers)
          else if ( nDOCLayers == MPAS_MISSING_DIM ) then
         nDOCLayers = nBioLayersP3*nDOC
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nDOCIceLayers', nDOCIceLayers)
      if ( .not. associated(nDOCIceLayers) ) then
         allocate(nDOCIceLayers)
         nDOCIceLayers = nBioLayersP1*nDOC
call mpas_log_write('       nDOCIceLayers = $i', intArgs=(/nBioLayersP1*nDOC/))
         call mpas_pool_add_dimension(dimensionPool, 'nDOCIceLayers', nDOCIceLayers)
          else if ( nDOCIceLayers == MPAS_MISSING_DIM ) then
         nDOCIceLayers = nBioLayersP1*nDOC
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nDOCSnowLayers', nDOCSnowLayers)
      if ( .not. associated(nDOCSnowLayers) ) then
         allocate(nDOCSnowLayers)
         nDOCSnowLayers = TWO*nDOC
call mpas_log_write('       nDOCSnowLayers = $i', intArgs=(/TWO*nDOC/))
         call mpas_pool_add_dimension(dimensionPool, 'nDOCSnowLayers', nDOCSnowLayers)
          else if ( nDOCSnowLayers == MPAS_MISSING_DIM ) then
         nDOCSnowLayers = TWO*nDOC
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nDICLayers', nDICLayers)
      if ( .not. associated(nDICLayers) ) then
         allocate(nDICLayers)
         nDICLayers = nBioLayersP3*nDIC
call mpas_log_write('       nDICLayers = $i', intArgs=(/nBioLayersP3*nDIC/))
         call mpas_pool_add_dimension(dimensionPool, 'nDICLayers', nDICLayers)
          else if ( nDICLayers == MPAS_MISSING_DIM ) then
         nDICLayers = nBioLayersP3*nDIC
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nDICIceLayers', nDICIceLayers)
      if ( .not. associated(nDICIceLayers) ) then
         allocate(nDICIceLayers)
         nDICIceLayers = nBioLayersP1*nDIC
call mpas_log_write('       nDICIceLayers = $i', intArgs=(/nBioLayersP1*nDIC/))
         call mpas_pool_add_dimension(dimensionPool, 'nDICIceLayers', nDICIceLayers)
          else if ( nDICIceLayers == MPAS_MISSING_DIM ) then
         nDICIceLayers = nBioLayersP1*nDIC
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nDICSnowLayers', nDICSnowLayers)
      if ( .not. associated(nDICSnowLayers) ) then
         allocate(nDICSnowLayers)
         nDICSnowLayers = TWO*nDIC
call mpas_log_write('       nDICSnowLayers = $i', intArgs=(/TWO*nDIC/))
         call mpas_pool_add_dimension(dimensionPool, 'nDICSnowLayers', nDICSnowLayers)
          else if ( nDICSnowLayers == MPAS_MISSING_DIM ) then
         nDICSnowLayers = TWO*nDIC
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nDONLayers', nDONLayers)
      if ( .not. associated(nDONLayers) ) then
         allocate(nDONLayers)
         nDONLayers = nBioLayersP3*nDON
call mpas_log_write('       nDONLayers = $i', intArgs=(/nBioLayersP3*nDON/))
         call mpas_pool_add_dimension(dimensionPool, 'nDONLayers', nDONLayers)
          else if ( nDONLayers == MPAS_MISSING_DIM ) then
         nDONLayers = nBioLayersP3*nDON
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nDONIceLayers', nDONIceLayers)
      if ( .not. associated(nDONIceLayers) ) then
         allocate(nDONIceLayers)
         nDONIceLayers = nBioLayersP1*nDON
call mpas_log_write('       nDONIceLayers = $i', intArgs=(/nBioLayersP1*nDON/))
         call mpas_pool_add_dimension(dimensionPool, 'nDONIceLayers', nDONIceLayers)
          else if ( nDONIceLayers == MPAS_MISSING_DIM ) then
         nDONIceLayers = nBioLayersP1*nDON
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nDONSnowLayers', nDONSnowLayers)
      if ( .not. associated(nDONSnowLayers) ) then
         allocate(nDONSnowLayers)
         nDONSnowLayers = TWO*nDON
call mpas_log_write('       nDONSnowLayers = $i', intArgs=(/TWO*nDON/))
         call mpas_pool_add_dimension(dimensionPool, 'nDONSnowLayers', nDONSnowLayers)
          else if ( nDONSnowLayers == MPAS_MISSING_DIM ) then
         nDONSnowLayers = TWO*nDON
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nParticulateIronLayers', nParticulateIronLayers)
      if ( .not. associated(nParticulateIronLayers) ) then
         allocate(nParticulateIronLayers)
         nParticulateIronLayers = nBioLayersP3*nParticulateIron
call mpas_log_write('       nParticulateIronLayers = $i', intArgs=(/nBioLayersP3*nParticulateIron/))
         call mpas_pool_add_dimension(dimensionPool, 'nParticulateIronLayers', nParticulateIronLayers)
          else if ( nParticulateIronLayers == MPAS_MISSING_DIM ) then
         nParticulateIronLayers = nBioLayersP3*nParticulateIron
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nPartIronIceLayers', nPartIronIceLayers)
      if ( .not. associated(nPartIronIceLayers) ) then
         allocate(nPartIronIceLayers)
         nPartIronIceLayers = nBioLayersP1*nParticulateIron
call mpas_log_write('       nPartIronIceLayers = $i', intArgs=(/nBioLayersP1*nParticulateIron/))
         call mpas_pool_add_dimension(dimensionPool, 'nPartIronIceLayers', nPartIronIceLayers)
          else if ( nPartIronIceLayers == MPAS_MISSING_DIM ) then
         nPartIronIceLayers = nBioLayersP1*nParticulateIron
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nPartIronSnowLayers', nPartIronSnowLayers)
      if ( .not. associated(nPartIronSnowLayers) ) then
         allocate(nPartIronSnowLayers)
         nPartIronSnowLayers = TWO*nParticulateIron
call mpas_log_write('       nPartIronSnowLayers = $i', intArgs=(/TWO*nParticulateIron/))
         call mpas_pool_add_dimension(dimensionPool, 'nPartIronSnowLayers', nPartIronSnowLayers)
          else if ( nPartIronSnowLayers == MPAS_MISSING_DIM ) then
         nPartIronSnowLayers = TWO*nParticulateIron
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nDissolvedIronLayers', nDissolvedIronLayers)
      if ( .not. associated(nDissolvedIronLayers) ) then
         allocate(nDissolvedIronLayers)
         nDissolvedIronLayers = nBioLayersP3*nDissolvedIron
call mpas_log_write('       nDissolvedIronLayers = $i', intArgs=(/nBioLayersP3*nDissolvedIron/))
         call mpas_pool_add_dimension(dimensionPool, 'nDissolvedIronLayers', nDissolvedIronLayers)
          else if ( nDissolvedIronLayers == MPAS_MISSING_DIM ) then
         nDissolvedIronLayers = nBioLayersP3*nDissolvedIron
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nDisIronIceLayers', nDisIronIceLayers)
      if ( .not. associated(nDisIronIceLayers) ) then
         allocate(nDisIronIceLayers)
         nDisIronIceLayers = nBioLayersP1*nDissolvedIron
call mpas_log_write('       nDisIronIceLayers = $i', intArgs=(/nBioLayersP1*nDissolvedIron/))
         call mpas_pool_add_dimension(dimensionPool, 'nDisIronIceLayers', nDisIronIceLayers)
          else if ( nDisIronIceLayers == MPAS_MISSING_DIM ) then
         nDisIronIceLayers = nBioLayersP1*nDissolvedIron
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nDisIronSnowLayers', nDisIronSnowLayers)
      if ( .not. associated(nDisIronSnowLayers) ) then
         allocate(nDisIronSnowLayers)
         nDisIronSnowLayers = TWO*nDissolvedIron
call mpas_log_write('       nDisIronSnowLayers = $i', intArgs=(/TWO*nDissolvedIron/))
         call mpas_pool_add_dimension(dimensionPool, 'nDisIronSnowLayers', nDisIronSnowLayers)
          else if ( nDisIronSnowLayers == MPAS_MISSING_DIM ) then
         nDisIronSnowLayers = TWO*nDissolvedIron
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nzAerosolsLayers', nzAerosolsLayers)
      if ( .not. associated(nzAerosolsLayers) ) then
         allocate(nzAerosolsLayers)
         nzAerosolsLayers = nBioLayersP3*nzAerosols
call mpas_log_write('       nzAerosolsLayers = $i', intArgs=(/nBioLayersP3*nzAerosols/))
         call mpas_pool_add_dimension(dimensionPool, 'nzAerosolsLayers', nzAerosolsLayers)
          else if ( nzAerosolsLayers == MPAS_MISSING_DIM ) then
         nzAerosolsLayers = nBioLayersP3*nzAerosols
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nzAerosolsSnowLayers', nzAerosolsSnowLayers)
      if ( .not. associated(nzAerosolsSnowLayers) ) then
         allocate(nzAerosolsSnowLayers)
         nzAerosolsSnowLayers = TWO*nzAerosols
call mpas_log_write('       nzAerosolsSnowLayers = $i', intArgs=(/TWO*nzAerosols/))
         call mpas_pool_add_dimension(dimensionPool, 'nzAerosolsSnowLayers', nzAerosolsSnowLayers)
          else if ( nzAerosolsSnowLayers == MPAS_MISSING_DIM ) then
         nzAerosolsSnowLayers = TWO*nzAerosols
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nzAerosolsIceLayers', nzAerosolsIceLayers)
      if ( .not. associated(nzAerosolsIceLayers) ) then
         allocate(nzAerosolsIceLayers)
         nzAerosolsIceLayers = nBioLayersP1*nzAerosols
call mpas_log_write('       nzAerosolsIceLayers = $i', intArgs=(/nBioLayersP1*nzAerosols/))
         call mpas_pool_add_dimension(dimensionPool, 'nzAerosolsIceLayers', nzAerosolsIceLayers)
          else if ( nzAerosolsIceLayers == MPAS_MISSING_DIM ) then
         nzAerosolsIceLayers = nBioLayersP1*nzAerosols
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nZBGCTracers', nZBGCTracers)
      if ( .not. associated(nZBGCTracers) ) then
         allocate(nZBGCTracers)
         nZBGCTracers = 29
call mpas_log_write('       nZBGCTracers = $i', intArgs=(/29/))
         call mpas_pool_add_dimension(dimensionPool, 'nZBGCTracers', nZBGCTracers)
          else if ( nZBGCTracers == MPAS_MISSING_DIM ) then
         nZBGCTracers = 29
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nRegions', nRegions)
      if ( .not. associated(nRegions) ) then
         allocate(nRegions)
         nRegions = 3
call mpas_log_write('       nRegions = $i', intArgs=(/3/))
         call mpas_pool_add_dimension(dimensionPool, 'nRegions', nRegions)
          else if ( nRegions == MPAS_MISSING_DIM ) then
         nRegions = 3
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nPoints', nPoints)
      if ( .not. associated(nPoints) ) then
         allocate(nPoints)
         nPoints = 1
call mpas_log_write('       nPoints = $i', intArgs=(/1/))
         call mpas_pool_add_dimension(dimensionPool, 'nPoints', nPoints)
          else if ( nPoints == MPAS_MISSING_DIM ) then
         nPoints = 1
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nPointGroups', nPointGroups)
      if ( .not. associated(nPointGroups) ) then
         allocate(nPointGroups)
         nPointGroups = 1
call mpas_log_write('       nPointGroups = $i', intArgs=(/1/))
         call mpas_pool_add_dimension(dimensionPool, 'nPointGroups', nPointGroups)
          else if ( nPointGroups == MPAS_MISSING_DIM ) then
         nPointGroups = 1
          end if

      call mpas_pool_get_dimension(dimensionPool, 'maxPointsInGroup', maxPointsInGroup)
      if ( .not. associated(maxPointsInGroup) ) then
         allocate(maxPointsInGroup)
         maxPointsInGroup = 1
call mpas_log_write('       maxPointsInGroup = $i', intArgs=(/1/))
         call mpas_pool_add_dimension(dimensionPool, 'maxPointsInGroup', maxPointsInGroup)
          else if ( maxPointsInGroup == MPAS_MISSING_DIM ) then
         maxPointsInGroup = 1
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nForcingGroupsMax', nForcingGroupsMax)
      if ( .not. associated(nForcingGroupsMax) ) then
         allocate(nForcingGroupsMax)
         nForcingGroupsMax = 5
call mpas_log_write('       nForcingGroupsMax = $i', intArgs=(/5/))
         call mpas_pool_add_dimension(dimensionPool, 'nForcingGroupsMax', nForcingGroupsMax)
          else if ( nForcingGroupsMax == MPAS_MISSING_DIM ) then
         nForcingGroupsMax = 5
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nSpectralIntervalsSNICAR', nSpectralIntervalsSNICAR)
      if ( .not. associated(nSpectralIntervalsSNICAR) ) then
         allocate(nSpectralIntervalsSNICAR)
         nSpectralIntervalsSNICAR = 5
call mpas_log_write('       nSpectralIntervalsSNICAR = $i', intArgs=(/5/))
         call mpas_pool_add_dimension(dimensionPool, 'nSpectralIntervalsSNICAR', nSpectralIntervalsSNICAR)
          else if ( nSpectralIntervalsSNICAR == MPAS_MISSING_DIM ) then
         nSpectralIntervalsSNICAR = 5
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nSnowGrainRadiusSNICAR', nSnowGrainRadiusSNICAR)
      if ( .not. associated(nSnowGrainRadiusSNICAR) ) then
         allocate(nSnowGrainRadiusSNICAR)
         nSnowGrainRadiusSNICAR = 1471
call mpas_log_write('       nSnowGrainRadiusSNICAR = $i', intArgs=(/1471/))
         call mpas_pool_add_dimension(dimensionPool, 'nSnowGrainRadiusSNICAR', nSnowGrainRadiusSNICAR)
          else if ( nSnowGrainRadiusSNICAR == MPAS_MISSING_DIM ) then
         nSnowGrainRadiusSNICAR = 1471
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nProcs', nProcs)
      if ( .not. associated(nProcs) ) then
         allocate(nProcs)
         nProcs = config_AM_loadBalance_nProcs
call mpas_log_write('       nProcs = $i (config_AM_loadBalance_nProcs)', intArgs=(/config_AM_loadBalance_nProcs/))
         call mpas_pool_add_dimension(dimensionPool, 'nProcs', nProcs)
          else if ( nProcs == MPAS_MISSING_DIM ) then
         nProcs = config_AM_loadBalance_nProcs
          end if

      call mpas_pool_get_dimension(dimensionPool, 'nMonths', nMonths)
      if ( .not. associated(nMonths) ) then
         allocate(nMonths)
         nMonths = 13
call mpas_log_write('       nMonths = $i', intArgs=(/13/))
         call mpas_pool_add_dimension(dimensionPool, 'nMonths', nMonths)
          else if ( nMonths == MPAS_MISSING_DIM ) then
         nMonths = 13
          end if

      call mpas_log_write(' ')
      call mpas_log_write(' ----- done assigning dimensions from Registry.xml -----')
      call mpas_log_write(' ')
      call mpas_log_write(' ')
      call mpas_pool_set_error_level(errLevel)

   end function seaice_setup_derived_dimensions


   function seaice_setup_decomposed_dimensions(block, manager, readDimensions, dimensionPool, totalBlocks) result(iErr)

      use mpas_derived_types
      use mpas_decomp
      use mpas_pool_routines
      use mpas_io_units
      use mpas_abort, only : mpas_dmpar_global_abort
      use mpas_log, only : mpas_log_write

      implicit none

      type (block_type), intent(inout) :: block !< Input: Pointer to block
      type (mpas_streamManager_type), intent(inout) :: manager !< Input: Stream manager
      type (mpas_pool_type), intent(inout) :: readDimensions !< Input: Pool to pull read dimensions from
      type (mpas_pool_type), intent(inout) :: dimensionPool !< Input/Output: Pool to add dimensions into
      integer, intent(in) :: totalBlocks !< Input: Number of blocks

      integer :: iErr
      type (field1DInteger), pointer :: ownedIndices
      procedure (mpas_decomp_function), pointer :: decompFunc


      iErr = 0
      call mpas_log_write('Processing decomposed dimensions ...')

      call mpas_log_write(' ')
      call mpas_log_write(' ----- done processing decomposed dimensions -----')
      call mpas_log_write(' ')
      call mpas_log_write(' ')

   end function seaice_setup_decomposed_dimensions

   function seaice_define_packages(packagePool) result(iErr)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      implicit none
      type (mpas_pool_type), intent(inout) :: packagePool !< Input: MPAS Pool for containing package logicals.

      integer :: iErr

      iErr = 0
      call mpas_pool_add_package(packagePool, 'pkgWeakActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgVariationalActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgWeakVariationalActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgColumnPackageActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgColumnBiogeochemistryActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgColumnTracerIceAgeActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgColumnTracerFirstYearIceActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgColumnTracerLevelIceActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgColumnTracerPondsActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgColumnTracerLidThicknessActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgColumnTracerAerosolsActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgTracerBrineActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgTracerMobileFractionActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgTracerSkeletalAlgaeActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgTracerSkeletalNitrateActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgTracerSkeletalCarbonActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgTracerSkeletalSilicateActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgTracerSkeletalDMSActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgTracerSkeletalHumicsActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgTracerSkeletalDONActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgTracerSkeletalIronActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgTracerVerticalAlgaeActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgTracerVerticalNitrateActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgTracerVerticalCarbonActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgTracerVerticalAmmoniumActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgTracerVerticalSilicateActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgTracerVerticalDMSActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgTracerVerticalNonreactiveActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgTracerVerticalHumicsActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgTracerVerticalDONActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgTracerVerticalIronActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgTracerZAerosolsActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgTracerZSalinityActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgColumnFormDragActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgBergsActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgTestingSystemTestActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgForcingActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgSnicarActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgPrescribedActive', .false.)
      call mpas_pool_add_package(packagePool, 'pkgSpecialBoundariesActive', .false.)
      call mpas_pool_add_package(packagePool, 'highFrequencyOutputAMPKGActive', .false.)
      call mpas_pool_add_package(packagePool, 'temperaturesAMPKGActive', .false.)
      call mpas_pool_add_package(packagePool, 'regionalStatisticsAMPKGActive', .false.)
      call mpas_pool_add_package(packagePool, 'ridgingDiagnosticsAMPKGActive', .false.)
      call mpas_pool_add_package(packagePool, 'conservationCheckAMPKGActive', .false.)
      call mpas_pool_add_package(packagePool, 'geographicalVectorsAMPKGActive', .false.)
      call mpas_pool_add_package(packagePool, 'loadBalanceAMPKGActive', .false.)
      call mpas_pool_add_package(packagePool, 'maximumIcePresenceAMPKGActive', .false.)
      call mpas_pool_add_package(packagePool, 'miscellaneousAMPKGActive', .false.)
      call mpas_pool_add_package(packagePool, 'areaVariablesAMPKGActive', .false.)
      call mpas_pool_add_package(packagePool, 'pondDiagnosticsAMPKGActive', .false.)
      call mpas_pool_add_package(packagePool, 'unitConversionAMPKGActive', .false.)
      call mpas_pool_add_package(packagePool, 'pointwiseStatsAMPKGActive', .false.)
      call mpas_pool_add_package(packagePool, 'iceShelvesAMPKGActive', .false.)
      call mpas_pool_add_package(packagePool, 'icePresentAMPKGActive', .false.)
      call mpas_pool_add_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', .false.)
      call mpas_pool_add_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', .false.)
      call mpas_pool_add_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', .false.)
      call mpas_pool_add_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', .false.)
   end function seaice_define_packages

   subroutine seaice_generate_pool_mesh(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'mesh', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'mesh', newSubPool)

! Define variable latCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'latCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'radians')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Latitude location of cell centers in radians.')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'latCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'latCell', r1Ptr)

! Define variable lonCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'lonCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'radians')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Longitude location of cell centers in radians.')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'lonCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'lonCell', r1Ptr)

! Define variable xCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'xCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'X Coordinate in cartesian space of cell centers.')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'xCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'xCell', r1Ptr)

! Define variable yCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'yCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Y Coordinate in cartesian space of cell centers.')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'yCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'yCell', r1Ptr)

! Define variable zCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'zCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Z Coordinate in cartesian space of cell centers.')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'zCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zCell', r1Ptr)

! Define variable indexToCellID
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'indexToCellID'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .false.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nCells'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'long_name', 'List of global cell IDs.')
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'indexToCellID', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'indexToCellID', i1Ptr)

! Define variable latEdge
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'latEdge'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'radians')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Latitude location of edge midpoints in radians.')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'latEdge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'latEdge', r1Ptr)

! Define variable lonEdge
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'lonEdge'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'radians')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Longitude location of edge midpoints in radians.')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'lonEdge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'lonEdge', r1Ptr)

! Define variable xEdge
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'xEdge'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'X Coordinate in cartesian space of edge midpoints.')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'xEdge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'xEdge', r1Ptr)

! Define variable yEdge
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'yEdge'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Y Coordinate in cartesian space of edge midpoints.')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'yEdge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'yEdge', r1Ptr)

! Define variable zEdge
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'zEdge'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Z Coordinate in cartesian space of edge midpoints.')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'zEdge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zEdge', r1Ptr)

! Define variable indexToEdgeID
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'indexToEdgeID'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .false.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nEdges'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'long_name', 'List of global edge IDs.')
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'indexToEdgeID', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'indexToEdgeID', i1Ptr)

! Define variable latVertex
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'latVertex'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'radians')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Latitude location of vertices in radians.')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'latVertex', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'latVertex', r1Ptr)

! Define variable lonVertex
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'lonVertex'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'radians')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Longitude location of vertices in radians.')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'lonVertex', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'lonVertex', r1Ptr)

! Define variable xVertex
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'xVertex'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'X Coordinate in cartesian space of vertices.')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'xVertex', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'xVertex', r1Ptr)

! Define variable yVertex
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'yVertex'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Y Coordinate in cartesian space of vertices.')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'yVertex', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'yVertex', r1Ptr)

! Define variable zVertex
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'zVertex'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Z Coordinate in cartesian space of vertices.')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'zVertex', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zVertex', r1Ptr)

! Define variable indexToVertexID
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'indexToVertexID'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .false.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nVertices'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'long_name', 'List of global vertex IDs.')
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'indexToVertexID', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'indexToVertexID', i1Ptr)

! Define variable cellsOnEdge
      allocate(i2Ptr)

! Setting up time level 1
      i2Ptr % fieldName = 'cellsOnEdge'
      i2Ptr % isVarArray = .false.
      i2Ptr % isDecomposed = .true.
      i2Ptr % hasTimeDimension = .false.
      i2Ptr % isPersistent = .true.
      i2Ptr % isActive = .false.
! Setting up dimensions
      i2Ptr % dimNames(1) = 'TWO'
      i2Ptr % dimNames(2) = 'nEdges'
      i2Ptr % defaultValue = 0
      allocate(i2Ptr % attLists(1))
      allocate(i2Ptr % attLists(1) % attList)
      call mpas_add_att(i2Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr % attLists(1) % attList, 'long_name', 'List of cells that straddle each edge.')
      i2Ptr % missingValue = MPAS_INT_FILLVAL
      i2Ptr % block => block

      i2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'cellsOnEdge', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'cellsOnEdge', i2Ptr)

! Define variable nEdgesOnCell
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'nEdgesOnCell'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .false.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nCells'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'long_name', 'Number of edges that border each cell.')
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'nEdgesOnCell', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'nEdgesOnCell', i1Ptr)

! Define variable nEdgesOnEdge
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'nEdgesOnEdge'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .false.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nEdges'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'long_name', 'Number of edges that surround each of the cells that straddle '&
//'each edge. These edges are used to reconstruct the tangential velocities.')
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'nEdgesOnEdge', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'nEdgesOnEdge', i1Ptr)

! Define variable edgesOnCell
      allocate(i2Ptr)

! Setting up time level 1
      i2Ptr % fieldName = 'edgesOnCell'
      i2Ptr % isVarArray = .false.
      i2Ptr % isDecomposed = .true.
      i2Ptr % hasTimeDimension = .false.
      i2Ptr % isPersistent = .true.
      i2Ptr % isActive = .false.
! Setting up dimensions
      i2Ptr % dimNames(1) = 'maxEdges'
      i2Ptr % dimNames(2) = 'nCells'
      i2Ptr % defaultValue = 0
      allocate(i2Ptr % attLists(1))
      allocate(i2Ptr % attLists(1) % attList)
      call mpas_add_att(i2Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr % attLists(1) % attList, 'long_name', 'List of edges that border each cell.')
      i2Ptr % missingValue = MPAS_INT_FILLVAL
      i2Ptr % block => block

      i2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'edgesOnCell', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'edgesOnCell', i2Ptr)

! Define variable edgesOnEdge
      allocate(i2Ptr)

! Setting up time level 1
      i2Ptr % fieldName = 'edgesOnEdge'
      i2Ptr % isVarArray = .false.
      i2Ptr % isDecomposed = .true.
      i2Ptr % hasTimeDimension = .false.
      i2Ptr % isPersistent = .true.
      i2Ptr % isActive = .false.
! Setting up dimensions
      i2Ptr % dimNames(1) = 'maxEdges2'
      i2Ptr % dimNames(2) = 'nEdges'
      i2Ptr % defaultValue = 0
      allocate(i2Ptr % attLists(1))
      allocate(i2Ptr % attLists(1) % attList)
      call mpas_add_att(i2Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr % attLists(1) % attList, 'long_name', 'List of edges that border each of the cells that straddle '&
//'each edge.')
      i2Ptr % missingValue = MPAS_INT_FILLVAL
      i2Ptr % block => block

      i2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'edgesOnEdge', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'edgesOnEdge', i2Ptr)

! Define variable dvEdge
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'dvEdge'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Length of each edge, computed as the distance between '&
//'verticesOnEdge.')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'dvEdge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'dvEdge', r1Ptr)

! Define variable dcEdge
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'dcEdge'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Length of each edge, computed as the distance between '&
//'cellsOnEdge.')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'dcEdge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'dcEdge', r1Ptr)

! Define variable areaCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'areaCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'm^2')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Area of each cell in the primary grid.')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'areaCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'areaCell', r1Ptr)

! Define variable areaTriangle
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'areaTriangle'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'm^2')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Area of each cell (triangle) in the dual grid.')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'areaTriangle', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'areaTriangle', r1Ptr)

! Define variable edgeNormalVectors
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'edgeNormalVectors'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'R3'
      r2Ptr % dimNames(2) = 'nEdges'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Normal unit vector defined at an edge.')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      r2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'edgeNormalVectors', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'edgeNormalVectors', r2Ptr)

! Define variable cellTangentPlane
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'cellTangentPlane'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'R3'
      r3Ptr % dimNames(2) = 'TWO'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      call mpas_add_att(r3Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r3Ptr % attLists(1) % attList, 'long_name', 'The two vectors that define a tangent plane at a cell '&
//'center.')
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'cellTangentPlane', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'cellTangentPlane', r3Ptr)

! Define variable localVerticalUnitVectors
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'localVerticalUnitVectors'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'R3'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Unit surface normal vectors defined at cell centers.')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      r2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'localVerticalUnitVectors', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'localVerticalUnitVectors', r2Ptr)

! Define variable cellsOnCell
      allocate(i2Ptr)

! Setting up time level 1
      i2Ptr % fieldName = 'cellsOnCell'
      i2Ptr % isVarArray = .false.
      i2Ptr % isDecomposed = .true.
      i2Ptr % hasTimeDimension = .false.
      i2Ptr % isPersistent = .true.
      i2Ptr % isActive = .false.
! Setting up dimensions
      i2Ptr % dimNames(1) = 'maxEdges'
      i2Ptr % dimNames(2) = 'nCells'
      i2Ptr % defaultValue = 0
      allocate(i2Ptr % attLists(1))
      allocate(i2Ptr % attLists(1) % attList)
      call mpas_add_att(i2Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr % attLists(1) % attList, 'long_name', 'List of cells that neighbor each cell.')
      i2Ptr % missingValue = MPAS_INT_FILLVAL
      i2Ptr % block => block

      i2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'cellsOnCell', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'cellsOnCell', i2Ptr)

! Define variable verticesOnCell
      allocate(i2Ptr)

! Setting up time level 1
      i2Ptr % fieldName = 'verticesOnCell'
      i2Ptr % isVarArray = .false.
      i2Ptr % isDecomposed = .true.
      i2Ptr % hasTimeDimension = .false.
      i2Ptr % isPersistent = .true.
      i2Ptr % isActive = .false.
! Setting up dimensions
      i2Ptr % dimNames(1) = 'maxEdges'
      i2Ptr % dimNames(2) = 'nCells'
      i2Ptr % defaultValue = 0
      allocate(i2Ptr % attLists(1))
      allocate(i2Ptr % attLists(1) % attList)
      call mpas_add_att(i2Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr % attLists(1) % attList, 'long_name', 'List of vertices that border each cell.')
      i2Ptr % missingValue = MPAS_INT_FILLVAL
      i2Ptr % block => block

      i2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'verticesOnCell', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticesOnCell', i2Ptr)

! Define variable verticesOnEdge
      allocate(i2Ptr)

! Setting up time level 1
      i2Ptr % fieldName = 'verticesOnEdge'
      i2Ptr % isVarArray = .false.
      i2Ptr % isDecomposed = .true.
      i2Ptr % hasTimeDimension = .false.
      i2Ptr % isPersistent = .true.
      i2Ptr % isActive = .false.
! Setting up dimensions
      i2Ptr % dimNames(1) = 'TWO'
      i2Ptr % dimNames(2) = 'nEdges'
      i2Ptr % defaultValue = 0
      allocate(i2Ptr % attLists(1))
      allocate(i2Ptr % attLists(1) % attList)
      call mpas_add_att(i2Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr % attLists(1) % attList, 'long_name', 'List of vertices that straddle each edge.')
      i2Ptr % missingValue = MPAS_INT_FILLVAL
      i2Ptr % block => block

      i2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'verticesOnEdge', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticesOnEdge', i2Ptr)

! Define variable edgesOnVertex
      allocate(i2Ptr)

! Setting up time level 1
      i2Ptr % fieldName = 'edgesOnVertex'
      i2Ptr % isVarArray = .false.
      i2Ptr % isDecomposed = .true.
      i2Ptr % hasTimeDimension = .false.
      i2Ptr % isPersistent = .true.
      i2Ptr % isActive = .false.
! Setting up dimensions
      i2Ptr % dimNames(1) = 'vertexDegree'
      i2Ptr % dimNames(2) = 'nVertices'
      i2Ptr % defaultValue = 0
      allocate(i2Ptr % attLists(1))
      allocate(i2Ptr % attLists(1) % attList)
      call mpas_add_att(i2Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr % attLists(1) % attList, 'long_name', 'List of edges that share a vertex as an endpoint.')
      i2Ptr % missingValue = MPAS_INT_FILLVAL
      i2Ptr % block => block

      i2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'edgesOnVertex', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'edgesOnVertex', i2Ptr)

! Define variable cellsOnVertex
      allocate(i2Ptr)

! Setting up time level 1
      i2Ptr % fieldName = 'cellsOnVertex'
      i2Ptr % isVarArray = .false.
      i2Ptr % isDecomposed = .true.
      i2Ptr % hasTimeDimension = .false.
      i2Ptr % isPersistent = .true.
      i2Ptr % isActive = .false.
! Setting up dimensions
      i2Ptr % dimNames(1) = 'vertexDegree'
      i2Ptr % dimNames(2) = 'nVertices'
      i2Ptr % defaultValue = 0
      allocate(i2Ptr % attLists(1))
      allocate(i2Ptr % attLists(1) % attList)
      call mpas_add_att(i2Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr % attLists(1) % attList, 'long_name', 'List of cells that share a vertex.')
      i2Ptr % missingValue = MPAS_INT_FILLVAL
      i2Ptr % block => block

      i2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'cellsOnVertex', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'cellsOnVertex', i2Ptr)

! Define variable kiteAreasOnVertex
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'kiteAreasOnVertex'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'vertexDegree'
      r2Ptr % dimNames(2) = 'nVertices'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'm^2')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Area of the portions of each dual cell that are part of each '&
//'cellsOnVertex.')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      r2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'kiteAreasOnVertex', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'kiteAreasOnVertex', r2Ptr)

! Define variable fVertex
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'fVertex'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Coriolis parameter at vertices.')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'fVertex', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'fVertex', r1Ptr)

! Define variable fEdge
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'fEdge'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Coriolis parameter at edges.')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'fEdge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'fEdge', r1Ptr)

! Define variable coeffs_reconstruct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'coeffs_reconstruct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'R3'
      r3Ptr % dimNames(2) = 'maxEdges'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      call mpas_add_att(r3Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r3Ptr % attLists(1) % attList, 'long_name', 'Coefficients to reconstruct velocity vectors at cells '&
//'centers.')
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'coeffs_reconstruct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'coeffs_reconstruct', r3Ptr)

! Define variable itimestep
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'itimestep'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .false.
      i1Ptr % hasTimeDimension = .false.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'ONE'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'itimestep', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'itimestep', i1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_mesh


   subroutine seaice_generate_pool_tracers(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'tracers', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'tracers', newSubPool)

! Define variable iceAreaCategory
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'iceAreaCategory'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'ONE'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'iceAreaCategory'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'ONE'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      r3aPtr(1) % isActive = .true.
      r3aPtr(2) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceAreaCategory', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'iceAreaCategory', r3aPtr)

! Define variable iceVolumeCategory
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'iceVolumeCategory'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'ONE'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'iceVolumeCategory'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'ONE'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      r3aPtr(1) % isActive = .true.
      r3aPtr(2) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceVolumeCategory', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'iceVolumeCategory', r3aPtr)

! Define variable snowVolumeCategory
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'snowVolumeCategory'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'ONE'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'snowVolumeCategory'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'ONE'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      r3aPtr(1) % isActive = .true.
      r3aPtr(2) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowVolumeCategory', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'snowVolumeCategory', r3aPtr)

! Define variable surfaceTemperature
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'surfaceTemperature'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'ONE'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'surfaceTemperature'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'ONE'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      r3aPtr(1) % isActive = .true.
      r3aPtr(2) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'surfaceTemperature', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'surfaceTemperature', r3aPtr)

! Define variable iceEnthalpy
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'iceEnthalpy'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nIceLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'iceEnthalpy'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nIceLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      r3aPtr(1) % isActive = .true.
      r3aPtr(2) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceEnthalpy', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'iceEnthalpy', r3aPtr)

! Define variable iceSalinity
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'iceSalinity'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nIceLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'iceSalinity'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nIceLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      r3aPtr(1) % isActive = .true.
      r3aPtr(2) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceSalinity', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'iceSalinity', r3aPtr)

! Define variable snowEnthalpy
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'snowEnthalpy'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nSnowLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'snowEnthalpy'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nSnowLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      r3aPtr(1) % isActive = .true.
      r3aPtr(2) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowEnthalpy', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'snowEnthalpy', r3aPtr)

! Define variable snowIceMass
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'snowIceMass'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nSnowLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      call mpas_add_att(r3aPtr(1) % attLists(1) % attList, 'units', 'kg/m^3')
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'snowIceMass'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nSnowLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      call mpas_add_att(r3aPtr(2) % attLists(1) % attList, 'units', 'kg/m^3')
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowIceMass', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'snowIceMass', r3aPtr)

! Define variable snowLiquidMass
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'snowLiquidMass'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nSnowLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      call mpas_add_att(r3aPtr(1) % attLists(1) % attList, 'units', 'kg/m^3')
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'snowLiquidMass'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nSnowLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      call mpas_add_att(r3aPtr(2) % attLists(1) % attList, 'units', 'kg/m^3')
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowLiquidMass', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'snowLiquidMass', r3aPtr)

! Define variable snowGrainRadius
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'snowGrainRadius'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nSnowLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      call mpas_add_att(r3aPtr(1) % attLists(1) % attList, 'units', 'um')
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'snowGrainRadius'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nSnowLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      call mpas_add_att(r3aPtr(2) % attLists(1) % attList, 'units', 'um')
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgColumnTracerSnowGrainRadiusActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowGrainRadius', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'snowGrainRadius', r3aPtr)

! Define variable snowDensity
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'snowDensity'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nSnowLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      call mpas_add_att(r3aPtr(1) % attLists(1) % attList, 'units', 'kg/m^3')
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'snowDensity'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nSnowLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      call mpas_add_att(r3aPtr(2) % attLists(1) % attList, 'units', 'kg/m^3')
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowDensity', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'snowDensity', r3aPtr)

! Define variable iceAge
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'iceAge'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'ONE'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'iceAge'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'ONE'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgColumnTracerIceAgeActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceAge', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'iceAge', r3aPtr)

! Define variable firstYearIceArea
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'firstYearIceArea'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'ONE'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'firstYearIceArea'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'ONE'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgColumnTracerFirstYearIceActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'firstYearIceArea', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'firstYearIceArea', r3aPtr)

! Define variable levelIceArea
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'levelIceArea'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'ONE'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'levelIceArea'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'ONE'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgColumnTracerLevelIceActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceArea', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'levelIceArea', r3aPtr)

! Define variable levelIceVolume
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'levelIceVolume'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'ONE'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'levelIceVolume'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'ONE'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgColumnTracerLevelIceActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceVolume', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'levelIceVolume', r3aPtr)

! Define variable pondArea
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'pondArea'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'ONE'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'pondArea'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'ONE'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgColumnTracerPondsActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondArea', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'pondArea', r3aPtr)

! Define variable pondDepth
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'pondDepth'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'ONE'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'pondDepth'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'ONE'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgColumnTracerPondsActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondDepth', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'pondDepth', r3aPtr)

! Define variable pondLidThickness
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'pondLidThickness'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'ONE'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'pondLidThickness'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'ONE'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgColumnTracerLidThicknessActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondLidThickness', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'pondLidThickness', r3aPtr)

! Define variable snowScatteringAerosol
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'snowScatteringAerosol'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nAerosols'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'snowScatteringAerosol'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nAerosols'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowScatteringAerosol', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'snowScatteringAerosol', r3aPtr)

! Define variable snowBodyAerosol
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'snowBodyAerosol'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nAerosols'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'snowBodyAerosol'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nAerosols'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowBodyAerosol', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'snowBodyAerosol', r3aPtr)

! Define variable iceScatteringAerosol
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'iceScatteringAerosol'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nAerosols'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'iceScatteringAerosol'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nAerosols'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceScatteringAerosol', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'iceScatteringAerosol', r3aPtr)

! Define variable iceBodyAerosol
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'iceBodyAerosol'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nAerosols'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'iceBodyAerosol'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nAerosols'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceBodyAerosol', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'iceBodyAerosol', r3aPtr)

! Define variable brineFraction
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'brineFraction'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'ONE'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'brineFraction'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'ONE'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerBrineActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'brineFraction', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'brineFraction', r3aPtr)

! Define variable mobileFraction
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'mobileFraction'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nZBGCTracers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'mobileFraction'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nZBGCTracers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerMobileFractionActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'mobileFraction', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'mobileFraction', r3aPtr)

! Define variable skeletalAlgaeConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'skeletalAlgaeConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nAlgae'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'skeletalAlgaeConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nAlgae'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerSkeletalAlgaeActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAlgaeConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalAlgaeConc', r3aPtr)

! Define variable skeletalDOCConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'skeletalDOCConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nDOC'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'skeletalDOCConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nDOC'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerSkeletalCarbonActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDOCConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalDOCConc', r3aPtr)

! Define variable skeletalDICConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'skeletalDICConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nDIC'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'skeletalDICConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nDIC'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerSkeletalCarbonActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDICConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalDICConc', r3aPtr)

! Define variable skeletalDONConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'skeletalDONConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nDON'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'skeletalDONConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nDON'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerSkeletalDONActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDONConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalDONConc', r3aPtr)

! Define variable skeletalNitrateConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'skeletalNitrateConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'ONE'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'skeletalNitrateConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'ONE'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerSkeletalNitrateActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNitrateConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalNitrateConc', r3aPtr)

! Define variable skeletalSilicateConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'skeletalSilicateConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'ONE'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'skeletalSilicateConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'ONE'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerSkeletalSilicateActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalSilicateConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalSilicateConc', r3aPtr)

! Define variable skeletalAmmoniumConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'skeletalAmmoniumConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'ONE'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'skeletalAmmoniumConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'ONE'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerSkeletalAmmoniumActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAmmoniumConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalAmmoniumConc', r3aPtr)

! Define variable skeletalDMSConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'skeletalDMSConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'ONE'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'skeletalDMSConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'ONE'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSConc', r3aPtr)

! Define variable skeletalDMSPpConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'skeletalDMSPpConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'ONE'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'skeletalDMSPpConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'ONE'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPpConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPpConc', r3aPtr)

! Define variable skeletalDMSPdConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'skeletalDMSPdConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'ONE'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'skeletalDMSPdConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'ONE'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPdConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPdConc', r3aPtr)

! Define variable skeletalNonreactiveConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'skeletalNonreactiveConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'ONE'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'skeletalNonreactiveConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'ONE'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerSkeletalNonreactiveActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNonreactiveConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalNonreactiveConc', r3aPtr)

! Define variable skeletalHumicsConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'skeletalHumicsConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'ONE'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'skeletalHumicsConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'ONE'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerSkeletalHumicsActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalHumicsConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalHumicsConc', r3aPtr)

! Define variable skeletalParticulateIronConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'skeletalParticulateIronConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nParticulateIron'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'skeletalParticulateIronConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nParticulateIron'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerSkeletalIronActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalParticulateIronConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalParticulateIronConc', r3aPtr)

! Define variable skeletalDissolvedIronConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'skeletalDissolvedIronConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nDissolvedIron'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'skeletalDissolvedIronConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nDissolvedIron'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerSkeletalIronActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDissolvedIronConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalDissolvedIronConc', r3aPtr)

! Define variable verticalAlgaeConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalAlgaeConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nAlgaeLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalAlgaeConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nAlgaeLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeConc', r3aPtr)

! Define variable verticalDOCConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalDOCConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nDOCLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalDOCConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nDOCLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCConc', r3aPtr)

! Define variable verticalDICConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalDICConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nDICLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalDICConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nDICLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDICConc', r3aPtr)

! Define variable verticalDONConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalDONConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nDONLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalDONConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nDONLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalDONActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDONConc', r3aPtr)

! Define variable verticalNitrateConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalNitrateConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nBioLayersP3'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalNitrateConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nBioLayersP3'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalNitrateActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateConc', r3aPtr)

! Define variable verticalSilicateConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalSilicateConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nBioLayersP3'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalSilicateConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nBioLayersP3'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalSilicateActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateConc', r3aPtr)

! Define variable verticalAmmoniumConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalAmmoniumConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nBioLayersP3'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalAmmoniumConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nBioLayersP3'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumConc', r3aPtr)

! Define variable verticalDMSConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalDMSConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nBioLayersP3'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalDMSConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nBioLayersP3'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalDMSActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSConc', r3aPtr)

! Define variable verticalDMSPpConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalDMSPpConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nBioLayersP3'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalDMSPpConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nBioLayersP3'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalDMSActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpConc', r3aPtr)

! Define variable verticalDMSPdConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalDMSPdConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nBioLayersP3'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalDMSPdConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nBioLayersP3'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalDMSActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdConc', r3aPtr)

! Define variable verticalNonreactiveConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalNonreactiveConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nBioLayersP3'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalNonreactiveConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nBioLayersP3'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveConc', r3aPtr)

! Define variable verticalHumicsConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalHumicsConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nBioLayersP3'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalHumicsConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nBioLayersP3'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalHumicsActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsConc', r3aPtr)

! Define variable verticalParticulateIronConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalParticulateIronConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nParticulateIronLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalParticulateIronConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nParticulateIronLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalIronActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronConc', r3aPtr)

! Define variable verticalDissolvedIronConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalDissolvedIronConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nDissolvedIronLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalDissolvedIronConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nDissolvedIronLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalIronActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronConc', r3aPtr)

! Define variable verticalAlgaeSnow
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalAlgaeSnow'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nAlgaeSnowLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalAlgaeSnow'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nAlgaeSnowLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeSnow', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeSnow', r3aPtr)

! Define variable verticalDOCSnow
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalDOCSnow'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nDOCSnowLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalDOCSnow'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nDOCSnowLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCSnow', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCSnow', r3aPtr)

! Define variable verticalDICSnow
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalDICSnow'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nDICSnowLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalDICSnow'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nDICSnowLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICSnow', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDICSnow', r3aPtr)

! Define variable verticalDONSnow
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalDONSnow'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nDONSnowLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalDONSnow'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nDONSnowLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalDONActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONSnow', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDONSnow', r3aPtr)

! Define variable verticalNitrateSnow
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalNitrateSnow'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'TWO'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalNitrateSnow'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'TWO'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalNitrateActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateSnow', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateSnow', r3aPtr)

! Define variable verticalSilicateSnow
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalSilicateSnow'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'TWO'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalSilicateSnow'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'TWO'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalSilicateActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateSnow', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateSnow', r3aPtr)

! Define variable verticalAmmoniumSnow
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalAmmoniumSnow'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'TWO'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalAmmoniumSnow'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'TWO'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumSnow', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumSnow', r3aPtr)

! Define variable verticalDMSSnow
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalDMSSnow'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'TWO'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalDMSSnow'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'TWO'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalDMSActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSSnow', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSSnow', r3aPtr)

! Define variable verticalDMSPpSnow
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalDMSPpSnow'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'TWO'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalDMSPpSnow'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'TWO'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalDMSActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpSnow', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpSnow', r3aPtr)

! Define variable verticalDMSPdSnow
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalDMSPdSnow'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'TWO'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalDMSPdSnow'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'TWO'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalDMSActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdSnow', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdSnow', r3aPtr)

! Define variable verticalNonreactiveSnow
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalNonreactiveSnow'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'TWO'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalNonreactiveSnow'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'TWO'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveSnow', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveSnow', r3aPtr)

! Define variable verticalHumicsSnow
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalHumicsSnow'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'TWO'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalHumicsSnow'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'TWO'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalHumicsActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsSnow', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsSnow', r3aPtr)

! Define variable verticalParticulateIronSnow
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalParticulateIronSnow'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nPartIronSnowLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalParticulateIronSnow'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nPartIronSnowLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalIronActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronSnow', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronSnow', r3aPtr)

! Define variable verticalDissolvedIronSnow
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalDissolvedIronSnow'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nDisIronSnowLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalDissolvedIronSnow'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nDisIronSnowLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalIronActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronSnow', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronSnow', r3aPtr)

! Define variable verticalAlgaeIce
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalAlgaeIce'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nAlgaeIceLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalAlgaeIce'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nAlgaeIceLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeIce', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeIce', r3aPtr)

! Define variable verticalDOCIce
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalDOCIce'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nDOCIceLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalDOCIce'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nDOCIceLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCIce', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCIce', r3aPtr)

! Define variable verticalDICIce
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalDICIce'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nDICIceLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalDICIce'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nDICIceLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICIce', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDICIce', r3aPtr)

! Define variable verticalDONIce
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalDONIce'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nDONIceLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalDONIce'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nDONIceLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalDONActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONIce', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDONIce', r3aPtr)

! Define variable verticalNitrateIce
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalNitrateIce'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nBioLayersP1'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalNitrateIce'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nBioLayersP1'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalNitrateActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateIce', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateIce', r3aPtr)

! Define variable verticalSilicateIce
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalSilicateIce'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nBioLayersP1'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalSilicateIce'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nBioLayersP1'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalSilicateActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateIce', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateIce', r3aPtr)

! Define variable verticalAmmoniumIce
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalAmmoniumIce'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nBioLayersP1'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalAmmoniumIce'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nBioLayersP1'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumIce', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumIce', r3aPtr)

! Define variable verticalDMSIce
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalDMSIce'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nBioLayersP1'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalDMSIce'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nBioLayersP1'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalDMSActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSIce', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSIce', r3aPtr)

! Define variable verticalDMSPpIce
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalDMSPpIce'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nBioLayersP1'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalDMSPpIce'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nBioLayersP1'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalDMSActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpIce', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpIce', r3aPtr)

! Define variable verticalDMSPdIce
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalDMSPdIce'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nBioLayersP1'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalDMSPdIce'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nBioLayersP1'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalDMSActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdIce', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdIce', r3aPtr)

! Define variable verticalNonreactiveIce
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalNonreactiveIce'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nBioLayersP1'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalNonreactiveIce'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nBioLayersP1'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveIce', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveIce', r3aPtr)

! Define variable verticalHumicsIce
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalHumicsIce'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nBioLayersP1'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalHumicsIce'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nBioLayersP1'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalHumicsActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsIce', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsIce', r3aPtr)

! Define variable verticalParticulateIronIce
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalParticulateIronIce'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nPartIronIceLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalParticulateIronIce'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nPartIronIceLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalIronActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronIce', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronIce', r3aPtr)

! Define variable verticalDissolvedIronIce
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalDissolvedIronIce'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nDisIronIceLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalDissolvedIronIce'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nDisIronIceLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerVerticalIronActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronIce', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronIce', r3aPtr)

! Define variable verticalAerosolsConc
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalAerosolsConc'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nzAerosolsLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalAerosolsConc'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nzAerosolsLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerZAerosolsActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsConc', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsConc', r3aPtr)

! Define variable verticalAerosolsSnow
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalAerosolsSnow'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nzAerosolsSnowLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalAerosolsSnow'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nzAerosolsSnowLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerZAerosolsActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsSnow', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsSnow', r3aPtr)

! Define variable verticalAerosolsIce
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalAerosolsIce'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nzAerosolsIceLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalAerosolsIce'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nzAerosolsIceLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerZAerosolsActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsIce', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsIce', r3aPtr)

! Define variable verticalSalinity
      allocate(r3aPtr(2))

! Setting up time level 1
      r3aPtr(1) % fieldName = 'verticalSalinity'
      r3aPtr(1) % isVarArray = .false.
      r3aPtr(1) % isDecomposed = .true.
      r3aPtr(1) % hasTimeDimension = .true.
      r3aPtr(1) % isPersistent = .true.
      r3aPtr(1) % isActive = .false.
! Setting up dimensions
      r3aPtr(1) % dimNames(1) = 'nBioLayers'
      r3aPtr(1) % dimNames(2) = 'nCategories'
      r3aPtr(1) % dimNames(3) = 'nCells'
      r3aPtr(1) % defaultValue = 0.0
      allocate(r3aPtr(1) % attLists(1))
      allocate(r3aPtr(1) % attLists(1) % attList)
      r3aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(1) % block => block

! Setting up time level 2
      r3aPtr(2) % fieldName = 'verticalSalinity'
      r3aPtr(2) % isVarArray = .false.
      r3aPtr(2) % isDecomposed = .true.
      r3aPtr(2) % hasTimeDimension = .true.
      r3aPtr(2) % isPersistent = .true.
      r3aPtr(2) % isActive = .false.
! Setting up dimensions
      r3aPtr(2) % dimNames(1) = 'nBioLayers'
      r3aPtr(2) % dimNames(2) = 'nCategories'
      r3aPtr(2) % dimNames(3) = 'nCells'
      r3aPtr(2) % defaultValue = 0.0
      allocate(r3aPtr(2) % attLists(1))
      allocate(r3aPtr(2) % attLists(1) % attList)
      r3aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r3aPtr(2) % block => block

      if (pkgTracerZSalinityActive) then
         r3aPtr(1) % isActive = .true.
         r3aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSalinity', r3aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalSalinity', r3aPtr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_tracers


   subroutine seaice_generate_pool_tracers_aggregate(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'tracers_aggregate', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'tracers_aggregate', newSubPool)

! Define variable iceAreaCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'iceAreaCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceAreaCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAreaCell', r1Ptr)

! Define variable iceVolumeCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'iceVolumeCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceVolumeCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceVolumeCell', r1Ptr)

! Define variable snowVolumeCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'snowVolumeCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowVolumeCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'snowVolumeCell', r1Ptr)

! Define variable surfaceTemperatureCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'surfaceTemperatureCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'surfaceTemperatureCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceTemperatureCell', r1Ptr)

! Define variable iceEnthalpyCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'iceEnthalpyCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nIceLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      r2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceEnthalpyCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'iceEnthalpyCell', r2Ptr)

! Define variable iceSalinityCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'iceSalinityCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nIceLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      r2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceSalinityCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'iceSalinityCell', r2Ptr)

! Define variable snowEnthalpyCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'snowEnthalpyCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nSnowLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      r2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowEnthalpyCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'snowEnthalpyCell', r2Ptr)

! Define variable snowIceMassCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'snowIceMassCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nSnowLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'kg/m^3')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Mass of ice in snow layer')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowIceMassCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'snowIceMassCell', r2Ptr)

! Define variable snowLiquidMassCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'snowLiquidMassCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nSnowLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'kg/m^3')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Mass of liquid in snow layer')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowLiquidMassCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'snowLiquidMassCell', r2Ptr)

! Define variable snowGrainRadiusCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'snowGrainRadiusCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nSnowLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'um')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Effective snow grain radius')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnTracerSnowGrainRadiusActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowGrainRadiusCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'snowGrainRadiusCell', r2Ptr)

! Define variable snowDensityCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'snowDensityCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nSnowLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'kg/m^3')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Prognostic snow density')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowDensityCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'snowDensityCell', r2Ptr)

! Define variable iceAgeCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'iceAgeCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnTracerIceAgeActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceAgeCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAgeCell', r1Ptr)

! Define variable firstYearIceAreaCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'firstYearIceAreaCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnTracerFirstYearIceActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'firstYearIceAreaCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'firstYearIceAreaCell', r1Ptr)

! Define variable levelIceAreaCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'levelIceAreaCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnTracerLevelIceActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceAreaCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'levelIceAreaCell', r1Ptr)

! Define variable levelIceVolumeCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'levelIceVolumeCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnTracerLevelIceActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceVolumeCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'levelIceVolumeCell', r1Ptr)

! Define variable pondAreaCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'pondAreaCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnTracerPondsActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondAreaCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'pondAreaCell', r1Ptr)

! Define variable pondDepthCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'pondDepthCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnTracerPondsActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondDepthCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'pondDepthCell', r1Ptr)

! Define variable pondLidThicknessCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'pondLidThicknessCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnTracerLidThicknessActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondLidThicknessCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'pondLidThicknessCell', r1Ptr)

! Define variable snowScatteringAerosolCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'snowScatteringAerosolCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nAerosols'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowScatteringAerosolCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'snowScatteringAerosolCell', r2Ptr)

! Define variable snowBodyAerosolCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'snowBodyAerosolCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nAerosols'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowBodyAerosolCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'snowBodyAerosolCell', r2Ptr)

! Define variable iceScatteringAerosolCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'iceScatteringAerosolCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nAerosols'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceScatteringAerosolCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'iceScatteringAerosolCell', r2Ptr)

! Define variable iceBodyAerosolCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'iceBodyAerosolCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nAerosols'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceBodyAerosolCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'iceBodyAerosolCell', r2Ptr)

! Define variable brineFractionCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'brineFractionCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Grid cell average ratio of brine height to ice thickness')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgTracerBrineActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'brineFractionCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'brineFractionCell', r1Ptr)

! Define variable skeletalAlgaeConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'skeletalAlgaeConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nAlgae'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerSkeletalAlgaeActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAlgaeConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalAlgaeConcCell', r2Ptr)

! Define variable skeletalDOCConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'skeletalDOCConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nDOC'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerSkeletalCarbonActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDOCConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDOCConcCell', r2Ptr)

! Define variable skeletalDICConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'skeletalDICConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nDIC'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerSkeletalCarbonActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDICConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDICConcCell', r2Ptr)

! Define variable skeletalDONConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'skeletalDONConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nDON'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerSkeletalDONActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDONConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDONConcCell', r2Ptr)

! Define variable skeletalNitrateConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'skeletalNitrateConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'ONE'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerSkeletalNitrateActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNitrateConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalNitrateConcCell', r2Ptr)

! Define variable skeletalSilicateConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'skeletalSilicateConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'ONE'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerSkeletalSilicateActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalSilicateConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalSilicateConcCell', r2Ptr)

! Define variable skeletalAmmoniumConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'skeletalAmmoniumConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'ONE'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerSkeletalAmmoniumActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAmmoniumConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalAmmoniumConcCell', r2Ptr)

! Define variable skeletalDMSConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'skeletalDMSConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'ONE'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSConcCell', r2Ptr)

! Define variable skeletalDMSPpConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'skeletalDMSPpConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'ONE'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPpConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPpConcCell', r2Ptr)

! Define variable skeletalDMSPdConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'skeletalDMSPdConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'ONE'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPdConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPdConcCell', r2Ptr)

! Define variable skeletalNonreactiveConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'skeletalNonreactiveConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'ONE'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerSkeletalNonreactiveActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNonreactiveConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalNonreactiveConcCell', r2Ptr)

! Define variable skeletalHumicsConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'skeletalHumicsConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'ONE'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerSkeletalHumicsActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalHumicsConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalHumicsConcCell', r2Ptr)

! Define variable skeletalParticulateIronConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'skeletalParticulateIronConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nParticulateIron'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerSkeletalIronActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalParticulateIronConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalParticulateIronConcCell', r2Ptr)

! Define variable skeletalDissolvedIronConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'skeletalDissolvedIronConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nDissolvedIron'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerSkeletalIronActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDissolvedIronConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDissolvedIronConcCell', r2Ptr)

! Define variable verticalAlgaeConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalAlgaeConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nAlgaeLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeConcCell', r2Ptr)

! Define variable verticalDOCConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalDOCConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nDOCLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCConcCell', r2Ptr)

! Define variable verticalDICConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalDICConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nDICLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDICConcCell', r2Ptr)

! Define variable verticalDONConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalDONConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nDONLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalDONActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDONConcCell', r2Ptr)

! Define variable verticalNitrateConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalNitrateConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nBioLayersP3'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalNitrateActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateConcCell', r2Ptr)

! Define variable verticalSilicateConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalSilicateConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nBioLayersP3'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalSilicateActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateConcCell', r2Ptr)

! Define variable verticalAmmoniumConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalAmmoniumConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nBioLayersP3'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumConcCell', r2Ptr)

! Define variable verticalDMSConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalDMSConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nBioLayersP3'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSConcCell', r2Ptr)

! Define variable verticalDMSPpConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalDMSPpConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nBioLayersP3'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpConcCell', r2Ptr)

! Define variable verticalDMSPdConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalDMSPdConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nBioLayersP3'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdConcCell', r2Ptr)

! Define variable verticalNonreactiveConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalNonreactiveConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nBioLayersP3'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveConcCell', r2Ptr)

! Define variable verticalHumicsConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalHumicsConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nBioLayersP3'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalHumicsActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsConcCell', r2Ptr)

! Define variable verticalParticulateIronConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalParticulateIronConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nParticulateIronLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronConcCell', r2Ptr)

! Define variable verticalDissolvedIronConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalDissolvedIronConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nDissolvedIronLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronConcCell', r2Ptr)

! Define variable verticalAlgaeSnowCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalAlgaeSnowCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nAlgaeSnowLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeSnowCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeSnowCell', r2Ptr)

! Define variable verticalDOCSnowCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalDOCSnowCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nDOCSnowLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCSnowCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCSnowCell', r2Ptr)

! Define variable verticalDICSnowCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalDICSnowCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nDICSnowLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICSnowCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDICSnowCell', r2Ptr)

! Define variable verticalDONSnowCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalDONSnowCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nDONSnowLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalDONActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONSnowCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDONSnowCell', r2Ptr)

! Define variable verticalNitrateSnowCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalNitrateSnowCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'TWO'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalNitrateActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateSnowCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateSnowCell', r2Ptr)

! Define variable verticalSilicateSnowCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalSilicateSnowCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'TWO'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalSilicateActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateSnowCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateSnowCell', r2Ptr)

! Define variable verticalAmmoniumSnowCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalAmmoniumSnowCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'TWO'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumSnowCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumSnowCell', r2Ptr)

! Define variable verticalDMSSnowCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalDMSSnowCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'TWO'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSSnowCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSSnowCell', r2Ptr)

! Define variable verticalDMSPpSnowCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalDMSPpSnowCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'TWO'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpSnowCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpSnowCell', r2Ptr)

! Define variable verticalDMSPdSnowCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalDMSPdSnowCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'TWO'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdSnowCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdSnowCell', r2Ptr)

! Define variable verticalNonreactiveSnowCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalNonreactiveSnowCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'TWO'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveSnowCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveSnowCell', r2Ptr)

! Define variable verticalHumicsSnowCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalHumicsSnowCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'TWO'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalHumicsActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsSnowCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsSnowCell', r2Ptr)

! Define variable verticalParticulateIronSnowCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalParticulateIronSnowCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nPartIronSnowLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronSnowCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronSnowCell', r2Ptr)

! Define variable verticalDissolvedIronSnowCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalDissolvedIronSnowCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nDisIronSnowLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronSnowCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronSnowCell', r2Ptr)

! Define variable verticalAlgaeIceCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalAlgaeIceCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nAlgaeIceLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'mmol/m^3')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Cell average algal nitrogen for each type and ice bio-grid '&
//'layer')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeIceCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeIceCell', r2Ptr)

! Define variable verticalDOCIceCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalDOCIceCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nDOCIceLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'mmol/m^3')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Cell average dissolved organic carbon for each type and ice '&
//'bio-grid layer')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCIceCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCIceCell', r2Ptr)

! Define variable verticalDICIceCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalDICIceCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nDICIceLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'mmol/m^3')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Cell average dissolved inorganic carbon for each type and ice '&
//'bio-grid layer')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICIceCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDICIceCell', r2Ptr)

! Define variable verticalDONIceCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalDONIceCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nDONIceLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'mmol/m^3')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Cell average dissolved organic nitrogen for each type and ice '&
//'bio-grid layer')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalDONActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONIceCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDONIceCell', r2Ptr)

! Define variable verticalNitrateIceCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalNitrateIceCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nBioLayersP1'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'mmol/m^3')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Cell average nitrate for each ice bio-grid layer')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalNitrateActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateIceCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateIceCell', r2Ptr)

! Define variable verticalSilicateIceCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalSilicateIceCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nBioLayersP1'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'mmol/m^3')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Cell average silicate for each ice bio-grid layer')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalSilicateActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateIceCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateIceCell', r2Ptr)

! Define variable verticalAmmoniumIceCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalAmmoniumIceCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nBioLayersP1'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'mmol/m^3')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Cell average ammonium for each ice bio-grid layer')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumIceCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumIceCell', r2Ptr)

! Define variable verticalDMSIceCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalDMSIceCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nBioLayersP1'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'mmol/m^3')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Cell average DMS for each ice bio-grid layer')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSIceCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSIceCell', r2Ptr)

! Define variable verticalDMSPpIceCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalDMSPpIceCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nBioLayersP1'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'mmol/m^3')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Cell average particulate DMSP for each ice bio-grid layer')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpIceCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpIceCell', r2Ptr)

! Define variable verticalDMSPdIceCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalDMSPdIceCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nBioLayersP1'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'mmol/m^3')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Cell average dissolved DMSP for each ice bio-grid layer')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdIceCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdIceCell', r2Ptr)

! Define variable verticalNonreactiveIceCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalNonreactiveIceCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nBioLayersP1'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'mmol/m^3')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Cell average nonreactive nitrate for each ice bio-grid layer')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveIceCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveIceCell', r2Ptr)

! Define variable verticalHumicsIceCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalHumicsIceCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nBioLayersP1'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'mmol/m^3')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Cell average humic carbon for each ice bio-grid layer')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalHumicsActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsIceCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsIceCell', r2Ptr)

! Define variable verticalParticulateIronIceCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalParticulateIronIceCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nPartIronIceLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'umol/m^3')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Cell average particulate iron for each type and ice bio-grid '&
//'layer')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronIceCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronIceCell', r2Ptr)

! Define variable verticalDissolvedIronIceCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalDissolvedIronIceCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nDisIronIceLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'umol/m^3')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Cell average dissolved iron for each type and ice bio-grid '&
//'layer')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronIceCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronIceCell', r2Ptr)

! Define variable verticalAerosolsSnowCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalAerosolsSnowCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nzAerosolsSnowLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'kg/m^3')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Cell average aerosol for each type and snow bio-grid layer')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerZAerosolsActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsSnowCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsSnowCell', r2Ptr)

! Define variable verticalAerosolsIceCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalAerosolsIceCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nzAerosolsIceLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'kg/m^3')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Cell average aerosol for each type and ice bio-grid layer')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerZAerosolsActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsIceCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsIceCell', r2Ptr)

! Define variable verticalAerosolsConcCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalAerosolsConcCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nzAerosolsLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerZAerosolsActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsConcCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsConcCell', r2Ptr)

! Define variable verticalSalinityCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'verticalSalinityCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nBioLayers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerZSalinityActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSalinityCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSalinityCell', r2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_tracers_aggregate


   subroutine seaice_generate_pool_icestate(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'icestate', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'icestate', newSubPool)

! Define variable iceAreaCellInitial
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'iceAreaCellInitial'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceAreaCellInitial', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAreaCellInitial', r1Ptr)

! Define variable iceAreaCategoryInitial
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'iceAreaCategoryInitial'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      r2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceAreaCategoryInitial', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAreaCategoryInitial', r2Ptr)

! Define variable iceVolumeCategoryInitial
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'iceVolumeCategoryInitial'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      r2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceVolumeCategoryInitial', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'iceVolumeCategoryInitial', r2Ptr)

! Define variable iceThicknessCategoryInitial
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'iceThicknessCategoryInitial'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      r2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceThicknessCategoryInitial', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'iceThicknessCategoryInitial', r2Ptr)

! Define variable snowVolumeCategoryInitial
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'snowVolumeCategoryInitial'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      r2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowVolumeCategoryInitial', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'snowVolumeCategoryInitial', r2Ptr)

! Define variable openWaterArea
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'openWaterArea'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'openWaterArea', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'openWaterArea', r1Ptr)

! Define variable iceAreaVertex
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'iceAreaVertex'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceAreaVertex', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAreaVertex', r1Ptr)

! Define variable iceAreaEdge
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'iceAreaEdge'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceAreaEdge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAreaEdge', r1Ptr)

! Define variable totalMassCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'totalMassCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'totalMassCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'totalMassCell', r1Ptr)

! Define variable totalMassVertex
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'totalMassVertex'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'totalMassVertex', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'totalMassVertex', r1Ptr)

! Define variable totalMassEdge
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'totalMassEdge'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'totalMassEdge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'totalMassEdge', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_icestate


   subroutine seaice_generate_pool_tracer_tendencies(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'tracer_tendencies', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'tracer_tendencies', newSubPool)

! Define variable iceAreaCategoryTend
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceAreaCategoryTend'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceAreaCategoryTend', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAreaCategoryTend', r3Ptr)

! Define variable iceVolumeCategoryTend
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceVolumeCategoryTend'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceVolumeCategoryTend', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceVolumeCategoryTend', r3Ptr)

! Define variable snowVolumeCategoryTend
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowVolumeCategoryTend'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowVolumeCategoryTend', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowVolumeCategoryTend', r3Ptr)

! Define variable surfaceTemperatureTend
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'surfaceTemperatureTend'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'surfaceTemperatureTend', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceTemperatureTend', r3Ptr)

! Define variable iceEnthalpyTend
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceEnthalpyTend'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceEnthalpyTend', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceEnthalpyTend', r3Ptr)

! Define variable iceSalinityTend
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceSalinityTend'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceSalinityTend', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceSalinityTend', r3Ptr)

! Define variable snowEnthalpyTend
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowEnthalpyTend'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowEnthalpyTend', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowEnthalpyTend', r3Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_tracer_tendencies


   subroutine seaice_generate_pool_tracer_masks(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'tracer_masks', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'tracer_masks', newSubPool)

! Define variable iceAreaCategoryMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'iceAreaCategoryMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'ONE'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      i3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceAreaCategoryMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAreaCategoryMask', i3Ptr)

! Define variable iceVolumeCategoryMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'iceVolumeCategoryMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'ONE'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      i3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceVolumeCategoryMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceVolumeCategoryMask', i3Ptr)

! Define variable snowVolumeCategoryMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'snowVolumeCategoryMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'ONE'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      i3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowVolumeCategoryMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowVolumeCategoryMask', i3Ptr)

! Define variable surfaceTemperatureMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'surfaceTemperatureMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'ONE'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      i3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'surfaceTemperatureMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceTemperatureMask', i3Ptr)

! Define variable iceEnthalpyMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'iceEnthalpyMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nIceLayers'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      i3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceEnthalpyMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceEnthalpyMask', i3Ptr)

! Define variable iceSalinityMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'iceSalinityMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nIceLayers'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      i3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceSalinityMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceSalinityMask', i3Ptr)

! Define variable snowEnthalpyMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'snowEnthalpyMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nSnowLayers'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      i3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowEnthalpyMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowEnthalpyMask', i3Ptr)

! Define variable snowIceMassMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'snowIceMassMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nSnowLayers'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowIceMassMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowIceMassMask', i3Ptr)

! Define variable snowLiquidMassMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'snowLiquidMassMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nSnowLayers'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowLiquidMassMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowLiquidMassMask', i3Ptr)

! Define variable snowGrainRadiusMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'snowGrainRadiusMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nSnowLayers'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgColumnTracerSnowGrainRadiusActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowGrainRadiusMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowGrainRadiusMask', i3Ptr)

! Define variable snowDensityMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'snowDensityMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nSnowLayers'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowDensityMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowDensityMask', i3Ptr)

! Define variable iceAgeMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'iceAgeMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'ONE'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgColumnTracerIceAgeActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceAgeMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAgeMask', i3Ptr)

! Define variable firstYearIceAreaMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'firstYearIceAreaMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'ONE'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgColumnTracerFirstYearIceActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'firstYearIceAreaMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'firstYearIceAreaMask', i3Ptr)

! Define variable levelIceAreaMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'levelIceAreaMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'ONE'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgColumnTracerLevelIceActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceAreaMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'levelIceAreaMask', i3Ptr)

! Define variable levelIceVolumeMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'levelIceVolumeMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'ONE'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgColumnTracerLevelIceActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceVolumeMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'levelIceVolumeMask', i3Ptr)

! Define variable pondAreaMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'pondAreaMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'ONE'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgColumnTracerPondsActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondAreaMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondAreaMask', i3Ptr)

! Define variable pondDepthMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'pondDepthMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'ONE'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgColumnTracerPondsActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondDepthMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondDepthMask', i3Ptr)

! Define variable pondLidThicknessMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'pondLidThicknessMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'ONE'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgColumnTracerLidThicknessActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondLidThicknessMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondLidThicknessMask', i3Ptr)

! Define variable snowScatteringAerosolMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'snowScatteringAerosolMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nAerosols'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowScatteringAerosolMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowScatteringAerosolMask', i3Ptr)

! Define variable snowBodyAerosolMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'snowBodyAerosolMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nAerosols'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowBodyAerosolMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowBodyAerosolMask', i3Ptr)

! Define variable iceScatteringAerosolMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'iceScatteringAerosolMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nAerosols'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceScatteringAerosolMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceScatteringAerosolMask', i3Ptr)

! Define variable iceBodyAerosolMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'iceBodyAerosolMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nAerosols'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceBodyAerosolMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceBodyAerosolMask', i3Ptr)

! Define variable brineFractionMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'brineFractionMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'ONE'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerBrineActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'brineFractionMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'brineFractionMask', i3Ptr)

! Define variable mobileFractionMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'mobileFractionMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nZBGCTracers'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerMobileFractionActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'mobileFractionMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'mobileFractionMask', i3Ptr)

! Define variable skeletalAlgaeConcMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'skeletalAlgaeConcMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nAlgae'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerSkeletalAlgaeActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAlgaeConcMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalAlgaeConcMask', i3Ptr)

! Define variable skeletalDOCConcMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'skeletalDOCConcMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nDOC'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerSkeletalCarbonActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDOCConcMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDOCConcMask', i3Ptr)

! Define variable skeletalDICConcMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'skeletalDICConcMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nDIC'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerSkeletalCarbonActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDICConcMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDICConcMask', i3Ptr)

! Define variable skeletalDONConcMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'skeletalDONConcMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nDON'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerSkeletalDONActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDONConcMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDONConcMask', i3Ptr)

! Define variable skeletalNitrateConcMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'skeletalNitrateConcMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'ONE'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerSkeletalNitrateActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNitrateConcMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalNitrateConcMask', i3Ptr)

! Define variable skeletalSilicateConcMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'skeletalSilicateConcMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'ONE'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerSkeletalSilicateActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalSilicateConcMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalSilicateConcMask', i3Ptr)

! Define variable skeletalAmmoniumConcMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'skeletalAmmoniumConcMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'ONE'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerSkeletalAmmoniumActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAmmoniumConcMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalAmmoniumConcMask', i3Ptr)

! Define variable skeletalDMSConcMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'skeletalDMSConcMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'ONE'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSConcMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSConcMask', i3Ptr)

! Define variable skeletalDMSPpConcMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'skeletalDMSPpConcMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'ONE'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPpConcMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPpConcMask', i3Ptr)

! Define variable skeletalDMSPdConcMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'skeletalDMSPdConcMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'ONE'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPdConcMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPdConcMask', i3Ptr)

! Define variable skeletalNonreactiveConcMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'skeletalNonreactiveConcMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'ONE'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerSkeletalNonreactiveActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNonreactiveConcMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalNonreactiveConcMask', i3Ptr)

! Define variable skeletalHumicsConcMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'skeletalHumicsConcMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'ONE'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerSkeletalHumicsActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalHumicsConcMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalHumicsConcMask', i3Ptr)

! Define variable skeletalParticulateIronConcMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'skeletalParticulateIronConcMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nParticulateIron'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerSkeletalIronActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalParticulateIronConcMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalParticulateIronConcMask', i3Ptr)

! Define variable skeletalDissolvedIronConcMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'skeletalDissolvedIronConcMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nDissolvedIron'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerSkeletalIronActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDissolvedIronConcMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDissolvedIronConcMask', i3Ptr)

! Define variable verticalAlgaeSnowMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalAlgaeSnowMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nAlgaeSnowLayers'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalAlgaeActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeSnowMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeSnowMask', i3Ptr)

! Define variable verticalDOCSnowMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalDOCSnowMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nDOCSnowLayers'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCSnowMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCSnowMask', i3Ptr)

! Define variable verticalDICSnowMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalDICSnowMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nDICSnowLayers'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICSnowMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDICSnowMask', i3Ptr)

! Define variable verticalDONSnowMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalDONSnowMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nDONSnowLayers'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalDONActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONSnowMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDONSnowMask', i3Ptr)

! Define variable verticalNitrateSnowMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalNitrateSnowMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'TWO'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalNitrateActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateSnowMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateSnowMask', i3Ptr)

! Define variable verticalSilicateSnowMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalSilicateSnowMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'TWO'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalSilicateActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateSnowMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateSnowMask', i3Ptr)

! Define variable verticalAmmoniumSnowMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalAmmoniumSnowMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'TWO'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumSnowMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumSnowMask', i3Ptr)

! Define variable verticalDMSSnowMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalDMSSnowMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'TWO'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSSnowMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSSnowMask', i3Ptr)

! Define variable verticalDMSPpSnowMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalDMSPpSnowMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'TWO'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpSnowMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpSnowMask', i3Ptr)

! Define variable verticalDMSPdSnowMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalDMSPdSnowMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'TWO'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdSnowMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdSnowMask', i3Ptr)

! Define variable verticalNonreactiveSnowMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalNonreactiveSnowMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'TWO'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveSnowMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveSnowMask', i3Ptr)

! Define variable verticalHumicsSnowMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalHumicsSnowMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'TWO'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalHumicsActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsSnowMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsSnowMask', i3Ptr)

! Define variable verticalParticulateIronSnowMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalParticulateIronSnowMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nPartIronSnowLayers'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronSnowMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronSnowMask', i3Ptr)

! Define variable verticalDissolvedIronSnowMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalDissolvedIronSnowMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nDisIronSnowLayers'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronSnowMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronSnowMask', i3Ptr)

! Define variable verticalAlgaeIceMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalAlgaeIceMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nAlgaeIceLayers'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalAlgaeActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeIceMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeIceMask', i3Ptr)

! Define variable verticalDOCIceMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalDOCIceMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nDOCIceLayers'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCIceMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCIceMask', i3Ptr)

! Define variable verticalDICIceMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalDICIceMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nDICIceLayers'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICIceMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDICIceMask', i3Ptr)

! Define variable verticalDONIceMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalDONIceMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nDONIceLayers'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalDONActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONIceMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDONIceMask', i3Ptr)

! Define variable verticalNitrateIceMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalNitrateIceMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nBioLayersP1'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalNitrateActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateIceMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateIceMask', i3Ptr)

! Define variable verticalSilicateIceMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalSilicateIceMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nBioLayersP1'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalSilicateActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateIceMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateIceMask', i3Ptr)

! Define variable verticalAmmoniumIceMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalAmmoniumIceMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nBioLayersP1'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumIceMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumIceMask', i3Ptr)

! Define variable verticalDMSIceMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalDMSIceMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nBioLayersP1'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSIceMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSIceMask', i3Ptr)

! Define variable verticalDMSPpIceMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalDMSPpIceMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nBioLayersP1'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpIceMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpIceMask', i3Ptr)

! Define variable verticalDMSPdIceMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalDMSPdIceMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nBioLayersP1'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdIceMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdIceMask', i3Ptr)

! Define variable verticalNonreactiveIceMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalNonreactiveIceMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nBioLayersP1'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveIceMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveIceMask', i3Ptr)

! Define variable verticalHumicsIceMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalHumicsIceMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nBioLayersP1'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalHumicsActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsIceMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsIceMask', i3Ptr)

! Define variable verticalParticulateIronIceMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalParticulateIronIceMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nPartIronIceLayers'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronIceMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronIceMask', i3Ptr)

! Define variable verticalDissolvedIronIceMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalDissolvedIronIceMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nDisIronIceLayers'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronIceMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronIceMask', i3Ptr)

! Define variable verticalAerosolsSnowMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalAerosolsSnowMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nzAerosolsSnowLayers'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerZAerosolsActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsSnowMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsSnowMask', i3Ptr)

! Define variable verticalAerosolsIceMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalAerosolsIceMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nzAerosolsIceLayers'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerZAerosolsActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsIceMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsIceMask', i3Ptr)

! Define variable verticalSalinityMask
      allocate(i3Ptr)

! Setting up time level 1
      i3Ptr % fieldName = 'verticalSalinityMask'
      i3Ptr % isVarArray = .false.
      i3Ptr % isDecomposed = .true.
      i3Ptr % hasTimeDimension = .false.
      i3Ptr % isPersistent = .true.
      i3Ptr % isActive = .false.
! Setting up dimensions
      i3Ptr % dimNames(1) = 'nBioLayers'
      i3Ptr % dimNames(2) = 'nCategories'
      i3Ptr % dimNames(3) = 'nCells'
      i3Ptr % defaultValue = 0
      allocate(i3Ptr % attLists(1))
      allocate(i3Ptr % attLists(1) % attList)
      i3Ptr % missingValue = MPAS_INT_FILLVAL
      i3Ptr % block => block

      if (pkgTracerZSalinityActive) then
         i3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSalinityMask', i3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSalinityMask', i3Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_tracer_masks


   subroutine seaice_generate_pool_tracer_edge_fluxes(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'tracer_edge_fluxes', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'tracer_edge_fluxes', newSubPool)

! Define variable iceAreaCategoryEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceAreaCategoryEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceAreaCategoryEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAreaCategoryEdgeFlux', r3Ptr)

! Define variable iceVolumeCategoryEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceVolumeCategoryEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceVolumeCategoryEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceVolumeCategoryEdgeFlux', r3Ptr)

! Define variable snowVolumeCategoryEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowVolumeCategoryEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowVolumeCategoryEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowVolumeCategoryEdgeFlux', r3Ptr)

! Define variable surfaceTemperatureEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'surfaceTemperatureEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'surfaceTemperatureEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceTemperatureEdgeFlux', r3Ptr)

! Define variable iceEnthalpyEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceEnthalpyEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceEnthalpyEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceEnthalpyEdgeFlux', r3Ptr)

! Define variable iceSalinityEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceSalinityEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceSalinityEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceSalinityEdgeFlux', r3Ptr)

! Define variable snowEnthalpyEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowEnthalpyEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowEnthalpyEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowEnthalpyEdgeFlux', r3Ptr)

! Define variable snowIceMassEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowIceMassEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowIceMassEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowIceMassEdgeFlux', r3Ptr)

! Define variable snowLiquidMassEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowLiquidMassEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowLiquidMassEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowLiquidMassEdgeFlux', r3Ptr)

! Define variable snowGrainRadiusEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowGrainRadiusEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerSnowGrainRadiusActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowGrainRadiusEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowGrainRadiusEdgeFlux', r3Ptr)

! Define variable snowDensityEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowDensityEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowDensityEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowDensityEdgeFlux', r3Ptr)

! Define variable iceAgeEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceAgeEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerIceAgeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceAgeEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAgeEdgeFlux', r3Ptr)

! Define variable firstYearIceAreaEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'firstYearIceAreaEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerFirstYearIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'firstYearIceAreaEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'firstYearIceAreaEdgeFlux', r3Ptr)

! Define variable levelIceAreaEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'levelIceAreaEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLevelIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceAreaEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'levelIceAreaEdgeFlux', r3Ptr)

! Define variable levelIceVolumeEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'levelIceVolumeEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLevelIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceVolumeEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'levelIceVolumeEdgeFlux', r3Ptr)

! Define variable pondAreaEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondAreaEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerPondsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondAreaEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondAreaEdgeFlux', r3Ptr)

! Define variable pondDepthEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondDepthEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerPondsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondDepthEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondDepthEdgeFlux', r3Ptr)

! Define variable pondLidThicknessEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondLidThicknessEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLidThicknessActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondLidThicknessEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondLidThicknessEdgeFlux', r3Ptr)

! Define variable snowScatteringAerosolEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowScatteringAerosolEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowScatteringAerosolEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowScatteringAerosolEdgeFlux', r3Ptr)

! Define variable snowBodyAerosolEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowBodyAerosolEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowBodyAerosolEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowBodyAerosolEdgeFlux', r3Ptr)

! Define variable iceScatteringAerosolEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceScatteringAerosolEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceScatteringAerosolEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceScatteringAerosolEdgeFlux', r3Ptr)

! Define variable iceBodyAerosolEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceBodyAerosolEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceBodyAerosolEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceBodyAerosolEdgeFlux', r3Ptr)

! Define variable brineFractionEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'brineFractionEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerBrineActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'brineFractionEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'brineFractionEdgeFlux', r3Ptr)

! Define variable mobileFractionEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'mobileFractionEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nZBGCTracers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerMobileFractionActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'mobileFractionEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'mobileFractionEdgeFlux', r3Ptr)

! Define variable skeletalAlgaeConcEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalAlgaeConcEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgae'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAlgaeConcEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalAlgaeConcEdgeFlux', r3Ptr)

! Define variable skeletalDOCConcEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDOCConcEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOC'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDOCConcEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDOCConcEdgeFlux', r3Ptr)

! Define variable skeletalDICConcEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDICConcEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDIC'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDICConcEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDICConcEdgeFlux', r3Ptr)

! Define variable skeletalDONConcEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDONConcEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDON'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDONConcEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDONConcEdgeFlux', r3Ptr)

! Define variable skeletalNitrateConcEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalNitrateConcEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNitrateConcEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalNitrateConcEdgeFlux', r3Ptr)

! Define variable skeletalSilicateConcEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalSilicateConcEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalSilicateConcEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalSilicateConcEdgeFlux', r3Ptr)

! Define variable skeletalAmmoniumConcEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalAmmoniumConcEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAmmoniumConcEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalAmmoniumConcEdgeFlux', r3Ptr)

! Define variable skeletalDMSConcEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSConcEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSConcEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSConcEdgeFlux', r3Ptr)

! Define variable skeletalDMSPpConcEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSPpConcEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPpConcEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPpConcEdgeFlux', r3Ptr)

! Define variable skeletalDMSPdConcEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSPdConcEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPdConcEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPdConcEdgeFlux', r3Ptr)

! Define variable skeletalNonreactiveConcEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalNonreactiveConcEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNonreactiveConcEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalNonreactiveConcEdgeFlux', r3Ptr)

! Define variable skeletalHumicsConcEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalHumicsConcEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalHumicsConcEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalHumicsConcEdgeFlux', r3Ptr)

! Define variable skeletalParticulateIronConcEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalParticulateIronConcEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nParticulateIron'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalParticulateIronConcEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalParticulateIronConcEdgeFlux', r3Ptr)

! Define variable skeletalDissolvedIronConcEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDissolvedIronConcEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDissolvedIron'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDissolvedIronConcEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDissolvedIronConcEdgeFlux', r3Ptr)

! Define variable verticalAlgaeSnowEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAlgaeSnowEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgaeSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeSnowEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeSnowEdgeFlux', r3Ptr)

! Define variable verticalDOCSnowEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDOCSnowEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOCSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCSnowEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCSnowEdgeFlux', r3Ptr)

! Define variable verticalDICSnowEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDICSnowEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDICSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICSnowEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDICSnowEdgeFlux', r3Ptr)

! Define variable verticalDONSnowEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDONSnowEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDONSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONSnowEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDONSnowEdgeFlux', r3Ptr)

! Define variable verticalNitrateSnowEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNitrateSnowEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateSnowEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateSnowEdgeFlux', r3Ptr)

! Define variable verticalSilicateSnowEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSilicateSnowEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateSnowEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateSnowEdgeFlux', r3Ptr)

! Define variable verticalAmmoniumSnowEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAmmoniumSnowEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumSnowEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumSnowEdgeFlux', r3Ptr)

! Define variable verticalDMSSnowEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSSnowEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSSnowEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSSnowEdgeFlux', r3Ptr)

! Define variable verticalDMSPpSnowEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPpSnowEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpSnowEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpSnowEdgeFlux', r3Ptr)

! Define variable verticalDMSPdSnowEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPdSnowEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdSnowEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdSnowEdgeFlux', r3Ptr)

! Define variable verticalNonreactiveSnowEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNonreactiveSnowEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveSnowEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveSnowEdgeFlux', r3Ptr)

! Define variable verticalHumicsSnowEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalHumicsSnowEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsSnowEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsSnowEdgeFlux', r3Ptr)

! Define variable verticalParticulateIronSnowEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalParticulateIronSnowEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nPartIronSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronSnowEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronSnowEdgeFlux', r3Ptr)

! Define variable verticalDissolvedIronSnowEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDissolvedIronSnowEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDisIronSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronSnowEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronSnowEdgeFlux', r3Ptr)

! Define variable verticalAlgaeIceEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAlgaeIceEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgaeIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeIceEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeIceEdgeFlux', r3Ptr)

! Define variable verticalDOCIceEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDOCIceEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOCIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCIceEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCIceEdgeFlux', r3Ptr)

! Define variable verticalDICIceEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDICIceEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDICIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICIceEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDICIceEdgeFlux', r3Ptr)

! Define variable verticalDONIceEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDONIceEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDONIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONIceEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDONIceEdgeFlux', r3Ptr)

! Define variable verticalNitrateIceEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNitrateIceEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateIceEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateIceEdgeFlux', r3Ptr)

! Define variable verticalSilicateIceEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSilicateIceEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateIceEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateIceEdgeFlux', r3Ptr)

! Define variable verticalAmmoniumIceEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAmmoniumIceEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumIceEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumIceEdgeFlux', r3Ptr)

! Define variable verticalDMSIceEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSIceEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSIceEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSIceEdgeFlux', r3Ptr)

! Define variable verticalDMSPpIceEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPpIceEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpIceEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpIceEdgeFlux', r3Ptr)

! Define variable verticalDMSPdIceEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPdIceEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdIceEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdIceEdgeFlux', r3Ptr)

! Define variable verticalNonreactiveIceEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNonreactiveIceEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveIceEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveIceEdgeFlux', r3Ptr)

! Define variable verticalHumicsIceEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalHumicsIceEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsIceEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsIceEdgeFlux', r3Ptr)

! Define variable verticalParticulateIronIceEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalParticulateIronIceEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nPartIronIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronIceEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronIceEdgeFlux', r3Ptr)

! Define variable verticalDissolvedIronIceEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDissolvedIronIceEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDisIronIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronIceEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronIceEdgeFlux', r3Ptr)

! Define variable verticalAerosolsSnowEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAerosolsSnowEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nzAerosolsSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsSnowEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsSnowEdgeFlux', r3Ptr)

! Define variable verticalAerosolsIceEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAerosolsIceEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nzAerosolsIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsIceEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsIceEdgeFlux', r3Ptr)

! Define variable verticalSalinityEdgeFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSalinityEdgeFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZSalinityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSalinityEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSalinityEdgeFlux', r3Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_tracer_edge_fluxes


   subroutine seaice_generate_pool_tracer_products(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'tracer_products', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'tracer_products', newSubPool)

! Define variable iceAreaCategoryProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceAreaCategoryProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceAreaCategoryProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAreaCategoryProduct', r3Ptr)

! Define variable iceVolumeCategoryProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceVolumeCategoryProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceVolumeCategoryProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceVolumeCategoryProduct', r3Ptr)

! Define variable snowVolumeCategoryProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowVolumeCategoryProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowVolumeCategoryProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowVolumeCategoryProduct', r3Ptr)

! Define variable surfaceTemperatureProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'surfaceTemperatureProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'surfaceTemperatureProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceTemperatureProduct', r3Ptr)

! Define variable iceEnthalpyProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceEnthalpyProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceEnthalpyProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceEnthalpyProduct', r3Ptr)

! Define variable iceSalinityProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceSalinityProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceSalinityProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceSalinityProduct', r3Ptr)

! Define variable snowEnthalpyProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowEnthalpyProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowEnthalpyProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowEnthalpyProduct', r3Ptr)

! Define variable snowIceMassProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowIceMassProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowIceMassProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowIceMassProduct', r3Ptr)

! Define variable snowLiquidMassProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowLiquidMassProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowLiquidMassProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowLiquidMassProduct', r3Ptr)

! Define variable snowGrainRadiusProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowGrainRadiusProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerSnowGrainRadiusActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowGrainRadiusProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowGrainRadiusProduct', r3Ptr)

! Define variable snowDensityProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowDensityProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowDensityProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowDensityProduct', r3Ptr)

! Define variable iceAgeProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceAgeProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerIceAgeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceAgeProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAgeProduct', r3Ptr)

! Define variable firstYearIceAreaProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'firstYearIceAreaProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerFirstYearIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'firstYearIceAreaProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'firstYearIceAreaProduct', r3Ptr)

! Define variable levelIceAreaProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'levelIceAreaProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLevelIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceAreaProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'levelIceAreaProduct', r3Ptr)

! Define variable levelIceVolumeProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'levelIceVolumeProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLevelIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceVolumeProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'levelIceVolumeProduct', r3Ptr)

! Define variable pondAreaProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondAreaProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerPondsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondAreaProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondAreaProduct', r3Ptr)

! Define variable pondDepthProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondDepthProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerPondsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondDepthProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondDepthProduct', r3Ptr)

! Define variable pondLidThicknessProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondLidThicknessProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLidThicknessActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondLidThicknessProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondLidThicknessProduct', r3Ptr)

! Define variable snowScatteringAerosolProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowScatteringAerosolProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowScatteringAerosolProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowScatteringAerosolProduct', r3Ptr)

! Define variable snowBodyAerosolProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowBodyAerosolProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowBodyAerosolProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowBodyAerosolProduct', r3Ptr)

! Define variable iceScatteringAerosolProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceScatteringAerosolProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceScatteringAerosolProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceScatteringAerosolProduct', r3Ptr)

! Define variable iceBodyAerosolProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceBodyAerosolProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceBodyAerosolProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceBodyAerosolProduct', r3Ptr)

! Define variable brineFractionProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'brineFractionProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerBrineActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'brineFractionProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'brineFractionProduct', r3Ptr)

! Define variable mobileFractionProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'mobileFractionProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nZBGCTracers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerMobileFractionActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'mobileFractionProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'mobileFractionProduct', r3Ptr)

! Define variable skeletalAlgaeConcProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalAlgaeConcProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgae'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAlgaeConcProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalAlgaeConcProduct', r3Ptr)

! Define variable skeletalDOCConcProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDOCConcProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOC'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDOCConcProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDOCConcProduct', r3Ptr)

! Define variable skeletalDICConcProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDICConcProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDIC'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDICConcProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDICConcProduct', r3Ptr)

! Define variable skeletalDONConcProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDONConcProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDON'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDONConcProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDONConcProduct', r3Ptr)

! Define variable skeletalNitrateConcProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalNitrateConcProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNitrateConcProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalNitrateConcProduct', r3Ptr)

! Define variable skeletalSilicateConcProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalSilicateConcProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalSilicateConcProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalSilicateConcProduct', r3Ptr)

! Define variable skeletalAmmoniumConcProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalAmmoniumConcProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAmmoniumConcProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalAmmoniumConcProduct', r3Ptr)

! Define variable skeletalDMSConcProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSConcProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSConcProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSConcProduct', r3Ptr)

! Define variable skeletalDMSPpConcProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSPpConcProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPpConcProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPpConcProduct', r3Ptr)

! Define variable skeletalDMSPdConcProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSPdConcProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPdConcProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPdConcProduct', r3Ptr)

! Define variable skeletalNonreactiveConcProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalNonreactiveConcProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNonreactiveConcProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalNonreactiveConcProduct', r3Ptr)

! Define variable skeletalHumicsConcProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalHumicsConcProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalHumicsConcProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalHumicsConcProduct', r3Ptr)

! Define variable skeletalParticulateIronConcProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalParticulateIronConcProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nParticulateIron'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalParticulateIronConcProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalParticulateIronConcProduct', r3Ptr)

! Define variable skeletalDissolvedIronConcProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDissolvedIronConcProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDissolvedIron'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDissolvedIronConcProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDissolvedIronConcProduct', r3Ptr)

! Define variable verticalAlgaeSnowProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAlgaeSnowProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgaeSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeSnowProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeSnowProduct', r3Ptr)

! Define variable verticalDOCSnowProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDOCSnowProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOCSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCSnowProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCSnowProduct', r3Ptr)

! Define variable verticalDICSnowProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDICSnowProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDICSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICSnowProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDICSnowProduct', r3Ptr)

! Define variable verticalDONSnowProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDONSnowProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDONSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONSnowProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDONSnowProduct', r3Ptr)

! Define variable verticalNitrateSnowProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNitrateSnowProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateSnowProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateSnowProduct', r3Ptr)

! Define variable verticalSilicateSnowProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSilicateSnowProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateSnowProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateSnowProduct', r3Ptr)

! Define variable verticalAmmoniumSnowProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAmmoniumSnowProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumSnowProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumSnowProduct', r3Ptr)

! Define variable verticalDMSSnowProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSSnowProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSSnowProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSSnowProduct', r3Ptr)

! Define variable verticalDMSPpSnowProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPpSnowProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpSnowProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpSnowProduct', r3Ptr)

! Define variable verticalDMSPdSnowProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPdSnowProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdSnowProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdSnowProduct', r3Ptr)

! Define variable verticalNonreactiveSnowProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNonreactiveSnowProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveSnowProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveSnowProduct', r3Ptr)

! Define variable verticalHumicsSnowProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalHumicsSnowProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsSnowProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsSnowProduct', r3Ptr)

! Define variable verticalParticulateIronSnowProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalParticulateIronSnowProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nPartIronSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronSnowProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronSnowProduct', r3Ptr)

! Define variable verticalDissolvedIronSnowProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDissolvedIronSnowProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDisIronSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronSnowProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronSnowProduct', r3Ptr)

! Define variable verticalAlgaeIceProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAlgaeIceProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgaeIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeIceProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeIceProduct', r3Ptr)

! Define variable verticalDOCIceProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDOCIceProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOCIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCIceProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCIceProduct', r3Ptr)

! Define variable verticalDICIceProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDICIceProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDICIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICIceProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDICIceProduct', r3Ptr)

! Define variable verticalDONIceProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDONIceProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDONIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONIceProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDONIceProduct', r3Ptr)

! Define variable verticalNitrateIceProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNitrateIceProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateIceProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateIceProduct', r3Ptr)

! Define variable verticalSilicateIceProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSilicateIceProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateIceProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateIceProduct', r3Ptr)

! Define variable verticalAmmoniumIceProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAmmoniumIceProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumIceProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumIceProduct', r3Ptr)

! Define variable verticalDMSIceProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSIceProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSIceProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSIceProduct', r3Ptr)

! Define variable verticalDMSPpIceProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPpIceProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpIceProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpIceProduct', r3Ptr)

! Define variable verticalDMSPdIceProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPdIceProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdIceProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdIceProduct', r3Ptr)

! Define variable verticalNonreactiveIceProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNonreactiveIceProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveIceProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveIceProduct', r3Ptr)

! Define variable verticalHumicsIceProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalHumicsIceProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsIceProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsIceProduct', r3Ptr)

! Define variable verticalParticulateIronIceProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalParticulateIronIceProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nPartIronIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronIceProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronIceProduct', r3Ptr)

! Define variable verticalDissolvedIronIceProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDissolvedIronIceProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDisIronIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronIceProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronIceProduct', r3Ptr)

! Define variable verticalAerosolsSnowProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAerosolsSnowProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nzAerosolsSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsSnowProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsSnowProduct', r3Ptr)

! Define variable verticalAerosolsIceProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAerosolsIceProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nzAerosolsIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsIceProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsIceProduct', r3Ptr)

! Define variable verticalSalinityProduct
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSalinityProduct'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZSalinityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSalinityProduct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSalinityProduct', r3Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_tracer_products


   subroutine seaice_generate_pool_tracer_triangles(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'tracer_triangles', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'tracer_triangles', newSubPool)

! Define variable iceAreaCategoryTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'iceAreaCategoryTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'ONE'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      r5Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceAreaCategoryTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAreaCategoryTriangle', r5Ptr)

! Define variable iceVolumeCategoryTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'iceVolumeCategoryTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'ONE'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      r5Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceVolumeCategoryTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'iceVolumeCategoryTriangle', r5Ptr)

! Define variable snowVolumeCategoryTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'snowVolumeCategoryTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'ONE'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      r5Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowVolumeCategoryTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'snowVolumeCategoryTriangle', r5Ptr)

! Define variable surfaceTemperatureTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'surfaceTemperatureTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'ONE'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      r5Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'surfaceTemperatureTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceTemperatureTriangle', r5Ptr)

! Define variable iceEnthalpyTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'iceEnthalpyTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nIceLayers'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      r5Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceEnthalpyTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'iceEnthalpyTriangle', r5Ptr)

! Define variable iceSalinityTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'iceSalinityTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nIceLayers'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      r5Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceSalinityTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'iceSalinityTriangle', r5Ptr)

! Define variable snowEnthalpyTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'snowEnthalpyTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nSnowLayers'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      r5Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowEnthalpyTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'snowEnthalpyTriangle', r5Ptr)

! Define variable snowIceMassTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'snowIceMassTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nSnowLayers'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowIceMassTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'snowIceMassTriangle', r5Ptr)

! Define variable snowLiquidMassTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'snowLiquidMassTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nSnowLayers'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowLiquidMassTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'snowLiquidMassTriangle', r5Ptr)

! Define variable snowGrainRadiusTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'snowGrainRadiusTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nSnowLayers'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgColumnTracerSnowGrainRadiusActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowGrainRadiusTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'snowGrainRadiusTriangle', r5Ptr)

! Define variable snowDensityTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'snowDensityTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nSnowLayers'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowDensityTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'snowDensityTriangle', r5Ptr)

! Define variable iceAgeTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'iceAgeTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'ONE'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgColumnTracerIceAgeActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceAgeTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAgeTriangle', r5Ptr)

! Define variable firstYearIceAreaTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'firstYearIceAreaTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'ONE'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgColumnTracerFirstYearIceActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'firstYearIceAreaTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'firstYearIceAreaTriangle', r5Ptr)

! Define variable levelIceAreaTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'levelIceAreaTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'ONE'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgColumnTracerLevelIceActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceAreaTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'levelIceAreaTriangle', r5Ptr)

! Define variable levelIceVolumeTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'levelIceVolumeTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'ONE'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgColumnTracerLevelIceActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceVolumeTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'levelIceVolumeTriangle', r5Ptr)

! Define variable pondAreaTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'pondAreaTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'ONE'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgColumnTracerPondsActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondAreaTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'pondAreaTriangle', r5Ptr)

! Define variable pondDepthTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'pondDepthTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'ONE'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgColumnTracerPondsActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondDepthTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'pondDepthTriangle', r5Ptr)

! Define variable pondLidThicknessTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'pondLidThicknessTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'ONE'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgColumnTracerLidThicknessActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondLidThicknessTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'pondLidThicknessTriangle', r5Ptr)

! Define variable snowScatteringAerosolTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'snowScatteringAerosolTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nAerosols'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowScatteringAerosolTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'snowScatteringAerosolTriangle', r5Ptr)

! Define variable snowBodyAerosolTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'snowBodyAerosolTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nAerosols'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowBodyAerosolTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'snowBodyAerosolTriangle', r5Ptr)

! Define variable iceScatteringAerosolTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'iceScatteringAerosolTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nAerosols'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceScatteringAerosolTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'iceScatteringAerosolTriangle', r5Ptr)

! Define variable iceBodyAerosolTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'iceBodyAerosolTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nAerosols'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceBodyAerosolTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'iceBodyAerosolTriangle', r5Ptr)

! Define variable brineFractionTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'brineFractionTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'ONE'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerBrineActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'brineFractionTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'brineFractionTriangle', r5Ptr)

! Define variable mobileFractionTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'mobileFractionTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nZBGCTracers'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerMobileFractionActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'mobileFractionTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'mobileFractionTriangle', r5Ptr)

! Define variable skeletalAlgaeConcTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'skeletalAlgaeConcTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nAlgae'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerSkeletalAlgaeActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAlgaeConcTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalAlgaeConcTriangle', r5Ptr)

! Define variable skeletalDOCConcTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'skeletalDOCConcTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nDOC'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerSkeletalCarbonActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDOCConcTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDOCConcTriangle', r5Ptr)

! Define variable skeletalDICConcTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'skeletalDICConcTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nDIC'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerSkeletalCarbonActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDICConcTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDICConcTriangle', r5Ptr)

! Define variable skeletalDONConcTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'skeletalDONConcTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nDON'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerSkeletalDONActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDONConcTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDONConcTriangle', r5Ptr)

! Define variable skeletalNitrateConcTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'skeletalNitrateConcTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'ONE'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerSkeletalNitrateActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNitrateConcTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalNitrateConcTriangle', r5Ptr)

! Define variable skeletalSilicateConcTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'skeletalSilicateConcTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'ONE'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerSkeletalSilicateActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalSilicateConcTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalSilicateConcTriangle', r5Ptr)

! Define variable skeletalAmmoniumConcTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'skeletalAmmoniumConcTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'ONE'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerSkeletalAmmoniumActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAmmoniumConcTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalAmmoniumConcTriangle', r5Ptr)

! Define variable skeletalDMSConcTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'skeletalDMSConcTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'ONE'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSConcTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSConcTriangle', r5Ptr)

! Define variable skeletalDMSPpConcTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'skeletalDMSPpConcTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'ONE'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPpConcTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPpConcTriangle', r5Ptr)

! Define variable skeletalDMSPdConcTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'skeletalDMSPdConcTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'ONE'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPdConcTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPdConcTriangle', r5Ptr)

! Define variable skeletalNonreactiveConcTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'skeletalNonreactiveConcTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'ONE'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerSkeletalNonreactiveActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNonreactiveConcTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalNonreactiveConcTriangle', r5Ptr)

! Define variable skeletalHumicsConcTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'skeletalHumicsConcTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'ONE'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerSkeletalHumicsActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalHumicsConcTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalHumicsConcTriangle', r5Ptr)

! Define variable skeletalParticulateIronConcTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'skeletalParticulateIronConcTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nParticulateIron'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerSkeletalIronActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalParticulateIronConcTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalParticulateIronConcTriangle', r5Ptr)

! Define variable skeletalDissolvedIronConcTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'skeletalDissolvedIronConcTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nDissolvedIron'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerSkeletalIronActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDissolvedIronConcTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDissolvedIronConcTriangle', r5Ptr)

! Define variable verticalAlgaeSnowTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalAlgaeSnowTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nAlgaeSnowLayers'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeSnowTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeSnowTriangle', r5Ptr)

! Define variable verticalDOCSnowTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalDOCSnowTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nDOCSnowLayers'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCSnowTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCSnowTriangle', r5Ptr)

! Define variable verticalDICSnowTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalDICSnowTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nDICSnowLayers'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICSnowTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDICSnowTriangle', r5Ptr)

! Define variable verticalDONSnowTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalDONSnowTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nDONSnowLayers'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalDONActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONSnowTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDONSnowTriangle', r5Ptr)

! Define variable verticalNitrateSnowTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalNitrateSnowTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'TWO'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalNitrateActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateSnowTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateSnowTriangle', r5Ptr)

! Define variable verticalSilicateSnowTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalSilicateSnowTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'TWO'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalSilicateActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateSnowTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateSnowTriangle', r5Ptr)

! Define variable verticalAmmoniumSnowTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalAmmoniumSnowTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'TWO'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumSnowTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumSnowTriangle', r5Ptr)

! Define variable verticalDMSSnowTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalDMSSnowTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'TWO'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSSnowTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSSnowTriangle', r5Ptr)

! Define variable verticalDMSPpSnowTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalDMSPpSnowTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'TWO'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpSnowTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpSnowTriangle', r5Ptr)

! Define variable verticalDMSPdSnowTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalDMSPdSnowTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'TWO'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdSnowTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdSnowTriangle', r5Ptr)

! Define variable verticalNonreactiveSnowTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalNonreactiveSnowTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'TWO'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveSnowTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveSnowTriangle', r5Ptr)

! Define variable verticalHumicsSnowTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalHumicsSnowTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'TWO'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalHumicsActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsSnowTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsSnowTriangle', r5Ptr)

! Define variable verticalParticulateIronSnowTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalParticulateIronSnowTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nPartIronSnowLayers'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronSnowTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronSnowTriangle', r5Ptr)

! Define variable verticalDissolvedIronSnowTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalDissolvedIronSnowTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nDisIronSnowLayers'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronSnowTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronSnowTriangle', r5Ptr)

! Define variable verticalAlgaeIceTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalAlgaeIceTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nAlgaeIceLayers'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeIceTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeIceTriangle', r5Ptr)

! Define variable verticalDOCIceTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalDOCIceTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nDOCIceLayers'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCIceTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCIceTriangle', r5Ptr)

! Define variable verticalDICIceTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalDICIceTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nDICIceLayers'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICIceTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDICIceTriangle', r5Ptr)

! Define variable verticalDONIceTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalDONIceTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nDONIceLayers'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalDONActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONIceTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDONIceTriangle', r5Ptr)

! Define variable verticalNitrateIceTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalNitrateIceTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nBioLayersP1'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalNitrateActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateIceTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateIceTriangle', r5Ptr)

! Define variable verticalSilicateIceTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalSilicateIceTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nBioLayersP1'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalSilicateActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateIceTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateIceTriangle', r5Ptr)

! Define variable verticalAmmoniumIceTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalAmmoniumIceTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nBioLayersP1'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumIceTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumIceTriangle', r5Ptr)

! Define variable verticalDMSIceTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalDMSIceTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nBioLayersP1'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSIceTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSIceTriangle', r5Ptr)

! Define variable verticalDMSPpIceTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalDMSPpIceTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nBioLayersP1'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpIceTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpIceTriangle', r5Ptr)

! Define variable verticalDMSPdIceTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalDMSPdIceTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nBioLayersP1'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdIceTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdIceTriangle', r5Ptr)

! Define variable verticalNonreactiveIceTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalNonreactiveIceTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nBioLayersP1'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveIceTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveIceTriangle', r5Ptr)

! Define variable verticalHumicsIceTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalHumicsIceTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nBioLayersP1'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalHumicsActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsIceTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsIceTriangle', r5Ptr)

! Define variable verticalParticulateIronIceTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalParticulateIronIceTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nPartIronIceLayers'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronIceTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronIceTriangle', r5Ptr)

! Define variable verticalDissolvedIronIceTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalDissolvedIronIceTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nDisIronIceLayers'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronIceTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronIceTriangle', r5Ptr)

! Define variable verticalAerosolsSnowTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalAerosolsSnowTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nzAerosolsSnowLayers'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerZAerosolsActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsSnowTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsSnowTriangle', r5Ptr)

! Define variable verticalAerosolsIceTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalAerosolsIceTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nzAerosolsIceLayers'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerZAerosolsActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsIceTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsIceTriangle', r5Ptr)

! Define variable verticalSalinityTriangle
      allocate(r5Ptr)

! Setting up time level 1
      r5Ptr % fieldName = 'verticalSalinityTriangle'
      r5Ptr % isVarArray = .false.
      r5Ptr % isDecomposed = .true.
      r5Ptr % hasTimeDimension = .false.
      r5Ptr % isPersistent = .true.
      r5Ptr % isActive = .false.
! Setting up dimensions
      r5Ptr % dimNames(1) = 'nBioLayers'
      r5Ptr % dimNames(2) = 'nCategories'
      r5Ptr % dimNames(3) = 'nQuadPoints'
      r5Ptr % dimNames(4) = 'nTriPerEdgeRemap'
      r5Ptr % dimNames(5) = 'nEdges'
      r5Ptr % defaultValue = 0.0
      allocate(r5Ptr % attLists(1))
      allocate(r5Ptr % attLists(1) % attList)
      r5Ptr % missingValue = MPAS_REAL_FILLVAL
      r5Ptr % block => block

      if (pkgTracerZSalinityActive) then
         r5Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSalinityTriangle', r5Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSalinityTriangle', r5Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_tracer_triangles


   subroutine seaice_generate_pool_tracer_barycenter(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'tracer_barycenter', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'tracer_barycenter', newSubPool)

! Define variable iceAreaCategoryBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceAreaCategoryBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceAreaCategoryBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAreaCategoryBarycenterx', r3Ptr)

! Define variable iceAreaCategoryBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceAreaCategoryBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceAreaCategoryBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAreaCategoryBarycentery', r3Ptr)

! Define variable iceVolumeCategoryBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceVolumeCategoryBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceVolumeCategoryBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceVolumeCategoryBarycenterx', r3Ptr)

! Define variable iceVolumeCategoryBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceVolumeCategoryBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceVolumeCategoryBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceVolumeCategoryBarycentery', r3Ptr)

! Define variable snowVolumeCategoryBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowVolumeCategoryBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowVolumeCategoryBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowVolumeCategoryBarycenterx', r3Ptr)

! Define variable snowVolumeCategoryBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowVolumeCategoryBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowVolumeCategoryBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowVolumeCategoryBarycentery', r3Ptr)

! Define variable surfaceTemperatureBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'surfaceTemperatureBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'surfaceTemperatureBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceTemperatureBarycenterx', r3Ptr)

! Define variable surfaceTemperatureBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'surfaceTemperatureBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'surfaceTemperatureBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceTemperatureBarycentery', r3Ptr)

! Define variable iceEnthalpyBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceEnthalpyBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceEnthalpyBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceEnthalpyBarycenterx', r3Ptr)

! Define variable iceEnthalpyBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceEnthalpyBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceEnthalpyBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceEnthalpyBarycentery', r3Ptr)

! Define variable iceSalinityBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceSalinityBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceSalinityBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceSalinityBarycenterx', r3Ptr)

! Define variable iceSalinityBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceSalinityBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceSalinityBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceSalinityBarycentery', r3Ptr)

! Define variable snowEnthalpyBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowEnthalpyBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowEnthalpyBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowEnthalpyBarycenterx', r3Ptr)

! Define variable snowEnthalpyBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowEnthalpyBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowEnthalpyBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowEnthalpyBarycentery', r3Ptr)

! Define variable snowIceMassBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowIceMassBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowIceMassBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowIceMassBarycenterx', r3Ptr)

! Define variable snowIceMassBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowIceMassBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowIceMassBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowIceMassBarycentery', r3Ptr)

! Define variable snowLiquidMassBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowLiquidMassBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowLiquidMassBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowLiquidMassBarycenterx', r3Ptr)

! Define variable snowLiquidMassBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowLiquidMassBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowLiquidMassBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowLiquidMassBarycentery', r3Ptr)

! Define variable snowGrainRadiusBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowGrainRadiusBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerSnowGrainRadiusActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowGrainRadiusBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowGrainRadiusBarycenterx', r3Ptr)

! Define variable snowGrainRadiusBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowGrainRadiusBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerSnowGrainRadiusActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowGrainRadiusBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowGrainRadiusBarycentery', r3Ptr)

! Define variable snowDensityBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowDensityBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowDensityBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowDensityBarycenterx', r3Ptr)

! Define variable snowDensityBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowDensityBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowDensityBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowDensityBarycentery', r3Ptr)

! Define variable iceAgeBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceAgeBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerIceAgeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceAgeBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAgeBarycenterx', r3Ptr)

! Define variable iceAgeBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceAgeBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerIceAgeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceAgeBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAgeBarycentery', r3Ptr)

! Define variable firstYearIceAreaBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'firstYearIceAreaBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerFirstYearIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'firstYearIceAreaBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'firstYearIceAreaBarycenterx', r3Ptr)

! Define variable firstYearIceAreaBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'firstYearIceAreaBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerFirstYearIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'firstYearIceAreaBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'firstYearIceAreaBarycentery', r3Ptr)

! Define variable levelIceAreaBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'levelIceAreaBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLevelIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceAreaBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'levelIceAreaBarycenterx', r3Ptr)

! Define variable levelIceAreaBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'levelIceAreaBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLevelIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceAreaBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'levelIceAreaBarycentery', r3Ptr)

! Define variable levelIceVolumeBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'levelIceVolumeBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLevelIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceVolumeBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'levelIceVolumeBarycenterx', r3Ptr)

! Define variable levelIceVolumeBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'levelIceVolumeBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLevelIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceVolumeBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'levelIceVolumeBarycentery', r3Ptr)

! Define variable pondAreaBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondAreaBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerPondsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondAreaBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondAreaBarycenterx', r3Ptr)

! Define variable pondAreaBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondAreaBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerPondsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondAreaBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondAreaBarycentery', r3Ptr)

! Define variable pondDepthBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondDepthBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerPondsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondDepthBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondDepthBarycenterx', r3Ptr)

! Define variable pondDepthBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondDepthBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerPondsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondDepthBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondDepthBarycentery', r3Ptr)

! Define variable pondLidThicknessBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondLidThicknessBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLidThicknessActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondLidThicknessBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondLidThicknessBarycenterx', r3Ptr)

! Define variable pondLidThicknessBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondLidThicknessBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLidThicknessActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondLidThicknessBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondLidThicknessBarycentery', r3Ptr)

! Define variable snowScatteringAerosolBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowScatteringAerosolBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowScatteringAerosolBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowScatteringAerosolBarycenterx', r3Ptr)

! Define variable snowScatteringAerosolBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowScatteringAerosolBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowScatteringAerosolBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowScatteringAerosolBarycentery', r3Ptr)

! Define variable snowBodyAerosolBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowBodyAerosolBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowBodyAerosolBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowBodyAerosolBarycenterx', r3Ptr)

! Define variable snowBodyAerosolBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowBodyAerosolBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowBodyAerosolBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowBodyAerosolBarycentery', r3Ptr)

! Define variable iceScatteringAerosolBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceScatteringAerosolBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceScatteringAerosolBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceScatteringAerosolBarycenterx', r3Ptr)

! Define variable iceScatteringAerosolBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceScatteringAerosolBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceScatteringAerosolBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceScatteringAerosolBarycentery', r3Ptr)

! Define variable iceBodyAerosolBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceBodyAerosolBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceBodyAerosolBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceBodyAerosolBarycenterx', r3Ptr)

! Define variable iceBodyAerosolBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceBodyAerosolBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceBodyAerosolBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceBodyAerosolBarycentery', r3Ptr)

! Define variable brineFractionBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'brineFractionBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerBrineActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'brineFractionBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'brineFractionBarycenterx', r3Ptr)

! Define variable brineFractionBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'brineFractionBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerBrineActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'brineFractionBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'brineFractionBarycentery', r3Ptr)

! Define variable mobileFractionBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'mobileFractionBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nZBGCTracers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerMobileFractionActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'mobileFractionBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'mobileFractionBarycenterx', r3Ptr)

! Define variable mobileFractionBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'mobileFractionBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nZBGCTracers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerMobileFractionActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'mobileFractionBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'mobileFractionBarycentery', r3Ptr)

! Define variable skeletalAlgaeConcBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalAlgaeConcBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgae'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAlgaeConcBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalAlgaeConcBarycenterx', r3Ptr)

! Define variable skeletalAlgaeConcBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalAlgaeConcBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgae'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAlgaeConcBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalAlgaeConcBarycentery', r3Ptr)

! Define variable skeletalDOCConcBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDOCConcBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOC'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDOCConcBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDOCConcBarycenterx', r3Ptr)

! Define variable skeletalDOCConcBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDOCConcBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOC'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDOCConcBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDOCConcBarycentery', r3Ptr)

! Define variable skeletalDICConcBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDICConcBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDIC'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDICConcBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDICConcBarycenterx', r3Ptr)

! Define variable skeletalDICConcBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDICConcBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDIC'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDICConcBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDICConcBarycentery', r3Ptr)

! Define variable skeletalDONConcBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDONConcBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDON'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDONConcBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDONConcBarycenterx', r3Ptr)

! Define variable skeletalDONConcBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDONConcBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDON'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDONConcBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDONConcBarycentery', r3Ptr)

! Define variable skeletalNitrateConcBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalNitrateConcBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNitrateConcBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalNitrateConcBarycenterx', r3Ptr)

! Define variable skeletalNitrateConcBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalNitrateConcBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNitrateConcBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalNitrateConcBarycentery', r3Ptr)

! Define variable skeletalSilicateConcBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalSilicateConcBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalSilicateConcBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalSilicateConcBarycenterx', r3Ptr)

! Define variable skeletalSilicateConcBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalSilicateConcBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalSilicateConcBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalSilicateConcBarycentery', r3Ptr)

! Define variable skeletalAmmoniumConcBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalAmmoniumConcBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAmmoniumConcBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalAmmoniumConcBarycenterx', r3Ptr)

! Define variable skeletalAmmoniumConcBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalAmmoniumConcBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAmmoniumConcBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalAmmoniumConcBarycentery', r3Ptr)

! Define variable skeletalDMSConcBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSConcBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSConcBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSConcBarycenterx', r3Ptr)

! Define variable skeletalDMSConcBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSConcBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSConcBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSConcBarycentery', r3Ptr)

! Define variable skeletalDMSPpConcBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSPpConcBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPpConcBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPpConcBarycenterx', r3Ptr)

! Define variable skeletalDMSPpConcBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSPpConcBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPpConcBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPpConcBarycentery', r3Ptr)

! Define variable skeletalDMSPdConcBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSPdConcBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPdConcBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPdConcBarycenterx', r3Ptr)

! Define variable skeletalDMSPdConcBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSPdConcBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPdConcBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPdConcBarycentery', r3Ptr)

! Define variable skeletalNonreactiveConcBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalNonreactiveConcBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNonreactiveConcBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalNonreactiveConcBarycenterx', r3Ptr)

! Define variable skeletalNonreactiveConcBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalNonreactiveConcBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNonreactiveConcBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalNonreactiveConcBarycentery', r3Ptr)

! Define variable skeletalHumicsConcBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalHumicsConcBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalHumicsConcBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalHumicsConcBarycenterx', r3Ptr)

! Define variable skeletalHumicsConcBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalHumicsConcBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalHumicsConcBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalHumicsConcBarycentery', r3Ptr)

! Define variable skeletalParticulateIronConcBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalParticulateIronConcBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nParticulateIron'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalParticulateIronConcBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalParticulateIronConcBarycenterx', r3Ptr)

! Define variable skeletalParticulateIronConcBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalParticulateIronConcBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nParticulateIron'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalParticulateIronConcBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalParticulateIronConcBarycentery', r3Ptr)

! Define variable skeletalDissolvedIronConcBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDissolvedIronConcBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDissolvedIron'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDissolvedIronConcBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDissolvedIronConcBarycenterx', r3Ptr)

! Define variable skeletalDissolvedIronConcBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDissolvedIronConcBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDissolvedIron'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDissolvedIronConcBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDissolvedIronConcBarycentery', r3Ptr)

! Define variable verticalAlgaeSnowBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAlgaeSnowBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgaeSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeSnowBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeSnowBarycenterx', r3Ptr)

! Define variable verticalAlgaeSnowBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAlgaeSnowBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgaeSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeSnowBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeSnowBarycentery', r3Ptr)

! Define variable verticalDOCSnowBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDOCSnowBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOCSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCSnowBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCSnowBarycenterx', r3Ptr)

! Define variable verticalDOCSnowBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDOCSnowBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOCSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCSnowBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCSnowBarycentery', r3Ptr)

! Define variable verticalDICSnowBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDICSnowBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDICSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICSnowBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDICSnowBarycenterx', r3Ptr)

! Define variable verticalDICSnowBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDICSnowBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDICSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICSnowBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDICSnowBarycentery', r3Ptr)

! Define variable verticalDONSnowBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDONSnowBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDONSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONSnowBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDONSnowBarycenterx', r3Ptr)

! Define variable verticalDONSnowBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDONSnowBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDONSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONSnowBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDONSnowBarycentery', r3Ptr)

! Define variable verticalNitrateSnowBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNitrateSnowBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateSnowBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateSnowBarycenterx', r3Ptr)

! Define variable verticalNitrateSnowBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNitrateSnowBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateSnowBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateSnowBarycentery', r3Ptr)

! Define variable verticalSilicateSnowBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSilicateSnowBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateSnowBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateSnowBarycenterx', r3Ptr)

! Define variable verticalSilicateSnowBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSilicateSnowBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateSnowBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateSnowBarycentery', r3Ptr)

! Define variable verticalAmmoniumSnowBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAmmoniumSnowBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumSnowBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumSnowBarycenterx', r3Ptr)

! Define variable verticalAmmoniumSnowBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAmmoniumSnowBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumSnowBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumSnowBarycentery', r3Ptr)

! Define variable verticalDMSSnowBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSSnowBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSSnowBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSSnowBarycenterx', r3Ptr)

! Define variable verticalDMSSnowBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSSnowBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSSnowBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSSnowBarycentery', r3Ptr)

! Define variable verticalDMSPpSnowBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPpSnowBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpSnowBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpSnowBarycenterx', r3Ptr)

! Define variable verticalDMSPpSnowBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPpSnowBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpSnowBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpSnowBarycentery', r3Ptr)

! Define variable verticalDMSPdSnowBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPdSnowBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdSnowBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdSnowBarycenterx', r3Ptr)

! Define variable verticalDMSPdSnowBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPdSnowBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdSnowBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdSnowBarycentery', r3Ptr)

! Define variable verticalNonreactiveSnowBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNonreactiveSnowBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveSnowBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveSnowBarycenterx', r3Ptr)

! Define variable verticalNonreactiveSnowBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNonreactiveSnowBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveSnowBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveSnowBarycentery', r3Ptr)

! Define variable verticalHumicsSnowBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalHumicsSnowBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsSnowBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsSnowBarycenterx', r3Ptr)

! Define variable verticalHumicsSnowBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalHumicsSnowBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsSnowBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsSnowBarycentery', r3Ptr)

! Define variable verticalParticulateIronSnowBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalParticulateIronSnowBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nPartIronSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronSnowBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronSnowBarycenterx', r3Ptr)

! Define variable verticalParticulateIronSnowBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalParticulateIronSnowBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nPartIronSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronSnowBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronSnowBarycentery', r3Ptr)

! Define variable verticalDissolvedIronSnowBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDissolvedIronSnowBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDisIronSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronSnowBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronSnowBarycenterx', r3Ptr)

! Define variable verticalDissolvedIronSnowBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDissolvedIronSnowBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDisIronSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronSnowBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronSnowBarycentery', r3Ptr)

! Define variable verticalAlgaeIceBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAlgaeIceBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgaeIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeIceBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeIceBarycenterx', r3Ptr)

! Define variable verticalAlgaeIceBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAlgaeIceBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgaeIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeIceBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeIceBarycentery', r3Ptr)

! Define variable verticalDOCIceBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDOCIceBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOCIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCIceBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCIceBarycenterx', r3Ptr)

! Define variable verticalDOCIceBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDOCIceBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOCIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCIceBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCIceBarycentery', r3Ptr)

! Define variable verticalDICIceBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDICIceBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDICIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICIceBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDICIceBarycenterx', r3Ptr)

! Define variable verticalDICIceBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDICIceBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDICIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICIceBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDICIceBarycentery', r3Ptr)

! Define variable verticalDONIceBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDONIceBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDONIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONIceBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDONIceBarycenterx', r3Ptr)

! Define variable verticalDONIceBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDONIceBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDONIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONIceBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDONIceBarycentery', r3Ptr)

! Define variable verticalNitrateIceBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNitrateIceBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateIceBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateIceBarycenterx', r3Ptr)

! Define variable verticalNitrateIceBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNitrateIceBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateIceBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateIceBarycentery', r3Ptr)

! Define variable verticalSilicateIceBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSilicateIceBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateIceBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateIceBarycenterx', r3Ptr)

! Define variable verticalSilicateIceBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSilicateIceBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateIceBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateIceBarycentery', r3Ptr)

! Define variable verticalAmmoniumIceBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAmmoniumIceBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumIceBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumIceBarycenterx', r3Ptr)

! Define variable verticalAmmoniumIceBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAmmoniumIceBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumIceBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumIceBarycentery', r3Ptr)

! Define variable verticalDMSIceBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSIceBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSIceBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSIceBarycenterx', r3Ptr)

! Define variable verticalDMSIceBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSIceBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSIceBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSIceBarycentery', r3Ptr)

! Define variable verticalDMSPpIceBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPpIceBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpIceBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpIceBarycenterx', r3Ptr)

! Define variable verticalDMSPpIceBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPpIceBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpIceBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpIceBarycentery', r3Ptr)

! Define variable verticalDMSPdIceBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPdIceBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdIceBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdIceBarycenterx', r3Ptr)

! Define variable verticalDMSPdIceBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPdIceBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdIceBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdIceBarycentery', r3Ptr)

! Define variable verticalNonreactiveIceBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNonreactiveIceBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveIceBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveIceBarycenterx', r3Ptr)

! Define variable verticalNonreactiveIceBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNonreactiveIceBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveIceBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveIceBarycentery', r3Ptr)

! Define variable verticalHumicsIceBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalHumicsIceBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsIceBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsIceBarycenterx', r3Ptr)

! Define variable verticalHumicsIceBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalHumicsIceBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsIceBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsIceBarycentery', r3Ptr)

! Define variable verticalParticulateIronIceBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalParticulateIronIceBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nPartIronIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronIceBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronIceBarycenterx', r3Ptr)

! Define variable verticalParticulateIronIceBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalParticulateIronIceBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nPartIronIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronIceBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronIceBarycentery', r3Ptr)

! Define variable verticalDissolvedIronIceBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDissolvedIronIceBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDisIronIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronIceBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronIceBarycenterx', r3Ptr)

! Define variable verticalDissolvedIronIceBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDissolvedIronIceBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDisIronIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronIceBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronIceBarycentery', r3Ptr)

! Define variable verticalAerosolsSnowBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAerosolsSnowBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nzAerosolsSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsSnowBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsSnowBarycenterx', r3Ptr)

! Define variable verticalAerosolsSnowBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAerosolsSnowBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nzAerosolsSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsSnowBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsSnowBarycentery', r3Ptr)

! Define variable verticalAerosolsIceBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAerosolsIceBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nzAerosolsIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsIceBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsIceBarycenterx', r3Ptr)

! Define variable verticalAerosolsIceBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAerosolsIceBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nzAerosolsIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsIceBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsIceBarycentery', r3Ptr)

! Define variable verticalSalinityBarycenterx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSalinityBarycenterx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZSalinityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSalinityBarycenterx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSalinityBarycenterx', r3Ptr)

! Define variable verticalSalinityBarycentery
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSalinityBarycentery'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZSalinityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSalinityBarycentery', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSalinityBarycentery', r3Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_tracer_barycenter


   subroutine seaice_generate_pool_tracer_reconstruction(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'tracer_reconstruction', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'tracer_reconstruction', newSubPool)

! Define variable iceAreaCategoryCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceAreaCategoryCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceAreaCategoryCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAreaCategoryCenter', r3Ptr)

! Define variable iceAreaCategoryGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceAreaCategoryGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceAreaCategoryGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAreaCategoryGradx', r3Ptr)

! Define variable iceAreaCategoryGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceAreaCategoryGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceAreaCategoryGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAreaCategoryGrady', r3Ptr)

! Define variable iceVolumeCategoryCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceVolumeCategoryCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceVolumeCategoryCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceVolumeCategoryCenter', r3Ptr)

! Define variable iceVolumeCategoryGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceVolumeCategoryGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceVolumeCategoryGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceVolumeCategoryGradx', r3Ptr)

! Define variable iceVolumeCategoryGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceVolumeCategoryGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceVolumeCategoryGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceVolumeCategoryGrady', r3Ptr)

! Define variable snowVolumeCategoryCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowVolumeCategoryCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowVolumeCategoryCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowVolumeCategoryCenter', r3Ptr)

! Define variable snowVolumeCategoryGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowVolumeCategoryGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowVolumeCategoryGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowVolumeCategoryGradx', r3Ptr)

! Define variable snowVolumeCategoryGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowVolumeCategoryGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowVolumeCategoryGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowVolumeCategoryGrady', r3Ptr)

! Define variable surfaceTemperatureCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'surfaceTemperatureCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'surfaceTemperatureCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceTemperatureCenter', r3Ptr)

! Define variable surfaceTemperatureGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'surfaceTemperatureGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'surfaceTemperatureGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceTemperatureGradx', r3Ptr)

! Define variable surfaceTemperatureGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'surfaceTemperatureGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'surfaceTemperatureGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceTemperatureGrady', r3Ptr)

! Define variable iceEnthalpyCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceEnthalpyCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceEnthalpyCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceEnthalpyCenter', r3Ptr)

! Define variable iceEnthalpyGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceEnthalpyGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceEnthalpyGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceEnthalpyGradx', r3Ptr)

! Define variable iceEnthalpyGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceEnthalpyGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceEnthalpyGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceEnthalpyGrady', r3Ptr)

! Define variable iceSalinityCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceSalinityCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceSalinityCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceSalinityCenter', r3Ptr)

! Define variable iceSalinityGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceSalinityGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceSalinityGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceSalinityGradx', r3Ptr)

! Define variable iceSalinityGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceSalinityGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceSalinityGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceSalinityGrady', r3Ptr)

! Define variable snowEnthalpyCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowEnthalpyCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowEnthalpyCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowEnthalpyCenter', r3Ptr)

! Define variable snowEnthalpyGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowEnthalpyGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowEnthalpyGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowEnthalpyGradx', r3Ptr)

! Define variable snowEnthalpyGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowEnthalpyGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowEnthalpyGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowEnthalpyGrady', r3Ptr)

! Define variable snowIceMassCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowIceMassCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowIceMassCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowIceMassCenter', r3Ptr)

! Define variable snowIceMassGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowIceMassGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowIceMassGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowIceMassGradx', r3Ptr)

! Define variable snowIceMassGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowIceMassGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowIceMassGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowIceMassGrady', r3Ptr)

! Define variable snowLiquidMassCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowLiquidMassCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowLiquidMassCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowLiquidMassCenter', r3Ptr)

! Define variable snowLiquidMassGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowLiquidMassGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowLiquidMassGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowLiquidMassGradx', r3Ptr)

! Define variable snowLiquidMassGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowLiquidMassGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowLiquidMassGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowLiquidMassGrady', r3Ptr)

! Define variable snowGrainRadiusCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowGrainRadiusCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerSnowGrainRadiusActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowGrainRadiusCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowGrainRadiusCenter', r3Ptr)

! Define variable snowGrainRadiusGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowGrainRadiusGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerSnowGrainRadiusActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowGrainRadiusGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowGrainRadiusGradx', r3Ptr)

! Define variable snowGrainRadiusGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowGrainRadiusGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerSnowGrainRadiusActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowGrainRadiusGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowGrainRadiusGrady', r3Ptr)

! Define variable snowDensityCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowDensityCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowDensityCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowDensityCenter', r3Ptr)

! Define variable snowDensityGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowDensityGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowDensityGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowDensityGradx', r3Ptr)

! Define variable snowDensityGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowDensityGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowDensityGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowDensityGrady', r3Ptr)

! Define variable iceAgeCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceAgeCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerIceAgeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceAgeCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAgeCenter', r3Ptr)

! Define variable iceAgeGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceAgeGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerIceAgeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceAgeGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAgeGradx', r3Ptr)

! Define variable iceAgeGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceAgeGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerIceAgeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceAgeGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAgeGrady', r3Ptr)

! Define variable firstYearIceAreaCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'firstYearIceAreaCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerFirstYearIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'firstYearIceAreaCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'firstYearIceAreaCenter', r3Ptr)

! Define variable firstYearIceAreaGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'firstYearIceAreaGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerFirstYearIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'firstYearIceAreaGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'firstYearIceAreaGradx', r3Ptr)

! Define variable firstYearIceAreaGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'firstYearIceAreaGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerFirstYearIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'firstYearIceAreaGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'firstYearIceAreaGrady', r3Ptr)

! Define variable levelIceAreaCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'levelIceAreaCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLevelIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceAreaCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'levelIceAreaCenter', r3Ptr)

! Define variable levelIceAreaGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'levelIceAreaGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLevelIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceAreaGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'levelIceAreaGradx', r3Ptr)

! Define variable levelIceAreaGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'levelIceAreaGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLevelIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceAreaGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'levelIceAreaGrady', r3Ptr)

! Define variable levelIceVolumeCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'levelIceVolumeCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLevelIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceVolumeCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'levelIceVolumeCenter', r3Ptr)

! Define variable levelIceVolumeGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'levelIceVolumeGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLevelIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceVolumeGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'levelIceVolumeGradx', r3Ptr)

! Define variable levelIceVolumeGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'levelIceVolumeGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLevelIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceVolumeGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'levelIceVolumeGrady', r3Ptr)

! Define variable pondAreaCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondAreaCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerPondsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondAreaCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondAreaCenter', r3Ptr)

! Define variable pondAreaGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondAreaGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerPondsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondAreaGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondAreaGradx', r3Ptr)

! Define variable pondAreaGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondAreaGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerPondsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondAreaGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondAreaGrady', r3Ptr)

! Define variable pondDepthCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondDepthCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerPondsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondDepthCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondDepthCenter', r3Ptr)

! Define variable pondDepthGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondDepthGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerPondsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondDepthGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondDepthGradx', r3Ptr)

! Define variable pondDepthGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondDepthGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerPondsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondDepthGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondDepthGrady', r3Ptr)

! Define variable pondLidThicknessCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondLidThicknessCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLidThicknessActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondLidThicknessCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondLidThicknessCenter', r3Ptr)

! Define variable pondLidThicknessGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondLidThicknessGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLidThicknessActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondLidThicknessGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondLidThicknessGradx', r3Ptr)

! Define variable pondLidThicknessGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondLidThicknessGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLidThicknessActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondLidThicknessGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondLidThicknessGrady', r3Ptr)

! Define variable snowScatteringAerosolCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowScatteringAerosolCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowScatteringAerosolCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowScatteringAerosolCenter', r3Ptr)

! Define variable snowScatteringAerosolGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowScatteringAerosolGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowScatteringAerosolGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowScatteringAerosolGradx', r3Ptr)

! Define variable snowScatteringAerosolGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowScatteringAerosolGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowScatteringAerosolGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowScatteringAerosolGrady', r3Ptr)

! Define variable snowBodyAerosolCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowBodyAerosolCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowBodyAerosolCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowBodyAerosolCenter', r3Ptr)

! Define variable snowBodyAerosolGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowBodyAerosolGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowBodyAerosolGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowBodyAerosolGradx', r3Ptr)

! Define variable snowBodyAerosolGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowBodyAerosolGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowBodyAerosolGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowBodyAerosolGrady', r3Ptr)

! Define variable iceScatteringAerosolCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceScatteringAerosolCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceScatteringAerosolCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceScatteringAerosolCenter', r3Ptr)

! Define variable iceScatteringAerosolGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceScatteringAerosolGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceScatteringAerosolGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceScatteringAerosolGradx', r3Ptr)

! Define variable iceScatteringAerosolGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceScatteringAerosolGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceScatteringAerosolGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceScatteringAerosolGrady', r3Ptr)

! Define variable iceBodyAerosolCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceBodyAerosolCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceBodyAerosolCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceBodyAerosolCenter', r3Ptr)

! Define variable iceBodyAerosolGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceBodyAerosolGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceBodyAerosolGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceBodyAerosolGradx', r3Ptr)

! Define variable iceBodyAerosolGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceBodyAerosolGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceBodyAerosolGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceBodyAerosolGrady', r3Ptr)

! Define variable brineFractionCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'brineFractionCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerBrineActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'brineFractionCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'brineFractionCenter', r3Ptr)

! Define variable brineFractionGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'brineFractionGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerBrineActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'brineFractionGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'brineFractionGradx', r3Ptr)

! Define variable brineFractionGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'brineFractionGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerBrineActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'brineFractionGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'brineFractionGrady', r3Ptr)

! Define variable mobileFractionCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'mobileFractionCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nZBGCTracers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerMobileFractionActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'mobileFractionCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'mobileFractionCenter', r3Ptr)

! Define variable mobileFractionGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'mobileFractionGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nZBGCTracers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerMobileFractionActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'mobileFractionGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'mobileFractionGradx', r3Ptr)

! Define variable mobileFractionGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'mobileFractionGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nZBGCTracers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerMobileFractionActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'mobileFractionGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'mobileFractionGrady', r3Ptr)

! Define variable skeletalAlgaeConcCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalAlgaeConcCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgae'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAlgaeConcCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalAlgaeConcCenter', r3Ptr)

! Define variable skeletalAlgaeConcGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalAlgaeConcGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgae'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAlgaeConcGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalAlgaeConcGradx', r3Ptr)

! Define variable skeletalAlgaeConcGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalAlgaeConcGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgae'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAlgaeConcGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalAlgaeConcGrady', r3Ptr)

! Define variable skeletalDOCConcCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDOCConcCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOC'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDOCConcCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDOCConcCenter', r3Ptr)

! Define variable skeletalDOCConcGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDOCConcGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOC'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDOCConcGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDOCConcGradx', r3Ptr)

! Define variable skeletalDOCConcGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDOCConcGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOC'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDOCConcGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDOCConcGrady', r3Ptr)

! Define variable skeletalDICConcCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDICConcCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDIC'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDICConcCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDICConcCenter', r3Ptr)

! Define variable skeletalDICConcGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDICConcGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDIC'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDICConcGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDICConcGradx', r3Ptr)

! Define variable skeletalDICConcGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDICConcGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDIC'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDICConcGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDICConcGrady', r3Ptr)

! Define variable skeletalDONConcCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDONConcCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDON'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDONConcCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDONConcCenter', r3Ptr)

! Define variable skeletalDONConcGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDONConcGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDON'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDONConcGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDONConcGradx', r3Ptr)

! Define variable skeletalDONConcGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDONConcGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDON'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDONConcGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDONConcGrady', r3Ptr)

! Define variable skeletalNitrateConcCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalNitrateConcCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNitrateConcCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalNitrateConcCenter', r3Ptr)

! Define variable skeletalNitrateConcGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalNitrateConcGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNitrateConcGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalNitrateConcGradx', r3Ptr)

! Define variable skeletalNitrateConcGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalNitrateConcGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNitrateConcGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalNitrateConcGrady', r3Ptr)

! Define variable skeletalSilicateConcCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalSilicateConcCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalSilicateConcCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalSilicateConcCenter', r3Ptr)

! Define variable skeletalSilicateConcGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalSilicateConcGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalSilicateConcGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalSilicateConcGradx', r3Ptr)

! Define variable skeletalSilicateConcGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalSilicateConcGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalSilicateConcGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalSilicateConcGrady', r3Ptr)

! Define variable skeletalAmmoniumConcCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalAmmoniumConcCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAmmoniumConcCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalAmmoniumConcCenter', r3Ptr)

! Define variable skeletalAmmoniumConcGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalAmmoniumConcGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAmmoniumConcGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalAmmoniumConcGradx', r3Ptr)

! Define variable skeletalAmmoniumConcGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalAmmoniumConcGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAmmoniumConcGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalAmmoniumConcGrady', r3Ptr)

! Define variable skeletalDMSConcCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSConcCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSConcCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSConcCenter', r3Ptr)

! Define variable skeletalDMSConcGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSConcGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSConcGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSConcGradx', r3Ptr)

! Define variable skeletalDMSConcGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSConcGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSConcGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSConcGrady', r3Ptr)

! Define variable skeletalDMSPpConcCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSPpConcCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPpConcCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPpConcCenter', r3Ptr)

! Define variable skeletalDMSPpConcGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSPpConcGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPpConcGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPpConcGradx', r3Ptr)

! Define variable skeletalDMSPpConcGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSPpConcGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPpConcGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPpConcGrady', r3Ptr)

! Define variable skeletalDMSPdConcCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSPdConcCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPdConcCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPdConcCenter', r3Ptr)

! Define variable skeletalDMSPdConcGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSPdConcGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPdConcGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPdConcGradx', r3Ptr)

! Define variable skeletalDMSPdConcGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSPdConcGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPdConcGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPdConcGrady', r3Ptr)

! Define variable skeletalNonreactiveConcCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalNonreactiveConcCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNonreactiveConcCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalNonreactiveConcCenter', r3Ptr)

! Define variable skeletalNonreactiveConcGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalNonreactiveConcGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNonreactiveConcGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalNonreactiveConcGradx', r3Ptr)

! Define variable skeletalNonreactiveConcGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalNonreactiveConcGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNonreactiveConcGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalNonreactiveConcGrady', r3Ptr)

! Define variable skeletalHumicsConcCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalHumicsConcCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalHumicsConcCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalHumicsConcCenter', r3Ptr)

! Define variable skeletalHumicsConcGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalHumicsConcGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalHumicsConcGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalHumicsConcGradx', r3Ptr)

! Define variable skeletalHumicsConcGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalHumicsConcGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalHumicsConcGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalHumicsConcGrady', r3Ptr)

! Define variable skeletalParticulateIronConcCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalParticulateIronConcCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nParticulateIron'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalParticulateIronConcCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalParticulateIronConcCenter', r3Ptr)

! Define variable skeletalParticulateIronConcGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalParticulateIronConcGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nParticulateIron'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalParticulateIronConcGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalParticulateIronConcGradx', r3Ptr)

! Define variable skeletalParticulateIronConcGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalParticulateIronConcGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nParticulateIron'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalParticulateIronConcGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalParticulateIronConcGrady', r3Ptr)

! Define variable skeletalDissolvedIronConcCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDissolvedIronConcCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDissolvedIron'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDissolvedIronConcCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDissolvedIronConcCenter', r3Ptr)

! Define variable skeletalDissolvedIronConcGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDissolvedIronConcGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDissolvedIron'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDissolvedIronConcGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDissolvedIronConcGradx', r3Ptr)

! Define variable skeletalDissolvedIronConcGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDissolvedIronConcGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDissolvedIron'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDissolvedIronConcGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDissolvedIronConcGrady', r3Ptr)

! Define variable verticalAlgaeSnowCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAlgaeSnowCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgaeSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeSnowCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeSnowCenter', r3Ptr)

! Define variable verticalAlgaeSnowGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAlgaeSnowGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgaeSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeSnowGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeSnowGradx', r3Ptr)

! Define variable verticalAlgaeSnowGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAlgaeSnowGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgaeSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeSnowGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeSnowGrady', r3Ptr)

! Define variable verticalDOCSnowCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDOCSnowCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOCSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCSnowCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCSnowCenter', r3Ptr)

! Define variable verticalDOCSnowGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDOCSnowGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOCSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCSnowGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCSnowGradx', r3Ptr)

! Define variable verticalDOCSnowGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDOCSnowGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOCSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCSnowGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCSnowGrady', r3Ptr)

! Define variable verticalDICSnowCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDICSnowCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDICSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICSnowCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDICSnowCenter', r3Ptr)

! Define variable verticalDICSnowGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDICSnowGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDICSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICSnowGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDICSnowGradx', r3Ptr)

! Define variable verticalDICSnowGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDICSnowGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDICSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICSnowGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDICSnowGrady', r3Ptr)

! Define variable verticalDONSnowCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDONSnowCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDONSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONSnowCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDONSnowCenter', r3Ptr)

! Define variable verticalDONSnowGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDONSnowGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDONSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONSnowGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDONSnowGradx', r3Ptr)

! Define variable verticalDONSnowGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDONSnowGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDONSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONSnowGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDONSnowGrady', r3Ptr)

! Define variable verticalNitrateSnowCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNitrateSnowCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateSnowCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateSnowCenter', r3Ptr)

! Define variable verticalNitrateSnowGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNitrateSnowGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateSnowGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateSnowGradx', r3Ptr)

! Define variable verticalNitrateSnowGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNitrateSnowGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateSnowGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateSnowGrady', r3Ptr)

! Define variable verticalSilicateSnowCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSilicateSnowCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateSnowCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateSnowCenter', r3Ptr)

! Define variable verticalSilicateSnowGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSilicateSnowGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateSnowGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateSnowGradx', r3Ptr)

! Define variable verticalSilicateSnowGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSilicateSnowGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateSnowGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateSnowGrady', r3Ptr)

! Define variable verticalAmmoniumSnowCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAmmoniumSnowCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumSnowCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumSnowCenter', r3Ptr)

! Define variable verticalAmmoniumSnowGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAmmoniumSnowGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumSnowGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumSnowGradx', r3Ptr)

! Define variable verticalAmmoniumSnowGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAmmoniumSnowGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumSnowGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumSnowGrady', r3Ptr)

! Define variable verticalDMSSnowCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSSnowCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSSnowCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSSnowCenter', r3Ptr)

! Define variable verticalDMSSnowGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSSnowGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSSnowGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSSnowGradx', r3Ptr)

! Define variable verticalDMSSnowGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSSnowGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSSnowGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSSnowGrady', r3Ptr)

! Define variable verticalDMSPpSnowCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPpSnowCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpSnowCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpSnowCenter', r3Ptr)

! Define variable verticalDMSPpSnowGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPpSnowGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpSnowGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpSnowGradx', r3Ptr)

! Define variable verticalDMSPpSnowGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPpSnowGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpSnowGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpSnowGrady', r3Ptr)

! Define variable verticalDMSPdSnowCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPdSnowCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdSnowCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdSnowCenter', r3Ptr)

! Define variable verticalDMSPdSnowGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPdSnowGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdSnowGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdSnowGradx', r3Ptr)

! Define variable verticalDMSPdSnowGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPdSnowGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdSnowGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdSnowGrady', r3Ptr)

! Define variable verticalNonreactiveSnowCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNonreactiveSnowCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveSnowCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveSnowCenter', r3Ptr)

! Define variable verticalNonreactiveSnowGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNonreactiveSnowGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveSnowGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveSnowGradx', r3Ptr)

! Define variable verticalNonreactiveSnowGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNonreactiveSnowGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveSnowGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveSnowGrady', r3Ptr)

! Define variable verticalHumicsSnowCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalHumicsSnowCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsSnowCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsSnowCenter', r3Ptr)

! Define variable verticalHumicsSnowGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalHumicsSnowGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsSnowGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsSnowGradx', r3Ptr)

! Define variable verticalHumicsSnowGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalHumicsSnowGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsSnowGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsSnowGrady', r3Ptr)

! Define variable verticalParticulateIronSnowCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalParticulateIronSnowCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nPartIronSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronSnowCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronSnowCenter', r3Ptr)

! Define variable verticalParticulateIronSnowGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalParticulateIronSnowGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nPartIronSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronSnowGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronSnowGradx', r3Ptr)

! Define variable verticalParticulateIronSnowGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalParticulateIronSnowGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nPartIronSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronSnowGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronSnowGrady', r3Ptr)

! Define variable verticalDissolvedIronSnowCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDissolvedIronSnowCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDisIronSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronSnowCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronSnowCenter', r3Ptr)

! Define variable verticalDissolvedIronSnowGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDissolvedIronSnowGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDisIronSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronSnowGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronSnowGradx', r3Ptr)

! Define variable verticalDissolvedIronSnowGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDissolvedIronSnowGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDisIronSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronSnowGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronSnowGrady', r3Ptr)

! Define variable verticalAlgaeIceCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAlgaeIceCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgaeIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeIceCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeIceCenter', r3Ptr)

! Define variable verticalAlgaeIceGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAlgaeIceGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgaeIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeIceGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeIceGradx', r3Ptr)

! Define variable verticalAlgaeIceGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAlgaeIceGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgaeIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeIceGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeIceGrady', r3Ptr)

! Define variable verticalDOCIceCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDOCIceCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOCIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCIceCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCIceCenter', r3Ptr)

! Define variable verticalDOCIceGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDOCIceGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOCIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCIceGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCIceGradx', r3Ptr)

! Define variable verticalDOCIceGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDOCIceGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOCIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCIceGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCIceGrady', r3Ptr)

! Define variable verticalDICIceCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDICIceCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDICIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICIceCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDICIceCenter', r3Ptr)

! Define variable verticalDICIceGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDICIceGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDICIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICIceGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDICIceGradx', r3Ptr)

! Define variable verticalDICIceGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDICIceGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDICIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICIceGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDICIceGrady', r3Ptr)

! Define variable verticalDONIceCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDONIceCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDONIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONIceCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDONIceCenter', r3Ptr)

! Define variable verticalDONIceGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDONIceGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDONIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONIceGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDONIceGradx', r3Ptr)

! Define variable verticalDONIceGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDONIceGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDONIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONIceGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDONIceGrady', r3Ptr)

! Define variable verticalNitrateIceCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNitrateIceCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateIceCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateIceCenter', r3Ptr)

! Define variable verticalNitrateIceGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNitrateIceGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateIceGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateIceGradx', r3Ptr)

! Define variable verticalNitrateIceGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNitrateIceGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateIceGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateIceGrady', r3Ptr)

! Define variable verticalSilicateIceCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSilicateIceCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateIceCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateIceCenter', r3Ptr)

! Define variable verticalSilicateIceGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSilicateIceGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateIceGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateIceGradx', r3Ptr)

! Define variable verticalSilicateIceGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSilicateIceGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateIceGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateIceGrady', r3Ptr)

! Define variable verticalAmmoniumIceCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAmmoniumIceCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumIceCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumIceCenter', r3Ptr)

! Define variable verticalAmmoniumIceGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAmmoniumIceGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumIceGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumIceGradx', r3Ptr)

! Define variable verticalAmmoniumIceGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAmmoniumIceGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumIceGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumIceGrady', r3Ptr)

! Define variable verticalDMSIceCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSIceCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSIceCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSIceCenter', r3Ptr)

! Define variable verticalDMSIceGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSIceGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSIceGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSIceGradx', r3Ptr)

! Define variable verticalDMSIceGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSIceGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSIceGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSIceGrady', r3Ptr)

! Define variable verticalDMSPpIceCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPpIceCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpIceCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpIceCenter', r3Ptr)

! Define variable verticalDMSPpIceGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPpIceGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpIceGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpIceGradx', r3Ptr)

! Define variable verticalDMSPpIceGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPpIceGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpIceGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpIceGrady', r3Ptr)

! Define variable verticalDMSPdIceCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPdIceCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdIceCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdIceCenter', r3Ptr)

! Define variable verticalDMSPdIceGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPdIceGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdIceGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdIceGradx', r3Ptr)

! Define variable verticalDMSPdIceGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPdIceGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdIceGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdIceGrady', r3Ptr)

! Define variable verticalNonreactiveIceCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNonreactiveIceCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveIceCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveIceCenter', r3Ptr)

! Define variable verticalNonreactiveIceGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNonreactiveIceGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveIceGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveIceGradx', r3Ptr)

! Define variable verticalNonreactiveIceGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNonreactiveIceGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveIceGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveIceGrady', r3Ptr)

! Define variable verticalHumicsIceCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalHumicsIceCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsIceCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsIceCenter', r3Ptr)

! Define variable verticalHumicsIceGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalHumicsIceGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsIceGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsIceGradx', r3Ptr)

! Define variable verticalHumicsIceGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalHumicsIceGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsIceGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsIceGrady', r3Ptr)

! Define variable verticalParticulateIronIceCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalParticulateIronIceCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nPartIronIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronIceCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronIceCenter', r3Ptr)

! Define variable verticalParticulateIronIceGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalParticulateIronIceGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nPartIronIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronIceGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronIceGradx', r3Ptr)

! Define variable verticalParticulateIronIceGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalParticulateIronIceGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nPartIronIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronIceGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronIceGrady', r3Ptr)

! Define variable verticalDissolvedIronIceCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDissolvedIronIceCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDisIronIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronIceCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronIceCenter', r3Ptr)

! Define variable verticalDissolvedIronIceGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDissolvedIronIceGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDisIronIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronIceGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronIceGradx', r3Ptr)

! Define variable verticalDissolvedIronIceGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDissolvedIronIceGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDisIronIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronIceGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronIceGrady', r3Ptr)

! Define variable verticalAerosolsSnowCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAerosolsSnowCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nzAerosolsSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsSnowCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsSnowCenter', r3Ptr)

! Define variable verticalAerosolsSnowGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAerosolsSnowGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nzAerosolsSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsSnowGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsSnowGradx', r3Ptr)

! Define variable verticalAerosolsSnowGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAerosolsSnowGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nzAerosolsSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsSnowGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsSnowGrady', r3Ptr)

! Define variable verticalAerosolsIceCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAerosolsIceCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nzAerosolsIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsIceCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsIceCenter', r3Ptr)

! Define variable verticalAerosolsIceGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAerosolsIceGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nzAerosolsIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsIceGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsIceGradx', r3Ptr)

! Define variable verticalAerosolsIceGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAerosolsIceGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nzAerosolsIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsIceGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsIceGrady', r3Ptr)

! Define variable verticalSalinityCenter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSalinityCenter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZSalinityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSalinityCenter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSalinityCenter', r3Ptr)

! Define variable verticalSalinityGradx
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSalinityGradx'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZSalinityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSalinityGradx', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSalinityGradx', r3Ptr)

! Define variable verticalSalinityGrady
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSalinityGrady'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZSalinityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSalinityGrady', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSalinityGrady', r3Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_tracer_reconstruction


   subroutine seaice_generate_pool_tracer_conservation(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'tracer_conservation', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'tracer_conservation', newSubPool)

! Define variable iceAreaCategoryCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'iceAreaCategoryCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'ONE'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'iceAreaCategoryCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'ONE'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      r2aPtr(1) % isActive = .true.
      r2aPtr(2) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceAreaCategoryCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'iceAreaCategoryCons', r2aPtr)

! Define variable iceVolumeCategoryCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'iceVolumeCategoryCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'ONE'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'iceVolumeCategoryCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'ONE'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      r2aPtr(1) % isActive = .true.
      r2aPtr(2) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceVolumeCategoryCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'iceVolumeCategoryCons', r2aPtr)

! Define variable snowVolumeCategoryCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'snowVolumeCategoryCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'ONE'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'snowVolumeCategoryCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'ONE'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      r2aPtr(1) % isActive = .true.
      r2aPtr(2) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowVolumeCategoryCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'snowVolumeCategoryCons', r2aPtr)

! Define variable surfaceTemperatureCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'surfaceTemperatureCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'ONE'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'surfaceTemperatureCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'ONE'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      r2aPtr(1) % isActive = .true.
      r2aPtr(2) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'surfaceTemperatureCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'surfaceTemperatureCons', r2aPtr)

! Define variable iceEnthalpyCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'iceEnthalpyCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nIceLayers'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'iceEnthalpyCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nIceLayers'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      r2aPtr(1) % isActive = .true.
      r2aPtr(2) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceEnthalpyCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'iceEnthalpyCons', r2aPtr)

! Define variable iceSalinityCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'iceSalinityCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nIceLayers'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'iceSalinityCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nIceLayers'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      r2aPtr(1) % isActive = .true.
      r2aPtr(2) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceSalinityCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'iceSalinityCons', r2aPtr)

! Define variable snowEnthalpyCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'snowEnthalpyCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nSnowLayers'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'snowEnthalpyCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nSnowLayers'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      r2aPtr(1) % isActive = .true.
      r2aPtr(2) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowEnthalpyCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'snowEnthalpyCons', r2aPtr)

! Define variable snowIceMassCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'snowIceMassCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nSnowLayers'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'snowIceMassCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nSnowLayers'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowIceMassCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'snowIceMassCons', r2aPtr)

! Define variable snowLiquidMassCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'snowLiquidMassCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nSnowLayers'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'snowLiquidMassCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nSnowLayers'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowLiquidMassCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'snowLiquidMassCons', r2aPtr)

! Define variable snowGrainRadiusCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'snowGrainRadiusCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nSnowLayers'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'snowGrainRadiusCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nSnowLayers'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgColumnTracerSnowGrainRadiusActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowGrainRadiusCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'snowGrainRadiusCons', r2aPtr)

! Define variable snowDensityCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'snowDensityCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nSnowLayers'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'snowDensityCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nSnowLayers'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowDensityCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'snowDensityCons', r2aPtr)

! Define variable iceAgeCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'iceAgeCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'ONE'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'iceAgeCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'ONE'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgColumnTracerIceAgeActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceAgeCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'iceAgeCons', r2aPtr)

! Define variable firstYearIceAreaCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'firstYearIceAreaCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'ONE'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'firstYearIceAreaCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'ONE'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgColumnTracerFirstYearIceActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'firstYearIceAreaCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'firstYearIceAreaCons', r2aPtr)

! Define variable levelIceAreaCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'levelIceAreaCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'ONE'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'levelIceAreaCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'ONE'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgColumnTracerLevelIceActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceAreaCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'levelIceAreaCons', r2aPtr)

! Define variable levelIceVolumeCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'levelIceVolumeCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'ONE'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'levelIceVolumeCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'ONE'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgColumnTracerLevelIceActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceVolumeCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'levelIceVolumeCons', r2aPtr)

! Define variable pondAreaCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'pondAreaCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'ONE'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'pondAreaCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'ONE'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgColumnTracerPondsActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondAreaCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'pondAreaCons', r2aPtr)

! Define variable pondDepthCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'pondDepthCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'ONE'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'pondDepthCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'ONE'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgColumnTracerPondsActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondDepthCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'pondDepthCons', r2aPtr)

! Define variable pondLidThicknessCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'pondLidThicknessCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'ONE'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'pondLidThicknessCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'ONE'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgColumnTracerLidThicknessActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondLidThicknessCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'pondLidThicknessCons', r2aPtr)

! Define variable snowScatteringAerosolCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'snowScatteringAerosolCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nAerosols'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'snowScatteringAerosolCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nAerosols'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgColumnTracerAerosolsActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowScatteringAerosolCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'snowScatteringAerosolCons', r2aPtr)

! Define variable snowBodyAerosolCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'snowBodyAerosolCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nAerosols'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'snowBodyAerosolCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nAerosols'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgColumnTracerAerosolsActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowBodyAerosolCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'snowBodyAerosolCons', r2aPtr)

! Define variable iceScatteringAerosolCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'iceScatteringAerosolCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nAerosols'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'iceScatteringAerosolCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nAerosols'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgColumnTracerAerosolsActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceScatteringAerosolCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'iceScatteringAerosolCons', r2aPtr)

! Define variable iceBodyAerosolCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'iceBodyAerosolCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nAerosols'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'iceBodyAerosolCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nAerosols'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgColumnTracerAerosolsActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceBodyAerosolCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'iceBodyAerosolCons', r2aPtr)

! Define variable brineFractionCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'brineFractionCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'ONE'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'brineFractionCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'ONE'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerBrineActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'brineFractionCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'brineFractionCons', r2aPtr)

! Define variable mobileFractionCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'mobileFractionCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nZBGCTracers'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'mobileFractionCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nZBGCTracers'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerMobileFractionActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'mobileFractionCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'mobileFractionCons', r2aPtr)

! Define variable skeletalAlgaeConcCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'skeletalAlgaeConcCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nAlgae'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'skeletalAlgaeConcCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nAlgae'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerSkeletalAlgaeActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAlgaeConcCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalAlgaeConcCons', r2aPtr)

! Define variable skeletalDOCConcCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'skeletalDOCConcCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nDOC'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'skeletalDOCConcCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nDOC'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerSkeletalCarbonActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDOCConcCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalDOCConcCons', r2aPtr)

! Define variable skeletalDICConcCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'skeletalDICConcCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nDIC'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'skeletalDICConcCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nDIC'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerSkeletalCarbonActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDICConcCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalDICConcCons', r2aPtr)

! Define variable skeletalDONConcCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'skeletalDONConcCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nDON'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'skeletalDONConcCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nDON'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerSkeletalDONActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDONConcCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalDONConcCons', r2aPtr)

! Define variable skeletalNitrateConcCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'skeletalNitrateConcCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'ONE'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'skeletalNitrateConcCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'ONE'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerSkeletalNitrateActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNitrateConcCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalNitrateConcCons', r2aPtr)

! Define variable skeletalSilicateConcCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'skeletalSilicateConcCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'ONE'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'skeletalSilicateConcCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'ONE'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerSkeletalSilicateActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalSilicateConcCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalSilicateConcCons', r2aPtr)

! Define variable skeletalAmmoniumConcCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'skeletalAmmoniumConcCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'ONE'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'skeletalAmmoniumConcCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'ONE'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerSkeletalAmmoniumActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAmmoniumConcCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalAmmoniumConcCons', r2aPtr)

! Define variable skeletalDMSConcCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'skeletalDMSConcCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'ONE'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'skeletalDMSConcCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'ONE'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerSkeletalDMSActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSConcCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSConcCons', r2aPtr)

! Define variable skeletalDMSPpConcCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'skeletalDMSPpConcCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'ONE'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'skeletalDMSPpConcCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'ONE'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerSkeletalDMSActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPpConcCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPpConcCons', r2aPtr)

! Define variable skeletalDMSPdConcCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'skeletalDMSPdConcCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'ONE'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'skeletalDMSPdConcCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'ONE'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerSkeletalDMSActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPdConcCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPdConcCons', r2aPtr)

! Define variable skeletalNonreactiveConcCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'skeletalNonreactiveConcCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'ONE'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'skeletalNonreactiveConcCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'ONE'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerSkeletalNonreactiveActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNonreactiveConcCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalNonreactiveConcCons', r2aPtr)

! Define variable skeletalHumicsConcCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'skeletalHumicsConcCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'ONE'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'skeletalHumicsConcCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'ONE'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerSkeletalHumicsActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalHumicsConcCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalHumicsConcCons', r2aPtr)

! Define variable skeletalParticulateIronConcCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'skeletalParticulateIronConcCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nParticulateIron'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'skeletalParticulateIronConcCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nParticulateIron'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerSkeletalIronActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalParticulateIronConcCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalParticulateIronConcCons', r2aPtr)

! Define variable skeletalDissolvedIronConcCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'skeletalDissolvedIronConcCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nDissolvedIron'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'skeletalDissolvedIronConcCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nDissolvedIron'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerSkeletalIronActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDissolvedIronConcCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'skeletalDissolvedIronConcCons', r2aPtr)

! Define variable verticalAlgaeSnowCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalAlgaeSnowCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nAlgaeSnowLayers'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalAlgaeSnowCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nAlgaeSnowLayers'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeSnowCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeSnowCons', r2aPtr)

! Define variable verticalDOCSnowCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalDOCSnowCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nDOCSnowLayers'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalDOCSnowCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nDOCSnowLayers'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalCarbonActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCSnowCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCSnowCons', r2aPtr)

! Define variable verticalDICSnowCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalDICSnowCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nDICSnowLayers'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalDICSnowCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nDICSnowLayers'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalCarbonActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICSnowCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDICSnowCons', r2aPtr)

! Define variable verticalDONSnowCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalDONSnowCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nDONSnowLayers'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalDONSnowCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nDONSnowLayers'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalDONActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONSnowCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDONSnowCons', r2aPtr)

! Define variable verticalNitrateSnowCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalNitrateSnowCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'TWO'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalNitrateSnowCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'TWO'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalNitrateActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateSnowCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateSnowCons', r2aPtr)

! Define variable verticalSilicateSnowCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalSilicateSnowCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'TWO'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalSilicateSnowCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'TWO'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalSilicateActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateSnowCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateSnowCons', r2aPtr)

! Define variable verticalAmmoniumSnowCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalAmmoniumSnowCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'TWO'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalAmmoniumSnowCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'TWO'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumSnowCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumSnowCons', r2aPtr)

! Define variable verticalDMSSnowCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalDMSSnowCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'TWO'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalDMSSnowCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'TWO'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalDMSActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSSnowCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSSnowCons', r2aPtr)

! Define variable verticalDMSPpSnowCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalDMSPpSnowCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'TWO'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalDMSPpSnowCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'TWO'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalDMSActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpSnowCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpSnowCons', r2aPtr)

! Define variable verticalDMSPdSnowCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalDMSPdSnowCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'TWO'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalDMSPdSnowCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'TWO'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalDMSActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdSnowCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdSnowCons', r2aPtr)

! Define variable verticalNonreactiveSnowCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalNonreactiveSnowCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'TWO'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalNonreactiveSnowCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'TWO'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveSnowCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveSnowCons', r2aPtr)

! Define variable verticalHumicsSnowCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalHumicsSnowCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'TWO'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalHumicsSnowCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'TWO'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalHumicsActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsSnowCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsSnowCons', r2aPtr)

! Define variable verticalParticulateIronSnowCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalParticulateIronSnowCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nPartIronSnowLayers'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalParticulateIronSnowCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nPartIronSnowLayers'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalIronActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronSnowCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronSnowCons', r2aPtr)

! Define variable verticalDissolvedIronSnowCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalDissolvedIronSnowCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nDisIronSnowLayers'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalDissolvedIronSnowCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nDisIronSnowLayers'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalIronActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronSnowCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronSnowCons', r2aPtr)

! Define variable verticalAlgaeIceCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalAlgaeIceCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nAlgaeIceLayers'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalAlgaeIceCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nAlgaeIceLayers'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeIceCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeIceCons', r2aPtr)

! Define variable verticalDOCIceCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalDOCIceCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nDOCIceLayers'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalDOCIceCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nDOCIceLayers'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalCarbonActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCIceCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCIceCons', r2aPtr)

! Define variable verticalDICIceCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalDICIceCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nDICIceLayers'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalDICIceCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nDICIceLayers'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalCarbonActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICIceCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDICIceCons', r2aPtr)

! Define variable verticalDONIceCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalDONIceCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nDONIceLayers'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalDONIceCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nDONIceLayers'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalDONActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONIceCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDONIceCons', r2aPtr)

! Define variable verticalNitrateIceCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalNitrateIceCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nBioLayersP1'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalNitrateIceCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nBioLayersP1'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalNitrateActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateIceCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateIceCons', r2aPtr)

! Define variable verticalSilicateIceCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalSilicateIceCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nBioLayersP1'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalSilicateIceCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nBioLayersP1'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalSilicateActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateIceCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateIceCons', r2aPtr)

! Define variable verticalAmmoniumIceCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalAmmoniumIceCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nBioLayersP1'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalAmmoniumIceCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nBioLayersP1'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumIceCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumIceCons', r2aPtr)

! Define variable verticalDMSIceCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalDMSIceCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nBioLayersP1'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalDMSIceCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nBioLayersP1'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalDMSActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSIceCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSIceCons', r2aPtr)

! Define variable verticalDMSPpIceCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalDMSPpIceCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nBioLayersP1'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalDMSPpIceCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nBioLayersP1'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalDMSActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpIceCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpIceCons', r2aPtr)

! Define variable verticalDMSPdIceCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalDMSPdIceCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nBioLayersP1'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalDMSPdIceCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nBioLayersP1'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalDMSActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdIceCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdIceCons', r2aPtr)

! Define variable verticalNonreactiveIceCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalNonreactiveIceCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nBioLayersP1'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalNonreactiveIceCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nBioLayersP1'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveIceCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveIceCons', r2aPtr)

! Define variable verticalHumicsIceCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalHumicsIceCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nBioLayersP1'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalHumicsIceCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nBioLayersP1'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalHumicsActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsIceCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsIceCons', r2aPtr)

! Define variable verticalParticulateIronIceCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalParticulateIronIceCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nPartIronIceLayers'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalParticulateIronIceCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nPartIronIceLayers'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalIronActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronIceCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronIceCons', r2aPtr)

! Define variable verticalDissolvedIronIceCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalDissolvedIronIceCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nDisIronIceLayers'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalDissolvedIronIceCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nDisIronIceLayers'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerVerticalIronActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronIceCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronIceCons', r2aPtr)

! Define variable verticalAerosolsSnowCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalAerosolsSnowCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nzAerosolsSnowLayers'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalAerosolsSnowCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nzAerosolsSnowLayers'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerZAerosolsActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsSnowCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsSnowCons', r2aPtr)

! Define variable verticalAerosolsIceCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalAerosolsIceCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nzAerosolsIceLayers'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalAerosolsIceCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nzAerosolsIceLayers'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerZAerosolsActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsIceCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsIceCons', r2aPtr)

! Define variable verticalSalinityCons
      allocate(r2aPtr(2))

! Setting up time level 1
      r2aPtr(1) % fieldName = 'verticalSalinityCons'
      r2aPtr(1) % isVarArray = .false.
      r2aPtr(1) % isDecomposed = .false.
      r2aPtr(1) % hasTimeDimension = .false.
      r2aPtr(1) % isPersistent = .true.
      r2aPtr(1) % isActive = .false.
! Setting up dimensions
      r2aPtr(1) % dimNames(1) = 'nBioLayers'
      r2aPtr(1) % dimNames(2) = 'nCategories'
      r2aPtr(1) % defaultValue = 0.0
      allocate(r2aPtr(1) % attLists(1))
      allocate(r2aPtr(1) % attLists(1) % attList)
      r2aPtr(1) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(1) % block => block

! Setting up time level 2
      r2aPtr(2) % fieldName = 'verticalSalinityCons'
      r2aPtr(2) % isVarArray = .false.
      r2aPtr(2) % isDecomposed = .false.
      r2aPtr(2) % hasTimeDimension = .false.
      r2aPtr(2) % isPersistent = .true.
      r2aPtr(2) % isActive = .false.
! Setting up dimensions
      r2aPtr(2) % dimNames(1) = 'nBioLayers'
      r2aPtr(2) % dimNames(2) = 'nCategories'
      r2aPtr(2) % defaultValue = 0.0
      allocate(r2aPtr(2) % attLists(1))
      allocate(r2aPtr(2) % attLists(1) % attList)
      r2aPtr(2) % missingValue = MPAS_REAL_FILLVAL
      r2aPtr(2) % block => block

      if (pkgTracerZSalinityActive) then
         r2aPtr(1) % isActive = .true.
         r2aPtr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSalinityCons', r2aPtr)
      call mpas_pool_add_field(block % allFields, 'verticalSalinityCons', r2aPtr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_tracer_conservation


   subroutine seaice_generate_pool_tracer_monotonicity(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'tracer_monotonicity', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'tracer_monotonicity', newSubPool)

! Define variable iceAreaCategoryLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceAreaCategoryLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceAreaCategoryLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAreaCategoryLocalMin', r3Ptr)

! Define variable iceAreaCategoryLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceAreaCategoryLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceAreaCategoryLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAreaCategoryLocalMax', r3Ptr)

! Define variable iceVolumeCategoryLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceVolumeCategoryLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceVolumeCategoryLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceVolumeCategoryLocalMin', r3Ptr)

! Define variable iceVolumeCategoryLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceVolumeCategoryLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceVolumeCategoryLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceVolumeCategoryLocalMax', r3Ptr)

! Define variable snowVolumeCategoryLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowVolumeCategoryLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowVolumeCategoryLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowVolumeCategoryLocalMin', r3Ptr)

! Define variable snowVolumeCategoryLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowVolumeCategoryLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowVolumeCategoryLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowVolumeCategoryLocalMax', r3Ptr)

! Define variable surfaceTemperatureLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'surfaceTemperatureLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'surfaceTemperatureLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceTemperatureLocalMin', r3Ptr)

! Define variable surfaceTemperatureLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'surfaceTemperatureLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'surfaceTemperatureLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceTemperatureLocalMax', r3Ptr)

! Define variable iceEnthalpyLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceEnthalpyLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceEnthalpyLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceEnthalpyLocalMin', r3Ptr)

! Define variable iceEnthalpyLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceEnthalpyLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceEnthalpyLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceEnthalpyLocalMax', r3Ptr)

! Define variable iceSalinityLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceSalinityLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceSalinityLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceSalinityLocalMin', r3Ptr)

! Define variable iceSalinityLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceSalinityLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceSalinityLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceSalinityLocalMax', r3Ptr)

! Define variable snowEnthalpyLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowEnthalpyLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowEnthalpyLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowEnthalpyLocalMin', r3Ptr)

! Define variable snowEnthalpyLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowEnthalpyLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowEnthalpyLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowEnthalpyLocalMax', r3Ptr)

! Define variable snowIceMassLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowIceMassLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowIceMassLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowIceMassLocalMin', r3Ptr)

! Define variable snowIceMassLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowIceMassLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowIceMassLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowIceMassLocalMax', r3Ptr)

! Define variable snowLiquidMassLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowLiquidMassLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowLiquidMassLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowLiquidMassLocalMin', r3Ptr)

! Define variable snowLiquidMassLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowLiquidMassLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowLiquidMassLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowLiquidMassLocalMax', r3Ptr)

! Define variable snowGrainRadiusLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowGrainRadiusLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerSnowGrainRadiusActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowGrainRadiusLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowGrainRadiusLocalMin', r3Ptr)

! Define variable snowGrainRadiusLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowGrainRadiusLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerSnowGrainRadiusActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowGrainRadiusLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowGrainRadiusLocalMax', r3Ptr)

! Define variable snowDensityLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowDensityLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowDensityLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowDensityLocalMin', r3Ptr)

! Define variable snowDensityLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowDensityLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerEffectiveSnowDensityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowDensityLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowDensityLocalMax', r3Ptr)

! Define variable iceAgeLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceAgeLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerIceAgeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceAgeLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAgeLocalMin', r3Ptr)

! Define variable iceAgeLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceAgeLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerIceAgeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceAgeLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAgeLocalMax', r3Ptr)

! Define variable firstYearIceAreaLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'firstYearIceAreaLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerFirstYearIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'firstYearIceAreaLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'firstYearIceAreaLocalMin', r3Ptr)

! Define variable firstYearIceAreaLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'firstYearIceAreaLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerFirstYearIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'firstYearIceAreaLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'firstYearIceAreaLocalMax', r3Ptr)

! Define variable levelIceAreaLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'levelIceAreaLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLevelIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceAreaLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'levelIceAreaLocalMin', r3Ptr)

! Define variable levelIceAreaLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'levelIceAreaLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLevelIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceAreaLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'levelIceAreaLocalMax', r3Ptr)

! Define variable levelIceVolumeLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'levelIceVolumeLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLevelIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceVolumeLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'levelIceVolumeLocalMin', r3Ptr)

! Define variable levelIceVolumeLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'levelIceVolumeLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLevelIceActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceVolumeLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'levelIceVolumeLocalMax', r3Ptr)

! Define variable pondAreaLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondAreaLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerPondsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondAreaLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondAreaLocalMin', r3Ptr)

! Define variable pondAreaLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondAreaLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerPondsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondAreaLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondAreaLocalMax', r3Ptr)

! Define variable pondDepthLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondDepthLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerPondsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondDepthLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondDepthLocalMin', r3Ptr)

! Define variable pondDepthLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondDepthLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerPondsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondDepthLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondDepthLocalMax', r3Ptr)

! Define variable pondLidThicknessLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondLidThicknessLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLidThicknessActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondLidThicknessLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondLidThicknessLocalMin', r3Ptr)

! Define variable pondLidThicknessLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'pondLidThicknessLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerLidThicknessActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondLidThicknessLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'pondLidThicknessLocalMax', r3Ptr)

! Define variable snowScatteringAerosolLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowScatteringAerosolLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowScatteringAerosolLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowScatteringAerosolLocalMin', r3Ptr)

! Define variable snowScatteringAerosolLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowScatteringAerosolLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowScatteringAerosolLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowScatteringAerosolLocalMax', r3Ptr)

! Define variable snowBodyAerosolLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowBodyAerosolLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowBodyAerosolLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowBodyAerosolLocalMin', r3Ptr)

! Define variable snowBodyAerosolLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowBodyAerosolLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowBodyAerosolLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowBodyAerosolLocalMax', r3Ptr)

! Define variable iceScatteringAerosolLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceScatteringAerosolLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceScatteringAerosolLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceScatteringAerosolLocalMin', r3Ptr)

! Define variable iceScatteringAerosolLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceScatteringAerosolLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceScatteringAerosolLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceScatteringAerosolLocalMax', r3Ptr)

! Define variable iceBodyAerosolLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceBodyAerosolLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceBodyAerosolLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceBodyAerosolLocalMin', r3Ptr)

! Define variable iceBodyAerosolLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceBodyAerosolLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAerosols'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnTracerAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceBodyAerosolLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceBodyAerosolLocalMax', r3Ptr)

! Define variable brineFractionLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'brineFractionLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerBrineActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'brineFractionLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'brineFractionLocalMin', r3Ptr)

! Define variable brineFractionLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'brineFractionLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerBrineActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'brineFractionLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'brineFractionLocalMax', r3Ptr)

! Define variable mobileFractionLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'mobileFractionLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nZBGCTracers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerMobileFractionActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'mobileFractionLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'mobileFractionLocalMin', r3Ptr)

! Define variable mobileFractionLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'mobileFractionLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nZBGCTracers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerMobileFractionActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'mobileFractionLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'mobileFractionLocalMax', r3Ptr)

! Define variable skeletalAlgaeConcLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalAlgaeConcLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgae'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAlgaeConcLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalAlgaeConcLocalMin', r3Ptr)

! Define variable skeletalAlgaeConcLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalAlgaeConcLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgae'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAlgaeConcLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalAlgaeConcLocalMax', r3Ptr)

! Define variable skeletalDOCConcLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDOCConcLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOC'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDOCConcLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDOCConcLocalMin', r3Ptr)

! Define variable skeletalDOCConcLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDOCConcLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOC'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDOCConcLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDOCConcLocalMax', r3Ptr)

! Define variable skeletalDICConcLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDICConcLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDIC'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDICConcLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDICConcLocalMin', r3Ptr)

! Define variable skeletalDICConcLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDICConcLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDIC'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDICConcLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDICConcLocalMax', r3Ptr)

! Define variable skeletalDONConcLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDONConcLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDON'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDONConcLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDONConcLocalMin', r3Ptr)

! Define variable skeletalDONConcLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDONConcLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDON'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDONConcLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDONConcLocalMax', r3Ptr)

! Define variable skeletalNitrateConcLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalNitrateConcLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNitrateConcLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalNitrateConcLocalMin', r3Ptr)

! Define variable skeletalNitrateConcLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalNitrateConcLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNitrateConcLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalNitrateConcLocalMax', r3Ptr)

! Define variable skeletalSilicateConcLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalSilicateConcLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalSilicateConcLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalSilicateConcLocalMin', r3Ptr)

! Define variable skeletalSilicateConcLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalSilicateConcLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalSilicateConcLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalSilicateConcLocalMax', r3Ptr)

! Define variable skeletalAmmoniumConcLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalAmmoniumConcLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAmmoniumConcLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalAmmoniumConcLocalMin', r3Ptr)

! Define variable skeletalAmmoniumConcLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalAmmoniumConcLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalAmmoniumConcLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalAmmoniumConcLocalMax', r3Ptr)

! Define variable skeletalDMSConcLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSConcLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSConcLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSConcLocalMin', r3Ptr)

! Define variable skeletalDMSConcLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSConcLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSConcLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSConcLocalMax', r3Ptr)

! Define variable skeletalDMSPpConcLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSPpConcLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPpConcLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPpConcLocalMin', r3Ptr)

! Define variable skeletalDMSPpConcLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSPpConcLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPpConcLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPpConcLocalMax', r3Ptr)

! Define variable skeletalDMSPdConcLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSPdConcLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPdConcLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPdConcLocalMin', r3Ptr)

! Define variable skeletalDMSPdConcLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDMSPdConcLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDMSPdConcLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDMSPdConcLocalMax', r3Ptr)

! Define variable skeletalNonreactiveConcLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalNonreactiveConcLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNonreactiveConcLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalNonreactiveConcLocalMin', r3Ptr)

! Define variable skeletalNonreactiveConcLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalNonreactiveConcLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalNonreactiveConcLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalNonreactiveConcLocalMax', r3Ptr)

! Define variable skeletalHumicsConcLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalHumicsConcLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalHumicsConcLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalHumicsConcLocalMin', r3Ptr)

! Define variable skeletalHumicsConcLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalHumicsConcLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'ONE'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalHumicsConcLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalHumicsConcLocalMax', r3Ptr)

! Define variable skeletalParticulateIronConcLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalParticulateIronConcLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nParticulateIron'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalParticulateIronConcLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalParticulateIronConcLocalMin', r3Ptr)

! Define variable skeletalParticulateIronConcLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalParticulateIronConcLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nParticulateIron'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalParticulateIronConcLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalParticulateIronConcLocalMax', r3Ptr)

! Define variable skeletalDissolvedIronConcLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDissolvedIronConcLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDissolvedIron'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDissolvedIronConcLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDissolvedIronConcLocalMin', r3Ptr)

! Define variable skeletalDissolvedIronConcLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'skeletalDissolvedIronConcLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDissolvedIron'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerSkeletalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'skeletalDissolvedIronConcLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'skeletalDissolvedIronConcLocalMax', r3Ptr)

! Define variable verticalAlgaeSnowLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAlgaeSnowLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgaeSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeSnowLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeSnowLocalMin', r3Ptr)

! Define variable verticalAlgaeSnowLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAlgaeSnowLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgaeSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeSnowLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeSnowLocalMax', r3Ptr)

! Define variable verticalDOCSnowLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDOCSnowLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOCSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCSnowLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCSnowLocalMin', r3Ptr)

! Define variable verticalDOCSnowLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDOCSnowLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOCSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCSnowLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCSnowLocalMax', r3Ptr)

! Define variable verticalDICSnowLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDICSnowLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDICSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICSnowLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDICSnowLocalMin', r3Ptr)

! Define variable verticalDICSnowLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDICSnowLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDICSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICSnowLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDICSnowLocalMax', r3Ptr)

! Define variable verticalDONSnowLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDONSnowLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDONSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONSnowLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDONSnowLocalMin', r3Ptr)

! Define variable verticalDONSnowLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDONSnowLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDONSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONSnowLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDONSnowLocalMax', r3Ptr)

! Define variable verticalNitrateSnowLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNitrateSnowLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateSnowLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateSnowLocalMin', r3Ptr)

! Define variable verticalNitrateSnowLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNitrateSnowLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateSnowLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateSnowLocalMax', r3Ptr)

! Define variable verticalSilicateSnowLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSilicateSnowLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateSnowLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateSnowLocalMin', r3Ptr)

! Define variable verticalSilicateSnowLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSilicateSnowLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateSnowLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateSnowLocalMax', r3Ptr)

! Define variable verticalAmmoniumSnowLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAmmoniumSnowLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumSnowLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumSnowLocalMin', r3Ptr)

! Define variable verticalAmmoniumSnowLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAmmoniumSnowLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumSnowLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumSnowLocalMax', r3Ptr)

! Define variable verticalDMSSnowLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSSnowLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSSnowLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSSnowLocalMin', r3Ptr)

! Define variable verticalDMSSnowLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSSnowLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSSnowLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSSnowLocalMax', r3Ptr)

! Define variable verticalDMSPpSnowLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPpSnowLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpSnowLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpSnowLocalMin', r3Ptr)

! Define variable verticalDMSPpSnowLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPpSnowLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpSnowLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpSnowLocalMax', r3Ptr)

! Define variable verticalDMSPdSnowLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPdSnowLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdSnowLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdSnowLocalMin', r3Ptr)

! Define variable verticalDMSPdSnowLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPdSnowLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdSnowLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdSnowLocalMax', r3Ptr)

! Define variable verticalNonreactiveSnowLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNonreactiveSnowLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveSnowLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveSnowLocalMin', r3Ptr)

! Define variable verticalNonreactiveSnowLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNonreactiveSnowLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveSnowLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveSnowLocalMax', r3Ptr)

! Define variable verticalHumicsSnowLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalHumicsSnowLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsSnowLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsSnowLocalMin', r3Ptr)

! Define variable verticalHumicsSnowLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalHumicsSnowLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsSnowLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsSnowLocalMax', r3Ptr)

! Define variable verticalParticulateIronSnowLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalParticulateIronSnowLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nPartIronSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronSnowLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronSnowLocalMin', r3Ptr)

! Define variable verticalParticulateIronSnowLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalParticulateIronSnowLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nPartIronSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronSnowLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronSnowLocalMax', r3Ptr)

! Define variable verticalDissolvedIronSnowLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDissolvedIronSnowLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDisIronSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronSnowLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronSnowLocalMin', r3Ptr)

! Define variable verticalDissolvedIronSnowLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDissolvedIronSnowLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDisIronSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronSnowLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronSnowLocalMax', r3Ptr)

! Define variable verticalAlgaeIceLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAlgaeIceLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgaeIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeIceLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeIceLocalMin', r3Ptr)

! Define variable verticalAlgaeIceLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAlgaeIceLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nAlgaeIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAlgaeIceLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAlgaeIceLocalMax', r3Ptr)

! Define variable verticalDOCIceLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDOCIceLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOCIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCIceLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCIceLocalMin', r3Ptr)

! Define variable verticalDOCIceLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDOCIceLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDOCIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDOCIceLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDOCIceLocalMax', r3Ptr)

! Define variable verticalDICIceLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDICIceLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDICIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICIceLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDICIceLocalMin', r3Ptr)

! Define variable verticalDICIceLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDICIceLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDICIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalCarbonActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDICIceLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDICIceLocalMax', r3Ptr)

! Define variable verticalDONIceLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDONIceLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDONIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONIceLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDONIceLocalMin', r3Ptr)

! Define variable verticalDONIceLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDONIceLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDONIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDONActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDONIceLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDONIceLocalMax', r3Ptr)

! Define variable verticalNitrateIceLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNitrateIceLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateIceLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateIceLocalMin', r3Ptr)

! Define variable verticalNitrateIceLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNitrateIceLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNitrateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrateIceLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrateIceLocalMax', r3Ptr)

! Define variable verticalSilicateIceLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSilicateIceLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateIceLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateIceLocalMin', r3Ptr)

! Define variable verticalSilicateIceLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSilicateIceLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalSilicateActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSilicateIceLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSilicateIceLocalMax', r3Ptr)

! Define variable verticalAmmoniumIceLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAmmoniumIceLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumIceLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumIceLocalMin', r3Ptr)

! Define variable verticalAmmoniumIceLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAmmoniumIceLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalAmmoniumActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAmmoniumIceLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAmmoniumIceLocalMax', r3Ptr)

! Define variable verticalDMSIceLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSIceLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSIceLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSIceLocalMin', r3Ptr)

! Define variable verticalDMSIceLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSIceLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSIceLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSIceLocalMax', r3Ptr)

! Define variable verticalDMSPpIceLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPpIceLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpIceLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpIceLocalMin', r3Ptr)

! Define variable verticalDMSPpIceLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPpIceLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPpIceLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPpIceLocalMax', r3Ptr)

! Define variable verticalDMSPdIceLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPdIceLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdIceLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdIceLocalMin', r3Ptr)

! Define variable verticalDMSPdIceLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDMSPdIceLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalDMSActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDMSPdIceLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDMSPdIceLocalMax', r3Ptr)

! Define variable verticalNonreactiveIceLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNonreactiveIceLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveIceLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveIceLocalMin', r3Ptr)

! Define variable verticalNonreactiveIceLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNonreactiveIceLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalNonreactiveActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNonreactiveIceLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNonreactiveIceLocalMax', r3Ptr)

! Define variable verticalHumicsIceLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalHumicsIceLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsIceLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsIceLocalMin', r3Ptr)

! Define variable verticalHumicsIceLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalHumicsIceLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalHumicsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalHumicsIceLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalHumicsIceLocalMax', r3Ptr)

! Define variable verticalParticulateIronIceLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalParticulateIronIceLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nPartIronIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronIceLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronIceLocalMin', r3Ptr)

! Define variable verticalParticulateIronIceLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalParticulateIronIceLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nPartIronIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalParticulateIronIceLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalParticulateIronIceLocalMax', r3Ptr)

! Define variable verticalDissolvedIronIceLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDissolvedIronIceLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDisIronIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronIceLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronIceLocalMin', r3Ptr)

! Define variable verticalDissolvedIronIceLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalDissolvedIronIceLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nDisIronIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerVerticalIronActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalDissolvedIronIceLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalDissolvedIronIceLocalMax', r3Ptr)

! Define variable verticalAerosolsSnowLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAerosolsSnowLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nzAerosolsSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsSnowLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsSnowLocalMin', r3Ptr)

! Define variable verticalAerosolsSnowLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAerosolsSnowLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nzAerosolsSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsSnowLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsSnowLocalMax', r3Ptr)

! Define variable verticalAerosolsIceLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAerosolsIceLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nzAerosolsIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsIceLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsIceLocalMin', r3Ptr)

! Define variable verticalAerosolsIceLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalAerosolsIceLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nzAerosolsIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZAerosolsActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalAerosolsIceLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalAerosolsIceLocalMax', r3Ptr)

! Define variable verticalSalinityLocalMin
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSalinityLocalMin'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZSalinityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSalinityLocalMin', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSalinityLocalMin', r3Ptr)

! Define variable verticalSalinityLocalMax
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalSalinityLocalMax'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgTracerZSalinityActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalSalinityLocalMax', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalSalinityLocalMax', r3Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_tracer_monotonicity


   subroutine seaice_generate_pool_rotated_mesh(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'rotated_mesh', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'rotated_mesh', newSubPool)

! Define variable xCellRotate
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'xCellRotate'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'xCellRotate', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'xCellRotate', r1Ptr)

! Define variable yCellRotate
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'yCellRotate'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'yCellRotate', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'yCellRotate', r1Ptr)

! Define variable zCellRotate
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'zCellRotate'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'zCellRotate', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zCellRotate', r1Ptr)

! Define variable xVertexRotate
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'xVertexRotate'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'xVertexRotate', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'xVertexRotate', r1Ptr)

! Define variable yVertexRotate
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'yVertexRotate'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'yVertexRotate', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'yVertexRotate', r1Ptr)

! Define variable zVertexRotate
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'zVertexRotate'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'zVertexRotate', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zVertexRotate', r1Ptr)

! Define variable xEdgeRotate
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'xEdgeRotate'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'xEdgeRotate', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'xEdgeRotate', r1Ptr)

! Define variable yEdgeRotate
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'yEdgeRotate'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'yEdgeRotate', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'yEdgeRotate', r1Ptr)

! Define variable zEdgeRotate
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'zEdgeRotate'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'zEdgeRotate', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zEdgeRotate', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_rotated_mesh


   subroutine seaice_generate_pool_incremental_remap(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'incremental_remap', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'incremental_remap', newSubPool)

! Define variable xTriangle
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'xTriangle'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nQuadPoints'
      r3Ptr % dimNames(2) = 'nTriPerEdgeRemap'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'xTriangle', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'xTriangle', r3Ptr)

! Define variable yTriangle
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'yTriangle'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nQuadPoints'
      r3Ptr % dimNames(2) = 'nTriPerEdgeRemap'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'yTriangle', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'yTriangle', r3Ptr)

! Define variable iCellTriangle
      allocate(i2Ptr)

! Setting up time level 1
      i2Ptr % fieldName = 'iCellTriangle'
      i2Ptr % isVarArray = .false.
      i2Ptr % isDecomposed = .true.
      i2Ptr % hasTimeDimension = .false.
      i2Ptr % isPersistent = .true.
      i2Ptr % isActive = .false.
! Setting up dimensions
      i2Ptr % dimNames(1) = 'nTriPerEdgeRemap'
      i2Ptr % dimNames(2) = 'nEdges'
      i2Ptr % defaultValue = 0
      allocate(i2Ptr % attLists(1))
      allocate(i2Ptr % attLists(1) % attList)
      i2Ptr % missingValue = MPAS_INT_FILLVAL
      i2Ptr % block => block

      i2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iCellTriangle', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'iCellTriangle', i2Ptr)

! Define variable triangleArea
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'triangleArea'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nTriPerEdgeRemap'
      r2Ptr % dimNames(2) = 'nEdges'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      r2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'triangleArea', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'triangleArea', r2Ptr)

! Define variable departurePoint
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'departurePoint'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'TWO'
      r2Ptr % dimNames(2) = 'nVertices'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      r2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'departurePoint', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'departurePoint', r2Ptr)

! Define variable remapEdge
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'remapEdge'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .false.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nEdges'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'remapEdge', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'remapEdge', i1Ptr)

! Define variable cellsOnEdgeRemap
      allocate(i2Ptr)

! Setting up time level 1
      i2Ptr % fieldName = 'cellsOnEdgeRemap'
      i2Ptr % isVarArray = .false.
      i2Ptr % isDecomposed = .true.
      i2Ptr % hasTimeDimension = .false.
      i2Ptr % isPersistent = .true.
      i2Ptr % isActive = .false.
! Setting up dimensions
      i2Ptr % dimNames(1) = 'maxCellsPerEdgeRemap'
      i2Ptr % dimNames(2) = 'nEdges'
      i2Ptr % defaultValue = 0
      allocate(i2Ptr % attLists(1))
      allocate(i2Ptr % attLists(1) % attList)
      i2Ptr % missingValue = MPAS_INT_FILLVAL
      i2Ptr % block => block

      i2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'cellsOnEdgeRemap', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'cellsOnEdgeRemap', i2Ptr)

! Define variable edgesOnEdgeRemap
      allocate(i2Ptr)

! Setting up time level 1
      i2Ptr % fieldName = 'edgesOnEdgeRemap'
      i2Ptr % isVarArray = .false.
      i2Ptr % isDecomposed = .true.
      i2Ptr % hasTimeDimension = .false.
      i2Ptr % isPersistent = .true.
      i2Ptr % isActive = .false.
! Setting up dimensions
      i2Ptr % dimNames(1) = 'maxEdgesPerEdgeRemap'
      i2Ptr % dimNames(2) = 'nEdges'
      i2Ptr % defaultValue = 0
      allocate(i2Ptr % attLists(1))
      allocate(i2Ptr % attLists(1) % attList)
      i2Ptr % missingValue = MPAS_INT_FILLVAL
      i2Ptr % block => block

      i2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'edgesOnEdgeRemap', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'edgesOnEdgeRemap', i2Ptr)

! Define variable xVertexOnCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'xVertexOnCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxEdges'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      r2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'xVertexOnCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'xVertexOnCell', r2Ptr)

! Define variable yVertexOnCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'yVertexOnCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxEdges'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      r2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'yVertexOnCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'yVertexOnCell', r2Ptr)

! Define variable xVertexOnEdge
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'xVertexOnEdge'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxVerticesPerEdgeRemap'
      r2Ptr % dimNames(2) = 'nEdges'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      r2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'xVertexOnEdge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'xVertexOnEdge', r2Ptr)

! Define variable yVertexOnEdge
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'yVertexOnEdge'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxVerticesPerEdgeRemap'
      r2Ptr % dimNames(2) = 'nEdges'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      r2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'yVertexOnEdge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'yVertexOnEdge', r2Ptr)

! Define variable transCellToGlobal
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'transCellToGlobal'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'R3'
      r3Ptr % dimNames(2) = 'R3'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'transCellToGlobal', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'transCellToGlobal', r3Ptr)

! Define variable transGlobalToCell
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'transGlobalToCell'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'R3'
      r3Ptr % dimNames(2) = 'R3'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'transGlobalToCell', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'transGlobalToCell', r3Ptr)

! Define variable transVertexToGlobal
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'transVertexToGlobal'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'R3'
      r3Ptr % dimNames(2) = 'R3'
      r3Ptr % dimNames(3) = 'nVertices'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'transVertexToGlobal', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'transVertexToGlobal', r3Ptr)

! Define variable transGlobalToVertex
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'transGlobalToVertex'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'R3'
      r3Ptr % dimNames(2) = 'R3'
      r3Ptr % dimNames(3) = 'nVertices'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'transGlobalToVertex', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'transGlobalToVertex', r3Ptr)

! Define variable transEdgeToGlobal
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'transEdgeToGlobal'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'R3'
      r3Ptr % dimNames(2) = 'R3'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'transEdgeToGlobal', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'transEdgeToGlobal', r3Ptr)

! Define variable transGlobalToEdge
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'transGlobalToEdge'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'R3'
      r3Ptr % dimNames(2) = 'R3'
      r3Ptr % dimNames(3) = 'nEdges'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'transGlobalToEdge', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'transGlobalToEdge', r3Ptr)

! Define variable minLengthEdgesOnVertex
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'minLengthEdgesOnVertex'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'minLengthEdgesOnVertex', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'minLengthEdgesOnVertex', r1Ptr)

! Define variable xAvgCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'xAvgCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'xAvgCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'xAvgCell', r1Ptr)

! Define variable yAvgCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'yAvgCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'yAvgCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'yAvgCell', r1Ptr)

! Define variable xxAvgCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'xxAvgCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'xxAvgCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'xxAvgCell', r1Ptr)

! Define variable xyAvgCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'xyAvgCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'xyAvgCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'xyAvgCell', r1Ptr)

! Define variable yyAvgCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'yyAvgCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'yyAvgCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'yyAvgCell', r1Ptr)

! Define variable xxxAvgCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'xxxAvgCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'xxxAvgCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'xxxAvgCell', r1Ptr)

! Define variable xxyAvgCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'xxyAvgCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'xxyAvgCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'xxyAvgCell', r1Ptr)

! Define variable xyyAvgCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'xyyAvgCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'xyyAvgCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'xyyAvgCell', r1Ptr)

! Define variable yyyAvgCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'yyyAvgCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'yyyAvgCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'yyyAvgCell', r1Ptr)

! Define variable xxxxAvgCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'xxxxAvgCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'xxxxAvgCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'xxxxAvgCell', r1Ptr)

! Define variable xxxyAvgCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'xxxyAvgCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'xxxyAvgCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'xxxyAvgCell', r1Ptr)

! Define variable xxyyAvgCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'xxyyAvgCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'xxyyAvgCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'xxyyAvgCell', r1Ptr)

! Define variable xyyyAvgCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'xyyyAvgCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'xyyyAvgCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'xyyyAvgCell', r1Ptr)

! Define variable yyyyAvgCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'yyyyAvgCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'yyyyAvgCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'yyyyAvgCell', r1Ptr)

! Define variable maskEdge
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'maskEdge'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .false.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nEdges'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'maskEdge', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'maskEdge', i1Ptr)

! Define variable maskCell
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'maskCell'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .false.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nCells'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'maskCell', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'maskCell', i1Ptr)

! Define variable maskCategoryCell
      allocate(i2Ptr)

! Setting up time level 1
      i2Ptr % fieldName = 'maskCategoryCell'
      i2Ptr % isVarArray = .false.
      i2Ptr % isDecomposed = .true.
      i2Ptr % hasTimeDimension = .false.
      i2Ptr % isPersistent = .true.
      i2Ptr % isActive = .false.
! Setting up dimensions
      i2Ptr % dimNames(1) = 'nCategories'
      i2Ptr % dimNames(2) = 'nCells'
      i2Ptr % defaultValue = 0
      allocate(i2Ptr % attLists(1))
      allocate(i2Ptr % attLists(1) % attList)
      i2Ptr % missingValue = MPAS_INT_FILLVAL
      i2Ptr % block => block

      i2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'maskCategoryCell', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'maskCategoryCell', i2Ptr)

! Define variable workCategoryCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'workCategoryCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      r2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'workCategoryCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'workCategoryCell', r2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_incremental_remap


   subroutine seaice_generate_pool_forcing(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'forcing', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'forcing', newSubPool)

! Define variable nForcingGroupCounter
      allocate(i0Ptr)

! Setting up time level 1
      i0Ptr % fieldName = 'nForcingGroupCounter'
      i0Ptr % isVarArray = .false.
      i0Ptr % isDecomposed = .false.
      i0Ptr % hasTimeDimension = .true.
      i0Ptr % defaultValue = 0
      i0Ptr % scalar = 0
      allocate(i0Ptr % attLists(1))
      allocate(i0Ptr % attLists(1) % attList)
      i0Ptr % missingValue = MPAS_INT_FILLVAL
      i0Ptr % block => block

      if (pkgForcingActive) then
         i0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'nForcingGroupCounter', i0Ptr)
      call mpas_pool_add_field(block % allFields, 'nForcingGroupCounter', i0Ptr)

! Define variable forcingGroupNames
      allocate(c1Ptr)

! Setting up time level 1
      c1Ptr % fieldName = 'forcingGroupNames'
      c1Ptr % isVarArray = .false.
      c1Ptr % isDecomposed = .false.
      c1Ptr % hasTimeDimension = .true.
      c1Ptr % isPersistent = .true.
      c1Ptr % isActive = .false.
! Setting up dimensions
      c1Ptr % dimNames(1) = 'nForcingGroupsMax'
      c1Ptr % defaultValue = ''
      allocate(c1Ptr % attLists(1))
      allocate(c1Ptr % attLists(1) % attList)
      c1Ptr % missingValue = MPAS_CHAR_FILLVAL
      c1Ptr % block => block

      if (pkgForcingActive) then
         c1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'forcingGroupNames', c1Ptr)
      call mpas_pool_add_field(block % allFields, 'forcingGroupNames', c1Ptr)

! Define variable forcingGroupRestartTimes
      allocate(c1Ptr)

! Setting up time level 1
      c1Ptr % fieldName = 'forcingGroupRestartTimes'
      c1Ptr % isVarArray = .false.
      c1Ptr % isDecomposed = .false.
      c1Ptr % hasTimeDimension = .true.
      c1Ptr % isPersistent = .true.
      c1Ptr % isActive = .false.
! Setting up dimensions
      c1Ptr % dimNames(1) = 'nForcingGroupsMax'
      c1Ptr % defaultValue = ''
      allocate(c1Ptr % attLists(1))
      allocate(c1Ptr % attLists(1) % attList)
      c1Ptr % missingValue = MPAS_CHAR_FILLVAL
      c1Ptr % block => block

      if (pkgForcingActive) then
         c1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'forcingGroupRestartTimes', c1Ptr)
      call mpas_pool_add_field(block % allFields, 'forcingGroupRestartTimes', c1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_forcing


   subroutine seaice_generate_pool_atmos_coupling(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'atmos_coupling', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'atmos_coupling', newSubPool)

! Define variable airLevelHeight
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'airLevelHeight'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 10.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'airLevelHeight', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'airLevelHeight', r1Ptr)

! Define variable airPotentialTemperature
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'airPotentialTemperature'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 253.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'airPotentialTemperature', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'airPotentialTemperature', r1Ptr)

! Define variable airTemperature
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'airTemperature'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 253.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'airTemperature', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'airTemperature', r1Ptr)

! Define variable airSpecificHumidity
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'airSpecificHumidity'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0006
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'airSpecificHumidity', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'airSpecificHumidity', r1Ptr)

! Define variable airDensity
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'airDensity'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 1.3
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'airDensity', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'airDensity', r1Ptr)

! Define variable shortwaveVisibleDirectDown
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'shortwaveVisibleDirectDown'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'shortwaveVisibleDirectDown', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'shortwaveVisibleDirectDown', r1Ptr)

! Define variable shortwaveVisibleDiffuseDown
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'shortwaveVisibleDiffuseDown'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'shortwaveVisibleDiffuseDown', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'shortwaveVisibleDiffuseDown', r1Ptr)

! Define variable shortwaveIRDirectDown
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'shortwaveIRDirectDown'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'shortwaveIRDirectDown', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'shortwaveIRDirectDown', r1Ptr)

! Define variable shortwaveIRDiffuseDown
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'shortwaveIRDiffuseDown'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'shortwaveIRDiffuseDown', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'shortwaveIRDiffuseDown', r1Ptr)

! Define variable longwaveDown
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'longwaveDown'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 180.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'longwaveDown', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'longwaveDown', r1Ptr)

! Define variable rainfallRate
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'rainfallRate'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'rainfallRate', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'rainfallRate', r1Ptr)

! Define variable snowfallRate
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'snowfallRate'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'snowfallRate', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'snowfallRate', r1Ptr)

! Define variable uAirVelocity
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'uAirVelocity'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 5.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'uAirVelocity', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'uAirVelocity', r1Ptr)

! Define variable vAirVelocity
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'vAirVelocity'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 5.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'vAirVelocity', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'vAirVelocity', r1Ptr)

! Define variable atmosReferenceSpeed10m
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'atmosReferenceSpeed10m'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'atmosReferenceSpeed10m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'atmosReferenceSpeed10m', r1Ptr)

! Define variable atmosReferenceTemperature2m
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'atmosReferenceTemperature2m'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'atmosReferenceTemperature2m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'atmosReferenceTemperature2m', r1Ptr)

! Define variable atmosReferenceHumidity2m
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'atmosReferenceHumidity2m'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'atmosReferenceHumidity2m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'atmosReferenceHumidity2m', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_atmos_coupling


   subroutine seaice_generate_pool_atmos_forcing(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'atmos_forcing', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'atmos_forcing', newSubPool)

! Define variable windSpeed
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'windSpeed'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'windSpeed', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'windSpeed', r1Ptr)

! Define variable uAirStress
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'uAirStress'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.05
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'uAirStress', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'uAirStress', r1Ptr)

! Define variable vAirStress
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'vAirStress'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.05
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'vAirStress', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'vAirStress', r1Ptr)

! Define variable shortwaveDown
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'shortwaveDown'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'shortwaveDown', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'shortwaveDown', r1Ptr)

! Define variable cloudFraction
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'cloudFraction'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'cloudFraction', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'cloudFraction', r1Ptr)

! Define variable sensibleTransferCoefficient
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'sensibleTransferCoefficient'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'sensibleTransferCoefficient', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'sensibleTransferCoefficient', r1Ptr)

! Define variable latentTransferCoefficient
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'latentTransferCoefficient'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'latentTransferCoefficient', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'latentTransferCoefficient', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_atmos_forcing


   subroutine seaice_generate_pool_alternative_atmos_forcing(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'alternative_atmos_forcing', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'alternative_atmos_forcing', newSubPool)

! Define variable latentHeatFluxCouple
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'latentHeatFluxCouple'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      r2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'latentHeatFluxCouple', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'latentHeatFluxCouple', r2Ptr)

! Define variable sensibleHeatFluxCouple
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'sensibleHeatFluxCouple'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      r2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'sensibleHeatFluxCouple', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'sensibleHeatFluxCouple', r2Ptr)

! Define variable surfaceHeatFluxCouple
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'surfaceHeatFluxCouple'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      r2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'surfaceHeatFluxCouple', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceHeatFluxCouple', r2Ptr)

! Define variable surfaceConductiveFluxCouple
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'surfaceConductiveFluxCouple'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      r2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'surfaceConductiveFluxCouple', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceConductiveFluxCouple', r2Ptr)

! Define variable airStressForcingU
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'airStressForcingU'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'airStressForcingU', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'airStressForcingU', r1Ptr)

! Define variable airStressForcingV
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'airStressForcingV'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'airStressForcingV', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'airStressForcingV', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_alternative_atmos_forcing


   subroutine seaice_generate_pool_ocean_coupling(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'ocean_coupling', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'ocean_coupling', newSubPool)

! Define variable seaSurfaceTemperature
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'seaSurfaceTemperature'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'seaSurfaceTemperature', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'seaSurfaceTemperature', r1Ptr)

! Define variable seaSurfaceSalinity
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'seaSurfaceSalinity'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 34.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'seaSurfaceSalinity', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'seaSurfaceSalinity', r1Ptr)

! Define variable seaFreezingTemperature
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'seaFreezingTemperature'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'seaFreezingTemperature', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'seaFreezingTemperature', r1Ptr)

! Define variable freezingMeltingPotential
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'freezingMeltingPotential'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'freezingMeltingPotential', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'freezingMeltingPotential', r1Ptr)

! Define variable uOceanVelocity
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'uOceanVelocity'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'uOceanVelocity', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'uOceanVelocity', r1Ptr)

! Define variable vOceanVelocity
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'vOceanVelocity'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'vOceanVelocity', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'vOceanVelocity', r1Ptr)

! Define variable seaSurfaceTiltU
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'seaSurfaceTiltU'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'seaSurfaceTiltU', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'seaSurfaceTiltU', r1Ptr)

! Define variable seaSurfaceTiltV
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'seaSurfaceTiltV'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'seaSurfaceTiltV', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'seaSurfaceTiltV', r1Ptr)

! Define variable oceanMixedLayerDepth
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanMixedLayerDepth'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 20.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'oceanMixedLayerDepth', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanMixedLayerDepth', r1Ptr)

! Define variable oceanHeatFluxConvergence
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanHeatFluxConvergence'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'oceanHeatFluxConvergence', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanHeatFluxConvergence', r1Ptr)

! Define variable landIceMask
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'landIceMask'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .true.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nCells'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'landIceMask', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'landIceMask', i1Ptr)

! Define variable landIceMaskVertex
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'landIceMaskVertex'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .true.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nVertices'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'landIceMaskVertex', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'landIceMaskVertex', i1Ptr)

! Define variable landIceMaskEdge
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'landIceMaskEdge'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .true.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nEdges'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'landIceMaskEdge', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'landIceMaskEdge', i1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_ocean_coupling


   subroutine seaice_generate_pool_boundary(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'boundary', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'boundary', newSubPool)

! Define variable interiorVertex
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'interiorVertex'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .true.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nVertices'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'interiorVertex', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'interiorVertex', i1Ptr)

! Define variable interiorCell
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'interiorCell'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .true.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nCells'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'interiorCell', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'interiorCell', i1Ptr)

! Define variable interiorEdge
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'interiorEdge'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .true.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nEdges'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'interiorEdge', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'interiorEdge', i1Ptr)

! Define variable blockIDout
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'blockIDout'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .true.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nCells'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'blockIDout', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'blockIDout', i1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_boundary


   subroutine seaice_generate_pool_velocity_solver(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'velocity_solver', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'velocity_solver', newSubPool)

! Define variable dynamicsTimeStep
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'dynamicsTimeStep'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .false.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      r0Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'dynamicsTimeStep', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'dynamicsTimeStep', r0Ptr)

! Define variable elasticTimeStep
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'elasticTimeStep'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .false.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      r0Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'elasticTimeStep', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'elasticTimeStep', r0Ptr)

! Define variable uVelocity
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'uVelocity'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'uVelocity', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'uVelocity', r1Ptr)

! Define variable vVelocity
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'vVelocity'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'vVelocity', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'vVelocity', r1Ptr)

! Define variable uVelocityCGrid
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'uVelocityCGrid'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'uVelocityCGrid', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'uVelocityCGrid', r1Ptr)

! Define variable vVelocityCGrid
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'vVelocityCGrid'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'vVelocityCGrid', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'vVelocityCGrid', r1Ptr)

! Define variable uVelocityCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'uVelocityCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'uVelocityCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'uVelocityCell', r1Ptr)

! Define variable vVelocityCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'vVelocityCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'vVelocityCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'vVelocityCell', r1Ptr)

! Define variable uVelocityInitial
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'uVelocityInitial'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'uVelocityInitial', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'uVelocityInitial', r1Ptr)

! Define variable vVelocityInitial
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'vVelocityInitial'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'vVelocityInitial', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'vVelocityInitial', r1Ptr)

! Define variable uVelocityInitialCGrid
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'uVelocityInitialCGrid'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'uVelocityInitialCGrid', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'uVelocityInitialCGrid', r1Ptr)

! Define variable vVelocityInitialCGrid
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'vVelocityInitialCGrid'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'vVelocityInitialCGrid', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'vVelocityInitialCGrid', r1Ptr)

! Define variable edgeVelocity
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'edgeVelocity'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'edgeVelocity', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'edgeVelocity', r1Ptr)

! Define variable normalVectorEdge
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'normalVectorEdge'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .true.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'maxEdges'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      r3Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'normalVectorEdge', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'normalVectorEdge', r3Ptr)

! Define variable solveStress
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'solveStress'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .true.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nCells'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'solveStress', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'solveStress', i1Ptr)

! Define variable solveStressTri
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'solveStressTri'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .true.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nVertices'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'solveStressTri', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'solveStressTri', i1Ptr)

! Define variable solveVelocity
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'solveVelocity'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .true.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nVertices'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'solveVelocity', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'solveVelocity', i1Ptr)

! Define variable solveVelocityPrevious
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'solveVelocityPrevious'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .true.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nVertices'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'solveVelocityPrevious', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'solveVelocityPrevious', i1Ptr)

! Define variable solveVelocityCGrid
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'solveVelocityCGrid'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .true.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nEdges'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'solveVelocityCGrid', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'solveVelocityCGrid', i1Ptr)

! Define variable solveVelocityPreviousCGrid
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'solveVelocityPreviousCGrid'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .true.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nEdges'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'solveVelocityPreviousCGrid', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'solveVelocityPreviousCGrid', i1Ptr)

! Define variable icePressure
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'icePressure'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'icePressure', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'icePressure', r1Ptr)

! Define variable stressDivergenceU
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'stressDivergenceU'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'stressDivergenceU', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'stressDivergenceU', r1Ptr)

! Define variable stressDivergenceV
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'stressDivergenceV'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'stressDivergenceV', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'stressDivergenceV', r1Ptr)

! Define variable stressDivergenceUNoMetric
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'stressDivergenceUNoMetric'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'stressDivergenceUNoMetric', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'stressDivergenceUNoMetric', r1Ptr)

! Define variable stressDivergenceVNoMetric
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'stressDivergenceVNoMetric'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'stressDivergenceVNoMetric', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'stressDivergenceVNoMetric', r1Ptr)

! Define variable stressDivergenceUMetric
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'stressDivergenceUMetric'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'stressDivergenceUMetric', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'stressDivergenceUMetric', r1Ptr)

! Define variable stressDivergenceVMetric
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'stressDivergenceVMetric'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'stressDivergenceVMetric', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'stressDivergenceVMetric', r1Ptr)

! Define variable stressDivergenceUAnalytical
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'stressDivergenceUAnalytical'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'stressDivergenceUAnalytical', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'stressDivergenceUAnalytical', r1Ptr)

! Define variable stressDivergenceVAnalytical
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'stressDivergenceVAnalytical'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'stressDivergenceVAnalytical', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'stressDivergenceVAnalytical', r1Ptr)

! Define variable stressDivergenceUAnalyticalCGrid
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'stressDivergenceUAnalyticalCGrid'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'stressDivergenceUAnalyticalCGrid', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'stressDivergenceUAnalyticalCGrid', r1Ptr)

! Define variable stressDivergenceVAnalyticalCGrid
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'stressDivergenceVAnalyticalCGrid'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'stressDivergenceVAnalyticalCGrid', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'stressDivergenceVAnalyticalCGrid', r1Ptr)

! Define variable stressDivergenceUCGrid
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'stressDivergenceUCGrid'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'stressDivergenceUCGrid', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'stressDivergenceUCGrid', r1Ptr)

! Define variable stressDivergenceVCGrid
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'stressDivergenceVCGrid'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'stressDivergenceVCGrid', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'stressDivergenceVCGrid', r1Ptr)

! Define variable stressDivergenceUCGridNoMetric
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'stressDivergenceUCGridNoMetric'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'stressDivergenceUCGridNoMetric', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'stressDivergenceUCGridNoMetric', r1Ptr)

! Define variable stressDivergenceVCGridNoMetric
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'stressDivergenceVCGridNoMetric'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'stressDivergenceVCGridNoMetric', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'stressDivergenceVCGridNoMetric', r1Ptr)

! Define variable stressDivergenceUCGridMetric
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'stressDivergenceUCGridMetric'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'stressDivergenceUCGridMetric', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'stressDivergenceUCGridMetric', r1Ptr)

! Define variable stressDivergenceVCGridMetric
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'stressDivergenceVCGridMetric'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'stressDivergenceVCGridMetric', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'stressDivergenceVCGridMetric', r1Ptr)

! Define variable airStressCellU
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'airStressCellU'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'airStressCellU', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'airStressCellU', r1Ptr)

! Define variable airStressCellV
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'airStressCellV'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'airStressCellV', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'airStressCellV', r1Ptr)

! Define variable airStressVertexU
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'airStressVertexU'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'airStressVertexU', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'airStressVertexU', r1Ptr)

! Define variable airStressVertexV
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'airStressVertexV'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'airStressVertexV', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'airStressVertexV', r1Ptr)

! Define variable airStressEdgeU
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'airStressEdgeU'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'airStressEdgeU', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'airStressEdgeU', r1Ptr)

! Define variable airStressEdgeV
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'airStressEdgeV'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'airStressEdgeV', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'airStressEdgeV', r1Ptr)

! Define variable uOceanVelocityVertex
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'uOceanVelocityVertex'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'uOceanVelocityVertex', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'uOceanVelocityVertex', r1Ptr)

! Define variable vOceanVelocityVertex
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'vOceanVelocityVertex'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'vOceanVelocityVertex', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'vOceanVelocityVertex', r1Ptr)

! Define variable uOceanVelocityEdge
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'uOceanVelocityEdge'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'uOceanVelocityEdge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'uOceanVelocityEdge', r1Ptr)

! Define variable vOceanVelocityEdge
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'vOceanVelocityEdge'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'vOceanVelocityEdge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'vOceanVelocityEdge', r1Ptr)

! Define variable oceanStressU
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanStressU'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'oceanStressU', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanStressU', r1Ptr)

! Define variable oceanStressV
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanStressV'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'oceanStressV', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanStressV', r1Ptr)

! Define variable oceanStressEdgeU
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanStressEdgeU'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'oceanStressEdgeU', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanStressEdgeU', r1Ptr)

! Define variable oceanStressEdgeV
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanStressEdgeV'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'oceanStressEdgeV', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanStressEdgeV', r1Ptr)

! Define variable oceanStressCoeff
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanStressCoeff'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'oceanStressCoeff', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanStressCoeff', r1Ptr)

! Define variable oceanStressCoeffEdge
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanStressCoeffEdge'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'oceanStressCoeffEdge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanStressCoeffEdge', r1Ptr)

! Define variable oceanStressCellU
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanStressCellU'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'oceanStressCellU', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanStressCellU', r1Ptr)

! Define variable oceanStressCellV
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanStressCellV'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'oceanStressCellV', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanStressCellV', r1Ptr)

! Define variable seaSurfaceTiltVertexU
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'seaSurfaceTiltVertexU'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'seaSurfaceTiltVertexU', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'seaSurfaceTiltVertexU', r1Ptr)

! Define variable seaSurfaceTiltVertexV
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'seaSurfaceTiltVertexV'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'seaSurfaceTiltVertexV', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'seaSurfaceTiltVertexV', r1Ptr)

! Define variable seaSurfaceTiltEdgeU
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'seaSurfaceTiltEdgeU'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'seaSurfaceTiltEdgeU', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'seaSurfaceTiltEdgeU', r1Ptr)

! Define variable seaSurfaceTiltEdgeV
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'seaSurfaceTiltEdgeV'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'seaSurfaceTiltEdgeV', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'seaSurfaceTiltEdgeV', r1Ptr)

! Define variable surfaceTiltForceU
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'surfaceTiltForceU'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'surfaceTiltForceU', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceTiltForceU', r1Ptr)

! Define variable surfaceTiltForceV
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'surfaceTiltForceV'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'surfaceTiltForceV', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceTiltForceV', r1Ptr)

! Define variable surfaceTiltForceEdgeU
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'surfaceTiltForceEdgeU'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'surfaceTiltForceEdgeU', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceTiltForceEdgeU', r1Ptr)

! Define variable surfaceTiltForceEdgeV
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'surfaceTiltForceEdgeV'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'surfaceTiltForceEdgeV', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceTiltForceEdgeV', r1Ptr)

! Define variable totalMassVertexfVertex
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'totalMassVertexfVertex'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'totalMassVertexfVertex', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'totalMassVertexfVertex', r1Ptr)

! Define variable totalMassEdgefEdge
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'totalMassEdgefEdge'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'totalMassEdgefEdge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'totalMassEdgefEdge', r1Ptr)

! Define variable divergence
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'divergence'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'divergence', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'divergence', r1Ptr)

! Define variable shear
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'shear'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'shear', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'shear', r1Ptr)

! Define variable dynamicallyLockedCellsMask
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'dynamicallyLockedCellsMask'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .true.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nCells'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'dynamicallyLockedCellsMask', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'dynamicallyLockedCellsMask', i1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_velocity_solver


   subroutine seaice_generate_pool_velocity_weak(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'velocity_weak', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'velocity_weak', newSubPool)

! Define variable normalVectorPolygon
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'normalVectorPolygon'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'maxEdges'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgWeakActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'normalVectorPolygon', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'normalVectorPolygon', r3Ptr)

! Define variable normalVectorTriangle
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'normalVectorTriangle'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'TWO'
      r3Ptr % dimNames(2) = 'vertexDegree'
      r3Ptr % dimNames(3) = 'nVertices'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgWeakActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'normalVectorTriangle', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'normalVectorTriangle', r3Ptr)

! Define variable latCellRotated
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'latCellRotated'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgWeakActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'latCellRotated', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'latCellRotated', r1Ptr)

! Define variable latVertexRotated
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'latVertexRotated'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgWeakActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'latVertexRotated', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'latVertexRotated', r1Ptr)

! Define variable strain11weak
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'strain11weak'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgWeakActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'strain11', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'strain11weak', r1Ptr)

! Define variable strain22weak
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'strain22weak'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgWeakActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'strain22', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'strain22weak', r1Ptr)

! Define variable strain12weak
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'strain12weak'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgWeakActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'strain12', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'strain12weak', r1Ptr)

! Define variable stress11weak
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'stress11weak'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgWeakActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'stress11', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'stress11weak', r1Ptr)

! Define variable stress22weak
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'stress22weak'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgWeakActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'stress22', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'stress22weak', r1Ptr)

! Define variable stress12weak
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'stress12weak'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgWeakActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'stress12', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'stress12weak', r1Ptr)

! Define variable principalStress1Weak
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'principalStress1Weak'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgWeakActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'principalStress1', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'principalStress1Weak', r1Ptr)

! Define variable principalStress2Weak
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'principalStress2Weak'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgWeakActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'principalStress2', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'principalStress2Weak', r1Ptr)

! Define variable replacementPressureWeak
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'replacementPressureWeak'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgWeakActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'replacementPressure', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'replacementPressureWeak', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_velocity_weak


   subroutine seaice_generate_pool_velocity_variational(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'velocity_variational', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'velocity_variational', newSubPool)

! Define variable strain11var
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'strain11var'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxEdges'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgVariationalActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'strain11', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'strain11var', r2Ptr)

! Define variable strain22var
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'strain22var'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxEdges'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgVariationalActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'strain22', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'strain22var', r2Ptr)

! Define variable strain12var
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'strain12var'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxEdges'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgVariationalActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'strain12', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'strain12var', r2Ptr)

! Define variable strain11varTri
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'strain11varTri'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'vertexDegree'
      r2Ptr % dimNames(2) = 'nVertices'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgVariationalActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'strain11Tri', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'strain11varTri', r2Ptr)

! Define variable strain22varTri
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'strain22varTri'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'vertexDegree'
      r2Ptr % dimNames(2) = 'nVertices'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgVariationalActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'strain22Tri', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'strain22varTri', r2Ptr)

! Define variable strain12varTri
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'strain12varTri'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'vertexDegree'
      r2Ptr % dimNames(2) = 'nVertices'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgVariationalActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'strain12Tri', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'strain12varTri', r2Ptr)

! Define variable stress11var
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'stress11var'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxEdges'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgVariationalActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'stress11', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'stress11var', r2Ptr)

! Define variable stress22var
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'stress22var'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxEdges'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgVariationalActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'stress22', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'stress22var', r2Ptr)

! Define variable stress12var
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'stress12var'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxEdges'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgVariationalActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'stress12', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'stress12var', r2Ptr)

! Define variable stress11varTri
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'stress11varTri'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'vertexDegree'
      r2Ptr % dimNames(2) = 'nVertices'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgVariationalActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'stress11Tri', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'stress11varTri', r2Ptr)

! Define variable stress22varTri
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'stress22varTri'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'vertexDegree'
      r2Ptr % dimNames(2) = 'nVertices'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgVariationalActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'stress22Tri', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'stress22varTri', r2Ptr)

! Define variable stress12varTri
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'stress12varTri'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'vertexDegree'
      r2Ptr % dimNames(2) = 'nVertices'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgVariationalActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'stress12Tri', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'stress12varTri', r2Ptr)

! Define variable tanLatVertexRotatedOverRadius
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'tanLatVertexRotatedOverRadius'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgVariationalActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tanLatVertexRotatedOverRadius', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tanLatVertexRotatedOverRadius', r1Ptr)

! Define variable tanLatEdgeRotatedOverRadius
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'tanLatEdgeRotatedOverRadius'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgVariationalActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tanLatEdgeRotatedOverRadius', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tanLatEdgeRotatedOverRadius', r1Ptr)

! Define variable cellVerticesAtVertex
      allocate(i2Ptr)

! Setting up time level 1
      i2Ptr % fieldName = 'cellVerticesAtVertex'
      i2Ptr % isVarArray = .false.
      i2Ptr % isDecomposed = .true.
      i2Ptr % hasTimeDimension = .false.
      i2Ptr % isPersistent = .true.
      i2Ptr % isActive = .false.
! Setting up dimensions
      i2Ptr % dimNames(1) = 'vertexDegree'
      i2Ptr % dimNames(2) = 'nVertices'
      i2Ptr % defaultValue = 0
      allocate(i2Ptr % attLists(1))
      allocate(i2Ptr % attLists(1) % attList)
      i2Ptr % missingValue = MPAS_INT_FILLVAL
      i2Ptr % block => block

      if (pkgVariationalActive) then
         i2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'cellVerticesAtVertex', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'cellVerticesAtVertex', i2Ptr)

! Define variable cellEdgesAtEdge
      allocate(i2Ptr)

! Setting up time level 1
      i2Ptr % fieldName = 'cellEdgesAtEdge'
      i2Ptr % isVarArray = .false.
      i2Ptr % isDecomposed = .true.
      i2Ptr % hasTimeDimension = .false.
      i2Ptr % isPersistent = .true.
      i2Ptr % isActive = .false.
! Setting up dimensions
      i2Ptr % dimNames(1) = 'TWO'
      i2Ptr % dimNames(2) = 'nEdges'
      i2Ptr % defaultValue = 0
      allocate(i2Ptr % attLists(1))
      allocate(i2Ptr % attLists(1) % attList)
      i2Ptr % missingValue = MPAS_INT_FILLVAL
      i2Ptr % block => block

      if (pkgVariationalActive) then
         i2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'cellEdgesAtEdge', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'cellEdgesAtEdge', i2Ptr)

! Define variable triangleEdgesAtEdge
      allocate(i2Ptr)

! Setting up time level 1
      i2Ptr % fieldName = 'triangleEdgesAtEdge'
      i2Ptr % isVarArray = .false.
      i2Ptr % isDecomposed = .true.
      i2Ptr % hasTimeDimension = .false.
      i2Ptr % isPersistent = .true.
      i2Ptr % isActive = .false.
! Setting up dimensions
      i2Ptr % dimNames(1) = 'TWO'
      i2Ptr % dimNames(2) = 'nEdges'
      i2Ptr % defaultValue = 0
      allocate(i2Ptr % attLists(1))
      allocate(i2Ptr % attLists(1) % attList)
      i2Ptr % missingValue = MPAS_INT_FILLVAL
      i2Ptr % block => block

      if (pkgVariationalActive) then
         i2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'triangleEdgesAtEdge', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'triangleEdgesAtEdge', i2Ptr)

! Define variable areaCellCGrid
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'areaCellCGrid'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgVariationalActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'areaCellCGrid', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'areaCellCGrid', r1Ptr)

! Define variable areaTriCGrid
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'areaTriCGrid'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgVariationalActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'areaTriCGrid', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'areaTriCGrid', r1Ptr)

! Define variable basisIntegralsU
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'basisIntegralsU'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'maxEdges'
      r3Ptr % dimNames(2) = 'maxEdges'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgVariationalActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'basisIntegralsU', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'basisIntegralsU', r3Ptr)

! Define variable basisIntegralsV
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'basisIntegralsV'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'maxEdges'
      r3Ptr % dimNames(2) = 'maxEdges'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgVariationalActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'basisIntegralsV', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'basisIntegralsV', r3Ptr)

! Define variable basisIntegralsMetric
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'basisIntegralsMetric'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'maxEdges'
      r3Ptr % dimNames(2) = 'maxEdges'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgVariationalActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'basisIntegralsMetric', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'basisIntegralsMetric', r3Ptr)

! Define variable basisIntegralsUNew
      allocate(r4Ptr)

! Setting up time level 1
      r4Ptr % fieldName = 'basisIntegralsUNew'
      r4Ptr % isVarArray = .false.
      r4Ptr % isDecomposed = .true.
      r4Ptr % hasTimeDimension = .false.
      r4Ptr % isPersistent = .true.
      r4Ptr % isActive = .false.
! Setting up dimensions
      r4Ptr % dimNames(1) = 'nEdges'
      r4Ptr % dimNames(2) = 'maxEdges'
      r4Ptr % dimNames(3) = 'maxEdges'
      r4Ptr % dimNames(4) = 'TWO'
      r4Ptr % defaultValue = 0.0
      allocate(r4Ptr % attLists(1))
      allocate(r4Ptr % attLists(1) % attList)
      r4Ptr % missingValue = MPAS_REAL_FILLVAL
      r4Ptr % block => block

      if (pkgVariationalActive) then
         r4Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'basisIntegralsUNew', r4Ptr)
      call mpas_pool_add_field(block % allFields, 'basisIntegralsUNew', r4Ptr)

! Define variable basisIntegralsVNew
      allocate(r4Ptr)

! Setting up time level 1
      r4Ptr % fieldName = 'basisIntegralsVNew'
      r4Ptr % isVarArray = .false.
      r4Ptr % isDecomposed = .true.
      r4Ptr % hasTimeDimension = .false.
      r4Ptr % isPersistent = .true.
      r4Ptr % isActive = .false.
! Setting up dimensions
      r4Ptr % dimNames(1) = 'nEdges'
      r4Ptr % dimNames(2) = 'maxEdges'
      r4Ptr % dimNames(3) = 'maxEdges'
      r4Ptr % dimNames(4) = 'TWO'
      r4Ptr % defaultValue = 0.0
      allocate(r4Ptr % attLists(1))
      allocate(r4Ptr % attLists(1) % attList)
      r4Ptr % missingValue = MPAS_REAL_FILLVAL
      r4Ptr % block => block

      if (pkgVariationalActive) then
         r4Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'basisIntegralsVNew', r4Ptr)
      call mpas_pool_add_field(block % allFields, 'basisIntegralsVNew', r4Ptr)

! Define variable basisIntegralsMetricNew
      allocate(r4Ptr)

! Setting up time level 1
      r4Ptr % fieldName = 'basisIntegralsMetricNew'
      r4Ptr % isVarArray = .false.
      r4Ptr % isDecomposed = .true.
      r4Ptr % hasTimeDimension = .false.
      r4Ptr % isPersistent = .true.
      r4Ptr % isActive = .false.
! Setting up dimensions
      r4Ptr % dimNames(1) = 'nEdges'
      r4Ptr % dimNames(2) = 'maxEdges'
      r4Ptr % dimNames(3) = 'maxEdges'
      r4Ptr % dimNames(4) = 'TWO'
      r4Ptr % defaultValue = 0.0
      allocate(r4Ptr % attLists(1))
      allocate(r4Ptr % attLists(1) % attList)
      r4Ptr % missingValue = MPAS_REAL_FILLVAL
      r4Ptr % block => block

      if (pkgVariationalActive) then
         r4Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'basisIntegralsMetricNew', r4Ptr)
      call mpas_pool_add_field(block % allFields, 'basisIntegralsMetricNew', r4Ptr)

! Define variable basisIntegralsUNewNew
      allocate(r4Ptr)

! Setting up time level 1
      r4Ptr % fieldName = 'basisIntegralsUNewNew'
      r4Ptr % isVarArray = .false.
      r4Ptr % isDecomposed = .true.
      r4Ptr % hasTimeDimension = .false.
      r4Ptr % isPersistent = .true.
      r4Ptr % isActive = .false.
! Setting up dimensions
      r4Ptr % dimNames(1) = 'nVertices'
      r4Ptr % dimNames(2) = 'maxEdges'
      r4Ptr % dimNames(3) = 'maxEdges'
      r4Ptr % dimNames(4) = 'R3'
      r4Ptr % defaultValue = 0.0
      allocate(r4Ptr % attLists(1))
      allocate(r4Ptr % attLists(1) % attList)
      r4Ptr % missingValue = MPAS_REAL_FILLVAL
      r4Ptr % block => block

      if (pkgVariationalActive) then
         r4Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'basisIntegralsUNewNew', r4Ptr)
      call mpas_pool_add_field(block % allFields, 'basisIntegralsUNewNew', r4Ptr)

! Define variable basisIntegralsVNewNew
      allocate(r4Ptr)

! Setting up time level 1
      r4Ptr % fieldName = 'basisIntegralsVNewNew'
      r4Ptr % isVarArray = .false.
      r4Ptr % isDecomposed = .true.
      r4Ptr % hasTimeDimension = .false.
      r4Ptr % isPersistent = .true.
      r4Ptr % isActive = .false.
! Setting up dimensions
      r4Ptr % dimNames(1) = 'nVertices'
      r4Ptr % dimNames(2) = 'maxEdges'
      r4Ptr % dimNames(3) = 'maxEdges'
      r4Ptr % dimNames(4) = 'R3'
      r4Ptr % defaultValue = 0.0
      allocate(r4Ptr % attLists(1))
      allocate(r4Ptr % attLists(1) % attList)
      r4Ptr % missingValue = MPAS_REAL_FILLVAL
      r4Ptr % block => block

      if (pkgVariationalActive) then
         r4Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'basisIntegralsVNewNew', r4Ptr)
      call mpas_pool_add_field(block % allFields, 'basisIntegralsVNewNew', r4Ptr)

! Define variable basisIntegralsMetricNewNew
      allocate(r4Ptr)

! Setting up time level 1
      r4Ptr % fieldName = 'basisIntegralsMetricNewNew'
      r4Ptr % isVarArray = .false.
      r4Ptr % isDecomposed = .true.
      r4Ptr % hasTimeDimension = .false.
      r4Ptr % isPersistent = .true.
      r4Ptr % isActive = .false.
! Setting up dimensions
      r4Ptr % dimNames(1) = 'nVertices'
      r4Ptr % dimNames(2) = 'maxEdges'
      r4Ptr % dimNames(3) = 'maxEdges'
      r4Ptr % dimNames(4) = 'R3'
      r4Ptr % defaultValue = 0.0
      allocate(r4Ptr % attLists(1))
      allocate(r4Ptr % attLists(1) % attList)
      r4Ptr % missingValue = MPAS_REAL_FILLVAL
      r4Ptr % block => block

      if (pkgVariationalActive) then
         r4Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'basisIntegralsMetricNewNew', r4Ptr)
      call mpas_pool_add_field(block % allFields, 'basisIntegralsMetricNewNew', r4Ptr)

! Define variable basisIntegralsUTriNew
      allocate(r4Ptr)

! Setting up time level 1
      r4Ptr % fieldName = 'basisIntegralsUTriNew'
      r4Ptr % isVarArray = .false.
      r4Ptr % isDecomposed = .true.
      r4Ptr % hasTimeDimension = .false.
      r4Ptr % isPersistent = .true.
      r4Ptr % isActive = .false.
! Setting up dimensions
      r4Ptr % dimNames(1) = 'nEdges'
      r4Ptr % dimNames(2) = 'vertexDegree'
      r4Ptr % dimNames(3) = 'vertexDegree'
      r4Ptr % dimNames(4) = 'TWO'
      r4Ptr % defaultValue = 0.0
      allocate(r4Ptr % attLists(1))
      allocate(r4Ptr % attLists(1) % attList)
      r4Ptr % missingValue = MPAS_REAL_FILLVAL
      r4Ptr % block => block

      if (pkgVariationalActive) then
         r4Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'basisIntegralsUTriNew', r4Ptr)
      call mpas_pool_add_field(block % allFields, 'basisIntegralsUTriNew', r4Ptr)

! Define variable basisIntegralsVTriNew
      allocate(r4Ptr)

! Setting up time level 1
      r4Ptr % fieldName = 'basisIntegralsVTriNew'
      r4Ptr % isVarArray = .false.
      r4Ptr % isDecomposed = .true.
      r4Ptr % hasTimeDimension = .false.
      r4Ptr % isPersistent = .true.
      r4Ptr % isActive = .false.
! Setting up dimensions
      r4Ptr % dimNames(1) = 'nEdges'
      r4Ptr % dimNames(2) = 'vertexDegree'
      r4Ptr % dimNames(3) = 'vertexDegree'
      r4Ptr % dimNames(4) = 'TWO'
      r4Ptr % defaultValue = 0.0
      allocate(r4Ptr % attLists(1))
      allocate(r4Ptr % attLists(1) % attList)
      r4Ptr % missingValue = MPAS_REAL_FILLVAL
      r4Ptr % block => block

      if (pkgVariationalActive) then
         r4Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'basisIntegralsVTriNew', r4Ptr)
      call mpas_pool_add_field(block % allFields, 'basisIntegralsVTriNew', r4Ptr)

! Define variable basisIntegralsMetricTriNew
      allocate(r4Ptr)

! Setting up time level 1
      r4Ptr % fieldName = 'basisIntegralsMetricTriNew'
      r4Ptr % isVarArray = .false.
      r4Ptr % isDecomposed = .true.
      r4Ptr % hasTimeDimension = .false.
      r4Ptr % isPersistent = .true.
      r4Ptr % isActive = .false.
! Setting up dimensions
      r4Ptr % dimNames(1) = 'nEdges'
      r4Ptr % dimNames(2) = 'vertexDegree'
      r4Ptr % dimNames(3) = 'vertexDegree'
      r4Ptr % dimNames(4) = 'TWO'
      r4Ptr % defaultValue = 0.0
      allocate(r4Ptr % attLists(1))
      allocate(r4Ptr % attLists(1) % attList)
      r4Ptr % missingValue = MPAS_REAL_FILLVAL
      r4Ptr % block => block

      if (pkgVariationalActive) then
         r4Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'basisIntegralsMetricTriNew', r4Ptr)
      call mpas_pool_add_field(block % allFields, 'basisIntegralsMetricTriNew', r4Ptr)

! Define variable basisGradientU
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'basisGradientU'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'maxEdges'
      r3Ptr % dimNames(2) = 'maxEdges'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgVariationalActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'basisGradientU', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'basisGradientU', r3Ptr)

! Define variable basisGradientV
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'basisGradientV'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'maxEdges'
      r3Ptr % dimNames(2) = 'maxEdges'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgVariationalActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'basisGradientV', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'basisGradientV', r3Ptr)

! Define variable basisGradientUNew
      allocate(r4Ptr)

! Setting up time level 1
      r4Ptr % fieldName = 'basisGradientUNew'
      r4Ptr % isVarArray = .false.
      r4Ptr % isDecomposed = .true.
      r4Ptr % hasTimeDimension = .false.
      r4Ptr % isPersistent = .true.
      r4Ptr % isActive = .false.
! Setting up dimensions
      r4Ptr % dimNames(1) = 'nEdges'
      r4Ptr % dimNames(2) = 'maxEdges'
      r4Ptr % dimNames(3) = 'maxEdges'
      r4Ptr % dimNames(4) = 'TWO'
      r4Ptr % defaultValue = 0.0
      allocate(r4Ptr % attLists(1))
      allocate(r4Ptr % attLists(1) % attList)
      r4Ptr % missingValue = MPAS_REAL_FILLVAL
      r4Ptr % block => block

      if (pkgVariationalActive) then
         r4Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'basisGradientUNew', r4Ptr)
      call mpas_pool_add_field(block % allFields, 'basisGradientUNew', r4Ptr)

! Define variable basisGradientVNew
      allocate(r4Ptr)

! Setting up time level 1
      r4Ptr % fieldName = 'basisGradientVNew'
      r4Ptr % isVarArray = .false.
      r4Ptr % isDecomposed = .true.
      r4Ptr % hasTimeDimension = .false.
      r4Ptr % isPersistent = .true.
      r4Ptr % isActive = .false.
! Setting up dimensions
      r4Ptr % dimNames(1) = 'nEdges'
      r4Ptr % dimNames(2) = 'maxEdges'
      r4Ptr % dimNames(3) = 'maxEdges'
      r4Ptr % dimNames(4) = 'TWO'
      r4Ptr % defaultValue = 0.0
      allocate(r4Ptr % attLists(1))
      allocate(r4Ptr % attLists(1) % attList)
      r4Ptr % missingValue = MPAS_REAL_FILLVAL
      r4Ptr % block => block

      if (pkgVariationalActive) then
         r4Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'basisGradientVNew', r4Ptr)
      call mpas_pool_add_field(block % allFields, 'basisGradientVNew', r4Ptr)

! Define variable basisGradientUNewNew
      allocate(r4Ptr)

! Setting up time level 1
      r4Ptr % fieldName = 'basisGradientUNewNew'
      r4Ptr % isVarArray = .false.
      r4Ptr % isDecomposed = .true.
      r4Ptr % hasTimeDimension = .false.
      r4Ptr % isPersistent = .true.
      r4Ptr % isActive = .false.
! Setting up dimensions
      r4Ptr % dimNames(1) = 'nVertices'
      r4Ptr % dimNames(2) = 'maxEdges'
      r4Ptr % dimNames(3) = 'maxEdges'
      r4Ptr % dimNames(4) = 'R3'
      r4Ptr % defaultValue = 0.0
      allocate(r4Ptr % attLists(1))
      allocate(r4Ptr % attLists(1) % attList)
      r4Ptr % missingValue = MPAS_REAL_FILLVAL
      r4Ptr % block => block

      if (pkgVariationalActive) then
         r4Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'basisGradientUNewNew', r4Ptr)
      call mpas_pool_add_field(block % allFields, 'basisGradientUNewNew', r4Ptr)

! Define variable basisGradientVNewNew
      allocate(r4Ptr)

! Setting up time level 1
      r4Ptr % fieldName = 'basisGradientVNewNew'
      r4Ptr % isVarArray = .false.
      r4Ptr % isDecomposed = .true.
      r4Ptr % hasTimeDimension = .false.
      r4Ptr % isPersistent = .true.
      r4Ptr % isActive = .false.
! Setting up dimensions
      r4Ptr % dimNames(1) = 'nVertices'
      r4Ptr % dimNames(2) = 'maxEdges'
      r4Ptr % dimNames(3) = 'maxEdges'
      r4Ptr % dimNames(4) = 'R3'
      r4Ptr % defaultValue = 0.0
      allocate(r4Ptr % attLists(1))
      allocate(r4Ptr % attLists(1) % attList)
      r4Ptr % missingValue = MPAS_REAL_FILLVAL
      r4Ptr % block => block

      if (pkgVariationalActive) then
         r4Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'basisGradientVNewNew', r4Ptr)
      call mpas_pool_add_field(block % allFields, 'basisGradientVNewNew', r4Ptr)

! Define variable basisGradientUTriNew
      allocate(r4Ptr)

! Setting up time level 1
      r4Ptr % fieldName = 'basisGradientUTriNew'
      r4Ptr % isVarArray = .false.
      r4Ptr % isDecomposed = .true.
      r4Ptr % hasTimeDimension = .false.
      r4Ptr % isPersistent = .true.
      r4Ptr % isActive = .false.
! Setting up dimensions
      r4Ptr % dimNames(1) = 'nEdges'
      r4Ptr % dimNames(2) = 'vertexDegree'
      r4Ptr % dimNames(3) = 'vertexDegree'
      r4Ptr % dimNames(4) = 'TWO'
      r4Ptr % defaultValue = 0.0
      allocate(r4Ptr % attLists(1))
      allocate(r4Ptr % attLists(1) % attList)
      r4Ptr % missingValue = MPAS_REAL_FILLVAL
      r4Ptr % block => block

      if (pkgVariationalActive) then
         r4Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'basisGradientUTriNew', r4Ptr)
      call mpas_pool_add_field(block % allFields, 'basisGradientUTriNew', r4Ptr)

! Define variable basisGradientVTriNew
      allocate(r4Ptr)

! Setting up time level 1
      r4Ptr % fieldName = 'basisGradientVTriNew'
      r4Ptr % isVarArray = .false.
      r4Ptr % isDecomposed = .true.
      r4Ptr % hasTimeDimension = .false.
      r4Ptr % isPersistent = .true.
      r4Ptr % isActive = .false.
! Setting up dimensions
      r4Ptr % dimNames(1) = 'nEdges'
      r4Ptr % dimNames(2) = 'vertexDegree'
      r4Ptr % dimNames(3) = 'vertexDegree'
      r4Ptr % dimNames(4) = 'TWO'
      r4Ptr % defaultValue = 0.0
      allocate(r4Ptr % attLists(1))
      allocate(r4Ptr % attLists(1) % attList)
      r4Ptr % missingValue = MPAS_REAL_FILLVAL
      r4Ptr % block => block

      if (pkgVariationalActive) then
         r4Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'basisGradientVTriNew', r4Ptr)
      call mpas_pool_add_field(block % allFields, 'basisGradientVTriNew', r4Ptr)

! Define variable principalStress1Var
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'principalStress1Var'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxEdges'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgVariationalActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'principalStress1', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'principalStress1Var', r2Ptr)

! Define variable principalStress2Var
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'principalStress2Var'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxEdges'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgVariationalActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'principalStress2', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'principalStress2Var', r2Ptr)

! Define variable replacementPressureVar
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'replacementPressureVar'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxEdges'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgVariationalActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'replacementPressure', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'replacementPressureVar', r2Ptr)

! Define variable replacementPressureVarTri
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'replacementPressureVarTri'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'vertexDegree'
      r2Ptr % dimNames(2) = 'nVertices'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgVariationalActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'replacementPressureTri', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'replacementPressureVarTri', r2Ptr)

! Define variable variationalDenominator
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'variationalDenominator'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgVariationalActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'variationalDenominator', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'variationalDenominator', r1Ptr)

! Define variable variationalDenominatorCGrid
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'variationalDenominatorCGrid'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nEdges'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgVariationalActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'variationalDenominatorCGrid', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'variationalDenominatorCGrid', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_velocity_variational


   subroutine seaice_generate_pool_velocity_weak_variational(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'velocity_weak_variational', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'velocity_weak_variational', newSubPool)

! Define variable strain11Vertex
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'strain11Vertex'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgWeakVariationalActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'strain11Vertex', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'strain11Vertex', r1Ptr)

! Define variable strain22Vertex
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'strain22Vertex'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgWeakVariationalActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'strain22Vertex', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'strain22Vertex', r1Ptr)

! Define variable strain12Vertex
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'strain12Vertex'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgWeakVariationalActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'strain12Vertex', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'strain12Vertex', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_velocity_weak_variational


   subroutine seaice_generate_pool_ridging(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'ridging', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'ridging', newSubPool)

! Define variable ridgeConvergence
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'ridgeConvergence'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ridgeConvergence', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ridgeConvergence', r1Ptr)

! Define variable ridgeShear
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'ridgeShear'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ridgeShear', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ridgeShear', r1Ptr)

! Define variable areaLossRidge
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'areaLossRidge'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'areaLossRidge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'areaLossRidge', r1Ptr)

! Define variable areaGainRidge
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'areaGainRidge'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'areaGainRidge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'areaGainRidge', r1Ptr)

! Define variable iceVolumeRidged
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'iceVolumeRidged'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceVolumeRidged', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceVolumeRidged', r1Ptr)

! Define variable openingRateRidge
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'openingRateRidge'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'openingRateRidge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'openingRateRidge', r1Ptr)

! Define variable ridgeParticipationFunction
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'ridgeParticipationFunction'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ridgeParticipationFunction', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ridgeParticipationFunction', r2Ptr)

! Define variable ratioRidgeThicknessToIce
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'ratioRidgeThicknessToIce'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ratioRidgeThicknessToIce', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ratioRidgeThicknessToIce', r2Ptr)

! Define variable fractionNewRidgeArea
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'fractionNewRidgeArea'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'fractionNewRidgeArea', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'fractionNewRidgeArea', r2Ptr)

! Define variable fractionNewRidgeVolume
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'fractionNewRidgeVolume'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'fractionNewRidgeVolume', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'fractionNewRidgeVolume', r2Ptr)

! Define variable areaLossRidgeCategory
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'areaLossRidgeCategory'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'areaLossRidgeCategory', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'areaLossRidgeCategory', r2Ptr)

! Define variable areaGainRidgeCategory
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'areaGainRidgeCategory'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'areaGainRidgeCategory', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'areaGainRidgeCategory', r2Ptr)

! Define variable iceVolumeRidgedCategory
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'iceVolumeRidgedCategory'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceVolumeRidgedCategory', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'iceVolumeRidgedCategory', r2Ptr)

! Define variable raftingIceArea
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'raftingIceArea'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'raftingIceArea', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'raftingIceArea', r2Ptr)

! Define variable raftingIceVolume
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'raftingIceVolume'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'raftingIceVolume', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'raftingIceVolume', r2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_ridging


   subroutine seaice_generate_pool_melt_growth_rates(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'melt_growth_rates', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'melt_growth_rates', newSubPool)

! Define variable lateralIceMeltFraction
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'lateralIceMeltFraction'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'lateralIceMeltFraction', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'lateralIceMeltFraction', r1Ptr)

! Define variable surfaceIceMelt
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'surfaceIceMelt'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'surfaceIceMelt', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceIceMelt', r1Ptr)

! Define variable surfaceIceMeltCategory
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'surfaceIceMeltCategory'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'surfaceIceMeltCategory', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceIceMeltCategory', r2Ptr)

! Define variable basalIceMelt
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'basalIceMelt'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'basalIceMelt', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'basalIceMelt', r1Ptr)

! Define variable basalIceMeltCategory
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'basalIceMeltCategory'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'basalIceMeltCategory', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'basalIceMeltCategory', r2Ptr)

! Define variable lateralIceMelt
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'lateralIceMelt'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'lateralIceMelt', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'lateralIceMelt', r1Ptr)

! Define variable snowMelt
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'snowMelt'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowMelt', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'snowMelt', r1Ptr)

! Define variable snowMeltCategory
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'snowMeltCategory'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowMeltCategory', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'snowMeltCategory', r2Ptr)

! Define variable congelation
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'congelation'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'congelation', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'congelation', r1Ptr)

! Define variable congelationCategory
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'congelationCategory'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'congelationCategory', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'congelationCategory', r2Ptr)

! Define variable snowiceFormation
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'snowiceFormation'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowiceFormation', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'snowiceFormation', r1Ptr)

! Define variable snowiceFormationCategory
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'snowiceFormationCategory'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowiceFormationCategory', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'snowiceFormationCategory', r2Ptr)

! Define variable snowThicknessChange
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'snowThicknessChange'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowThicknessChange', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'snowThicknessChange', r1Ptr)

! Define variable snowThicknessChangeCategory
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'snowThicknessChangeCategory'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowThicknessChangeCategory', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'snowThicknessChangeCategory', r2Ptr)

! Define variable frazilFormation
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'frazilFormation'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'frazilFormation', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'frazilFormation', r1Ptr)

! Define variable frazilGrowthDiagnostic
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'frazilGrowthDiagnostic'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'frazilGrowthDiagnostic', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'frazilGrowthDiagnostic', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_melt_growth_rates


   subroutine seaice_generate_pool_atmos_fluxes(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'atmos_fluxes', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'atmos_fluxes', newSubPool)

! Define variable surfaceHeatFlux
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'surfaceHeatFlux'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'surfaceHeatFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceHeatFlux', r1Ptr)

! Define variable surfaceHeatFluxCategory
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'surfaceHeatFluxCategory'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'surfaceHeatFluxCategory', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceHeatFluxCategory', r2Ptr)

! Define variable surfaceConductiveFlux
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'surfaceConductiveFlux'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'surfaceConductiveFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceConductiveFlux', r1Ptr)

! Define variable surfaceConductiveFluxCategory
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'surfaceConductiveFluxCategory'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'surfaceConductiveFluxCategory', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceConductiveFluxCategory', r2Ptr)

! Define variable longwaveUp
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'longwaveUp'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'longwaveUp', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'longwaveUp', r1Ptr)

! Define variable sensibleHeatFlux
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'sensibleHeatFlux'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'sensibleHeatFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'sensibleHeatFlux', r1Ptr)

! Define variable sensibleHeatFluxCategory
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'sensibleHeatFluxCategory'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'sensibleHeatFluxCategory', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'sensibleHeatFluxCategory', r2Ptr)

! Define variable latentHeatFlux
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'latentHeatFlux'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'latentHeatFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'latentHeatFlux', r1Ptr)

! Define variable latentHeatFluxCategory
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'latentHeatFluxCategory'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'latentHeatFluxCategory', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'latentHeatFluxCategory', r2Ptr)

! Define variable evaporativeWaterFlux
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'evaporativeWaterFlux'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'evaporativeWaterFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'evaporativeWaterFlux', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_atmos_fluxes


   subroutine seaice_generate_pool_ocean_fluxes(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'ocean_fluxes', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'ocean_fluxes', newSubPool)

! Define variable oceanFreshWaterFlux
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanFreshWaterFlux'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanFreshWaterFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanFreshWaterFlux', r1Ptr)

! Define variable oceanSaltFlux
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanSaltFlux'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanSaltFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanSaltFlux', r1Ptr)

! Define variable oceanHeatFlux
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanHeatFlux'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanHeatFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanHeatFlux', r1Ptr)

! Define variable oceanShortwaveFlux
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanShortwaveFlux'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanShortwaveFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanShortwaveFlux', r1Ptr)

! Define variable oceanFreshWaterFluxArea
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanFreshWaterFluxArea'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanFreshWaterFluxArea', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanFreshWaterFluxArea', r1Ptr)

! Define variable oceanSaltFluxArea
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanSaltFluxArea'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanSaltFluxArea', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanSaltFluxArea', r1Ptr)

! Define variable oceanHeatFluxArea
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanHeatFluxArea'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanHeatFluxArea', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanHeatFluxArea', r1Ptr)

! Define variable oceanShortwaveFluxArea
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanShortwaveFluxArea'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanShortwaveFluxArea', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanShortwaveFluxArea', r1Ptr)

! Define variable oceanHeatFluxIceBottom
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanHeatFluxIceBottom'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanHeatFluxIceBottom', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanHeatFluxIceBottom', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_ocean_fluxes


   subroutine seaice_generate_pool_berg_forcing(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'berg_forcing', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'berg_forcing', newSubPool)

! Define variable bergFreshwaterFluxData
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'bergFreshwaterFluxData'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgBergsActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'bergFreshwaterFluxData', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'bergFreshwaterFluxData', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_berg_forcing


   subroutine seaice_generate_pool_berg_fluxes(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'berg_fluxes', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'berg_fluxes', newSubPool)

! Define variable bergFreshwaterFlux
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'bergFreshwaterFlux'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgBergsActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'bergFreshwaterFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'bergFreshwaterFlux', r1Ptr)

! Define variable bergLatentHeatFlux
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'bergLatentHeatFlux'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgBergsActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'bergLatentHeatFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'bergLatentHeatFlux', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_berg_fluxes


   subroutine seaice_generate_pool_ocean_atmosphere(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'ocean_atmosphere', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'ocean_atmosphere', newSubPool)

! Define variable airStressOceanU
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'airStressOceanU'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'airStressOceanU', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'airStressOceanU', r1Ptr)

! Define variable airStressOceanV
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'airStressOceanV'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'airStressOceanV', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'airStressOceanV', r1Ptr)

! Define variable atmosReferenceTemperature2mOcean
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'atmosReferenceTemperature2mOcean'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'atmosReferenceTemperature2mOcean', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'atmosReferenceTemperature2mOcean', r1Ptr)

! Define variable atmosReferenceHumidity2mOcean
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'atmosReferenceHumidity2mOcean'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'atmosReferenceHumidity2mOcean', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'atmosReferenceHumidity2mOcean', r1Ptr)

! Define variable albedoVisibleDirectOcean
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'albedoVisibleDirectOcean'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'albedoVisibleDirectOcean', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'albedoVisibleDirectOcean', r1Ptr)

! Define variable albedoVisibleDiffuseOcean
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'albedoVisibleDiffuseOcean'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'albedoVisibleDiffuseOcean', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'albedoVisibleDiffuseOcean', r1Ptr)

! Define variable albedoIRDirectOcean
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'albedoIRDirectOcean'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'albedoIRDirectOcean', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'albedoIRDirectOcean', r1Ptr)

! Define variable albedoIRDiffuseOcean
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'albedoIRDiffuseOcean'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'albedoIRDiffuseOcean', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'albedoIRDiffuseOcean', r1Ptr)

! Define variable longwaveUpOcean
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'longwaveUpOcean'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'longwaveUpOcean', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'longwaveUpOcean', r1Ptr)

! Define variable sensibleHeatFluxOcean
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'sensibleHeatFluxOcean'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'sensibleHeatFluxOcean', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'sensibleHeatFluxOcean', r1Ptr)

! Define variable latentHeatFluxOcean
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'latentHeatFluxOcean'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'latentHeatFluxOcean', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'latentHeatFluxOcean', r1Ptr)

! Define variable evaporativeWaterFluxOcean
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'evaporativeWaterFluxOcean'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'evaporativeWaterFluxOcean', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'evaporativeWaterFluxOcean', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_ocean_atmosphere


   subroutine seaice_generate_pool_shortwave(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'shortwave', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'shortwave', newSubPool)

! Define variable dayOfNextShortwaveCalculation
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'dayOfNextShortwaveCalculation'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (pkgColumnPackageActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'dayOfNextShortwaveCalculation', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'dayOfNextShortwaveCalculation', r0Ptr)

! Define variable solarZenithAngleCosine
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'solarZenithAngleCosine'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'solarZenithAngleCosine', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'solarZenithAngleCosine', r1Ptr)

! Define variable albedoVisibleDirectCategory
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'albedoVisibleDirectCategory'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'albedoVisibleDirectCategory', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'albedoVisibleDirectCategory', r2Ptr)

! Define variable albedoVisibleDiffuseCategory
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'albedoVisibleDiffuseCategory'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'albedoVisibleDiffuseCategory', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'albedoVisibleDiffuseCategory', r2Ptr)

! Define variable albedoIRDirectCategory
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'albedoIRDirectCategory'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'albedoIRDirectCategory', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'albedoIRDirectCategory', r2Ptr)

! Define variable albedoIRDiffuseCategory
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'albedoIRDiffuseCategory'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'albedoIRDiffuseCategory', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'albedoIRDiffuseCategory', r2Ptr)

! Define variable albedoVisibleDirectCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'albedoVisibleDirectCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'albedoVisibleDirectCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'albedoVisibleDirectCell', r1Ptr)

! Define variable albedoVisibleDiffuseCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'albedoVisibleDiffuseCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'albedoVisibleDiffuseCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'albedoVisibleDiffuseCell', r1Ptr)

! Define variable albedoIRDirectCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'albedoIRDirectCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'albedoIRDirectCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'albedoIRDirectCell', r1Ptr)

! Define variable albedoIRDiffuseCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'albedoIRDiffuseCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'albedoIRDiffuseCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'albedoIRDiffuseCell', r1Ptr)

! Define variable albedoVisibleDirectArea
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'albedoVisibleDirectArea'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'albedoVisibleDirectArea', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'albedoVisibleDirectArea', r1Ptr)

! Define variable albedoVisibleDiffuseArea
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'albedoVisibleDiffuseArea'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'albedoVisibleDiffuseArea', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'albedoVisibleDiffuseArea', r1Ptr)

! Define variable albedoIRDirectArea
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'albedoIRDirectArea'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'albedoIRDirectArea', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'albedoIRDirectArea', r1Ptr)

! Define variable albedoIRDiffuseArea
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'albedoIRDiffuseArea'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'albedoIRDiffuseArea', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'albedoIRDiffuseArea', r1Ptr)

! Define variable shortwaveScalingFactor
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'shortwaveScalingFactor'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'shortwaveScalingFactor', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'shortwaveScalingFactor', r1Ptr)

! Define variable surfaceShortwaveFlux
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'surfaceShortwaveFlux'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'surfaceShortwaveFlux', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceShortwaveFlux', r2Ptr)

! Define variable interiorShortwaveFlux
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'interiorShortwaveFlux'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'interiorShortwaveFlux', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'interiorShortwaveFlux', r2Ptr)

! Define variable penetratingShortwaveFlux
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'penetratingShortwaveFlux'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'penetratingShortwaveFlux', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'penetratingShortwaveFlux', r2Ptr)

! Define variable shortwaveLayerPenetration
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'shortwaveLayerPenetration'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .true.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nIceLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnPackageActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'shortwaveLayerPenetration', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'shortwaveLayerPenetration', r3Ptr)

! Define variable absorbedShortwaveFlux
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'absorbedShortwaveFlux'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'absorbedShortwaveFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'absorbedShortwaveFlux', r1Ptr)

! Define variable absorbedShortwaveSnowLayer
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'absorbedShortwaveSnowLayer'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .true.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnPackageActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'absorbedShortwaveSnowLayer', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'absorbedShortwaveSnowLayer', r3Ptr)

! Define variable absorbedShortwaveIceLayer
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'absorbedShortwaveIceLayer'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .true.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnPackageActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'absorbedShortwaveIceLayer', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'absorbedShortwaveIceLayer', r3Ptr)

! Define variable bareIceAlbedoCategory
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'bareIceAlbedoCategory'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'bareIceAlbedoCategory', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'bareIceAlbedoCategory', r2Ptr)

! Define variable snowAlbedoCategory
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'snowAlbedoCategory'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowAlbedoCategory', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'snowAlbedoCategory', r2Ptr)

! Define variable pondAlbedoCategory
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'pondAlbedoCategory'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondAlbedoCategory', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'pondAlbedoCategory', r2Ptr)

! Define variable bareIceAlbedoCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'bareIceAlbedoCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'bareIceAlbedoCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'bareIceAlbedoCell', r1Ptr)

! Define variable snowAlbedoCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'snowAlbedoCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowAlbedoCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'snowAlbedoCell', r1Ptr)

! Define variable pondAlbedoCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'pondAlbedoCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondAlbedoCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'pondAlbedoCell', r1Ptr)

! Define variable effectivePondAreaCategory
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'effectivePondAreaCategory'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'effectivePondAreaCategory', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'effectivePondAreaCategory', r2Ptr)

! Define variable effectivePondAreaCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'effectivePondAreaCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'effectivePondAreaCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'effectivePondAreaCell', r1Ptr)

! Define variable snowFractionCategory
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'snowFractionCategory'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowFractionCategory', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'snowFractionCategory', r2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_shortwave


   subroutine seaice_generate_pool_drag(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'drag', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'drag', newSubPool)

! Define variable airOceanDragCoefficientRatio
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'airOceanDragCoefficientRatio'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'airOceanDragCoefficientRatio', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'airOceanDragCoefficientRatio', r1Ptr)

! Define variable oceanDragCoefficient
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanDragCoefficient'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanDragCoefficient', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanDragCoefficient', r1Ptr)

! Define variable oceanDragCoefficientSkin
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanDragCoefficientSkin'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnFormDragActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanDragCoefficientSkin', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanDragCoefficientSkin', r1Ptr)

! Define variable oceanDragCoefficientFloe
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanDragCoefficientFloe'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnFormDragActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanDragCoefficientFloe', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanDragCoefficientFloe', r1Ptr)

! Define variable oceanDragCoefficientKeel
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanDragCoefficientKeel'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnFormDragActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanDragCoefficientKeel', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanDragCoefficientKeel', r1Ptr)

! Define variable airDragCoefficient
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'airDragCoefficient'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'airDragCoefficient', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'airDragCoefficient', r1Ptr)

! Define variable airDragCoefficientSkin
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'airDragCoefficientSkin'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnFormDragActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'airDragCoefficientSkin', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'airDragCoefficientSkin', r1Ptr)

! Define variable airDragCoefficientFloe
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'airDragCoefficientFloe'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnFormDragActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'airDragCoefficientFloe', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'airDragCoefficientFloe', r1Ptr)

! Define variable airDragCoefficientPond
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'airDragCoefficientPond'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnFormDragActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'airDragCoefficientPond', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'airDragCoefficientPond', r1Ptr)

! Define variable airDragCoefficientRidge
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'airDragCoefficientRidge'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnFormDragActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'airDragCoefficientRidge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'airDragCoefficientRidge', r1Ptr)

! Define variable dragFreeboard
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'dragFreeboard'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnFormDragActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'dragFreeboard', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'dragFreeboard', r1Ptr)

! Define variable dragIceSnowDraft
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'dragIceSnowDraft'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnFormDragActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'dragIceSnowDraft', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'dragIceSnowDraft', r1Ptr)

! Define variable dragRidgeHeight
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'dragRidgeHeight'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnFormDragActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'dragRidgeHeight', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'dragRidgeHeight', r1Ptr)

! Define variable dragRidgeSeparation
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'dragRidgeSeparation'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnFormDragActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'dragRidgeSeparation', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'dragRidgeSeparation', r1Ptr)

! Define variable dragKeelDepth
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'dragKeelDepth'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnFormDragActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'dragKeelDepth', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'dragKeelDepth', r1Ptr)

! Define variable dragKeelSeparation
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'dragKeelSeparation'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnFormDragActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'dragKeelSeparation', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'dragKeelSeparation', r1Ptr)

! Define variable dragFloeLength
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'dragFloeLength'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnFormDragActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'dragFloeLength', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'dragFloeLength', r1Ptr)

! Define variable dragFloeSeparation
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'dragFloeSeparation'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnFormDragActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'dragFloeSeparation', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'dragFloeSeparation', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_drag


   subroutine seaice_generate_pool_ponds(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'ponds', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'ponds', newSubPool)

! Define variable pondFreshWaterFlux
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'pondFreshWaterFlux'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondFreshWaterFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'pondFreshWaterFlux', r1Ptr)

! Define variable pondSnowDepthDifference
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'pondSnowDepthDifference'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondSnowDepthDifference', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'pondSnowDepthDifference', r2Ptr)

! Define variable pondLidMeltFluxFraction
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'pondLidMeltFluxFraction'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pondLidMeltFluxFraction', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'pondLidMeltFluxFraction', r2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_ponds


   subroutine seaice_generate_pool_snow(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'snow', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'snow', newSubPool)

! Define variable snowDensityViaContent
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'snowDensityViaContent'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'kg/m^3')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowDensityViaContent', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'snowDensityViaContent', r1Ptr)

! Define variable snowDensityViaCompaction
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'snowDensityViaCompaction'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'kg/m^3')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowDensityViaCompaction', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'snowDensityViaCompaction', r1Ptr)

! Define variable snowLossToLeads
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'snowLossToLeads'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'kg/m^2/s')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowLossToLeads', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'snowLossToLeads', r1Ptr)

! Define variable snowMeltMassCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'snowMeltMassCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'kg/m^2/d')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowMeltMassCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'snowMeltMassCell', r1Ptr)

! Define variable snowMeltMassCategory
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'snowMeltMassCategory'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'kg/m^2')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowMeltMassCategory', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'snowMeltMassCategory', r2Ptr)

! Define variable snowRadiusInStandardRadiationSchemeCategory
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'snowRadiusInStandardRadiationSchemeCategory'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'um')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowRadiusInStandardRadiationSchemeCategory', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'snowRadiusInStandardRadiationSchemeCategory', r2Ptr)

! Define variable snowRadiusInStandardRadiationScheme
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'snowRadiusInStandardRadiationScheme'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'um')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowRadiusInStandardRadiationScheme', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'snowRadiusInStandardRadiationScheme', r1Ptr)

! Define variable snowEmpiricalGrowthParameterTau
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowEmpiricalGrowthParameterTau'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .false.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nGrainAgingSnowDensity'
      r3Ptr % dimNames(2) = 'nGrainAgingTempGradient'
      r3Ptr % dimNames(3) = 'nGrainAgingTemperature'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      call mpas_add_att(r3Ptr % attLists(1) % attList, 'units', 'um')
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnPackageActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowEmpiricalGrowthParameterTau', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowEmpiricalGrowthParameterTau', r3Ptr)

! Define variable snowEmpiricalGrowthParameterKappa
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowEmpiricalGrowthParameterKappa'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .false.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nGrainAgingSnowDensity'
      r3Ptr % dimNames(2) = 'nGrainAgingTempGradient'
      r3Ptr % dimNames(3) = 'nGrainAgingTemperature'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      call mpas_add_att(r3Ptr % attLists(1) % attList, 'units', 'none')
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnPackageActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowEmpiricalGrowthParameterKappa', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowEmpiricalGrowthParameterKappa', r3Ptr)

! Define variable snowPropertyRate
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowPropertyRate'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .false.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nGrainAgingSnowDensity'
      r3Ptr % dimNames(2) = 'nGrainAgingTempGradient'
      r3Ptr % dimNames(3) = 'nGrainAgingTemperature'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      call mpas_add_att(r3Ptr % attLists(1) % attList, 'units', 'um/hr')
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnPackageActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowPropertyRate', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowPropertyRate', r3Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_snow


   subroutine seaice_generate_pool_aerosols(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'aerosols', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'aerosols', newSubPool)

! Define variable atmosAerosolFlux
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'atmosAerosolFlux'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nAerosols'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'atmosAerosolFlux', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'atmosAerosolFlux', r2Ptr)

! Define variable oceanAerosolFlux
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'oceanAerosolFlux'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nAerosols'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanAerosolFlux', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanAerosolFlux', r2Ptr)

! Define variable aerosolMassExtinctionCrossSection
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'aerosolMassExtinctionCrossSection'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .false.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nSpectralIntervals'
      r2Ptr % dimNames(2) = 'maxAerosolType'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'aerosolMassExtinctionCrossSection', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'aerosolMassExtinctionCrossSection', r2Ptr)

! Define variable aerosolSingleScatterAlbedo
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'aerosolSingleScatterAlbedo'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .false.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nSpectralIntervals'
      r2Ptr % dimNames(2) = 'maxAerosolType'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'aerosolSingleScatterAlbedo', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'aerosolSingleScatterAlbedo', r2Ptr)

! Define variable aerosolAsymmetryParameter
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'aerosolAsymmetryParameter'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .false.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nSpectralIntervals'
      r2Ptr % dimNames(2) = 'maxAerosolType'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'aerosolAsymmetryParameter', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'aerosolAsymmetryParameter', r2Ptr)

! Define variable modalMassExtinctionCrossSection
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'modalMassExtinctionCrossSection'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .false.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nSpectralIntervals'
      r2Ptr % dimNames(2) = 'nModal1'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'modalMassExtinctionCrossSection', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'modalMassExtinctionCrossSection', r2Ptr)

! Define variable modalSingleScatterAlbedo
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'modalSingleScatterAlbedo'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .false.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nSpectralIntervals'
      r2Ptr % dimNames(2) = 'nModal1'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'modalSingleScatterAlbedo', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'modalSingleScatterAlbedo', r2Ptr)

! Define variable modalAsymmetryParameter
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'modalAsymmetryParameter'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .false.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nSpectralIntervals'
      r2Ptr % dimNames(2) = 'nModal1'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'modalAsymmetryParameter', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'modalAsymmetryParameter', r2Ptr)

! Define variable modalBCabsorptionParameter
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'modalBCabsorptionParameter'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .false.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSpectralIntervals'
      r3Ptr % dimNames(2) = 'nModal1'
      r3Ptr % dimNames(3) = 'nModal2'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnPackageActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'modalBCabsorptionParameter', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'modalBCabsorptionParameter', r3Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_aerosols


   subroutine seaice_generate_pool_biogeochemistry(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'biogeochemistry', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'biogeochemistry', newSubPool)

! Define variable newlyFormedIce
      allocate(i2Ptr)

! Setting up time level 1
      i2Ptr % fieldName = 'newlyFormedIce'
      i2Ptr % isVarArray = .false.
      i2Ptr % isDecomposed = .true.
      i2Ptr % hasTimeDimension = .false.
      i2Ptr % isPersistent = .true.
      i2Ptr % isActive = .false.
! Setting up dimensions
      i2Ptr % dimNames(1) = 'nCategories'
      i2Ptr % dimNames(2) = 'nCells'
      i2Ptr % defaultValue = 0
      allocate(i2Ptr % attLists(1))
      allocate(i2Ptr % attLists(1) % attList)
      i2Ptr % missingValue = MPAS_INT_FILLVAL
      i2Ptr % block => block

      if (pkgColumnBiogeochemistryActive .or. pkgColumnPackageActive) then
         i2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'newlyFormedIce', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'newlyFormedIce', i2Ptr)

! Define variable rayleighCriteriaReal
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'rayleighCriteriaReal'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'rayleighCriteriaReal', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'rayleighCriteriaReal', r1Ptr)

! Define variable atmosBioFluxes
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'atmosBioFluxes'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nZBGCTracers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'atmosBioFluxes', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'atmosBioFluxes', r2Ptr)

! Define variable atmosIceBioFluxes
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'atmosIceBioFluxes'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nZBGCTracers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'atmosIceBioFluxes', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'atmosIceBioFluxes', r2Ptr)

! Define variable snowIceBioFluxes
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'snowIceBioFluxes'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nZBGCTracers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowIceBioFluxes', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'snowIceBioFluxes', r2Ptr)

! Define variable atmosBlackCarbonFlux
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'atmosBlackCarbonFlux'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxBCType'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'atmosBlackCarbonFlux', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'atmosBlackCarbonFlux', r2Ptr)

! Define variable atmosDustFlux
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'atmosDustFlux'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxDustType'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'atmosDustFlux', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'atmosDustFlux', r2Ptr)

! Define variable totalCarbonContentCell
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'totalCarbonContentCell'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'mmol/m^2')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Concentration of carbon in the ice column')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive .or. pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'totalCarbonContentCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'totalCarbonContentCell', r1Ptr)

! Define variable totalOceanCarbonFlux
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'totalOceanCarbonFlux'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'mmol/m^2/s')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Total ocean carbon flux (positive into the ocean)')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive .or. pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'totalOceanCarbonFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'totalOceanCarbonFlux', r1Ptr)

! Define variable oceanBioFluxes
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'oceanBioFluxes'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nZBGCTracers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'mmol/m2/s')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Tracers are ordered: diatom nitrogen, smallPlankton nitrogen, '&
//'phaeocystis nitrogen, nitrate, polysaccarid carbon, lipid carbon, ammonium, silicate, DMSPp, DMSPd, DMS, Nonreactive nitrate, '&
//'Protein nitrogen, dissolved iron in umol/m2/s, particulate iron in umol/m2/s, humic carbon, black carbon1 in mg/m2/s, black '&
//'carbon2 in mg/m2/s, dust1 in mg/m2/s, dust2 in mg/m2/s, dust3 in mg/m2/s, dust4 in mg/m2/s')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive .or. pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanBioFluxes', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanBioFluxes', r2Ptr)

! Define variable oceanBioFluxesCategory
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'oceanBioFluxesCategory'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .true.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nZBGCTracers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      call mpas_add_att(r3Ptr % attLists(1) % attList, 'units', 'mmol/m2/s')
      call mpas_add_att(r3Ptr % attLists(1) % attList, 'long_name', 'Tracers are ordered: diatom nitrogen, smallPlankton nitrogen, '&
//'phaeocystis nitrogen, nitrate, polysaccarid carbon, lipid carbon, ammonium, silicate, DMSPp, DMSPd, DMS, Nonreactive nitrate, '&
//'Protein nitrogen, dissolved iron in umol/m2/s, particulate iron in umol/m2/s, humic carbon, black carbon1 in mg/m2/s, black '&
//'carbon2 in mg/m2/s, dust1 in mg/m2/s, dust2 in mg/m2/s, dust3 in mg/m2/s, dust4 in mg/m2/s')
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnBiogeochemistryActive .or. pkgColumnPackageActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanBioFluxesCategory', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanBioFluxesCategory', r3Ptr)

! Define variable oceanBioConcentrations
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'oceanBioConcentrations'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nZBGCTracers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'mmol/m3')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Tracers are ordered: diatom nitrogen, smallPlankton nitrogen, '&
//'phaeocystis nitrogen, nitrate, polysaccarid carbon, lipid carbon, ammonium, silicate, DMSPp, DMSPd, DMS, Nonreactive nitrate, '&
//'Protein nitrogen, dissolved iron in umol/m3, particulate iron in umol/m3, humic carbon, black carbon1 in mg/m3, black carbon2 '&
//'in mg/m3,dust1 in mg/m3, dust2 in mg/m3, dust3 in mg/m3, dust4 in mg/m3')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive .or. pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanBioConcentrations', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanBioConcentrations', r2Ptr)

! Define variable oceanAlgaeConc
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'oceanAlgaeConc'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxAlgaeType'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanAlgaeConc', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanAlgaeConc', r2Ptr)

! Define variable oceanDOCConc
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'oceanDOCConc'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxDOCType'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanDOCConc', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanDOCConc', r2Ptr)

! Define variable oceanDICConc
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'oceanDICConc'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxDICType'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanDICConc', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanDICConc', r2Ptr)

! Define variable oceanDONConc
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'oceanDONConc'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxDONType'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanDONConc', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanDONConc', r2Ptr)

! Define variable oceanNitrateConc
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanNitrateConc'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanNitrateConc', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanNitrateConc', r1Ptr)

! Define variable oceanSilicateConc
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanSilicateConc'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanSilicateConc', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanSilicateConc', r1Ptr)

! Define variable oceanAmmoniumConc
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanAmmoniumConc'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanAmmoniumConc', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanAmmoniumConc', r1Ptr)

! Define variable oceanDMSConc
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanDMSConc'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanDMSConc', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanDMSConc', r1Ptr)

! Define variable oceanDMSPConc
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanDMSPConc'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanDMSPConc', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanDMSPConc', r1Ptr)

! Define variable oceanHumicsConc
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanHumicsConc'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanHumicsConc', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanHumicsConc', r1Ptr)

! Define variable oceanParticulateIronConc
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'oceanParticulateIronConc'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxIronType'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanParticulateIronConc', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanParticulateIronConc', r2Ptr)

! Define variable oceanDissolvedIronConc
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'oceanDissolvedIronConc'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxIronType'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanDissolvedIronConc', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanDissolvedIronConc', r2Ptr)

! Define variable oceanZAerosolConc
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'oceanZAerosolConc'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxAerosolType'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanZAerosolConc', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanZAerosolConc', r2Ptr)

! Define variable oceanAlgaeFlux
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'oceanAlgaeFlux'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxAlgaeType'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanAlgaeFlux', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanAlgaeFlux', r2Ptr)

! Define variable oceanDOCFlux
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'oceanDOCFlux'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxDOCType'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanDOCFlux', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanDOCFlux', r2Ptr)

! Define variable oceanDICFlux
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'oceanDICFlux'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxDICType'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanDICFlux', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanDICFlux', r2Ptr)

! Define variable oceanDONFlux
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'oceanDONFlux'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxDONType'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanDONFlux', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanDONFlux', r2Ptr)

! Define variable oceanNitrateFlux
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanNitrateFlux'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanNitrateFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanNitrateFlux', r1Ptr)

! Define variable oceanSilicateFlux
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanSilicateFlux'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanSilicateFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanSilicateFlux', r1Ptr)

! Define variable oceanAmmoniumFlux
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanAmmoniumFlux'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanAmmoniumFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanAmmoniumFlux', r1Ptr)

! Define variable oceanDMSFlux
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanDMSFlux'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanDMSFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanDMSFlux', r1Ptr)

! Define variable oceanDMSPpFlux
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanDMSPpFlux'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanDMSPpFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanDMSPpFlux', r1Ptr)

! Define variable oceanDMSPdFlux
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanDMSPdFlux'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanDMSPdFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanDMSPdFlux', r1Ptr)

! Define variable oceanHumicsFlux
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanHumicsFlux'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanHumicsFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanHumicsFlux', r1Ptr)

! Define variable oceanParticulateIronFlux
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'oceanParticulateIronFlux'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxIronType'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanParticulateIronFlux', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanParticulateIronFlux', r2Ptr)

! Define variable oceanDissolvedIronFlux
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'oceanDissolvedIronFlux'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'maxIronType'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanDissolvedIronFlux', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanDissolvedIronFlux', r2Ptr)

! Define variable oceanDustIronFlux
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanDustIronFlux'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanDustIronFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanDustIronFlux', r1Ptr)

! Define variable bioTracerShortwave
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'bioTracerShortwave'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nShortwaveBio'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnBiogeochemistryActive .or. pkgColumnPackageActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'bioTracerShortwave', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'bioTracerShortwave', r3Ptr)

! Define variable bioPorosity
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'bioPorosity'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .true.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP2'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'bioPorosity', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'bioPorosity', r3Ptr)

! Define variable bioTemperature
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'bioTemperature'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP2'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'bioTemperature', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'bioTemperature', r3Ptr)

! Define variable bioShortwaveFlux
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'bioShortwaveFlux'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .true.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      call mpas_add_att(r3Ptr % attLists(1) % attList, 'units', 'W/m^2')
      call mpas_add_att(r3Ptr % attLists(1) % attList, 'long_name', 'Shortwave radiative flux on the vertical biology grid per '&
//'category')
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'bioShortwaveFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'bioShortwaveFlux', r3Ptr)

! Define variable bioShortwaveFluxCell
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'bioShortwaveFluxCell'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nBioLayersP1'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'W/m^2')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Averaged cell shortwave radiative flux on the vertical '&
//'biology grid')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'bioShortwaveFluxCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'bioShortwaveFluxCell', r2Ptr)

! Define variable bioDiffusivity
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'bioDiffusivity'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'bioDiffusivity', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'bioDiffusivity', r3Ptr)

! Define variable bioPermeability
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'bioPermeability'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP1'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'bioPermeability', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'bioPermeability', r3Ptr)

! Define variable zSalinityFlux
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'zSalinityFlux'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive .or. pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'zSalinityFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zSalinityFlux', r1Ptr)

! Define variable zSalinityGDFlux
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'zSalinityGDFlux'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive .or. pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'zSalinityGDFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zSalinityGDFlux', r1Ptr)

! Define variable zSalinityFluxCat
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'zSalinityFluxCat'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive .or. pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'zSalinityFluxCat', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'zSalinityFluxCat', r2Ptr)

! Define variable zSalinityGDFluxCat
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'zSalinityGDFluxCat'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive .or. pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'zSalinityGDFluxCat', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'zSalinityGDFluxCat', r2Ptr)

! Define variable darcyVelocityBio
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'darcyVelocityBio'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'darcyVelocityBio', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'darcyVelocityBio', r2Ptr)

! Define variable brineTopChange
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'brineTopChange'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerBrineActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'brineTopChange', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'brineTopChange', r2Ptr)

! Define variable brineBottomChange
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'brineBottomChange'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerBrineActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'brineBottomChange', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'brineBottomChange', r2Ptr)

! Define variable zSalinityIceDensity
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'zSalinityIceDensity'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'zSalinityIceDensity', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'zSalinityIceDensity', r2Ptr)

! Define variable peakVerticalAlgalConc
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'peakVerticalAlgalConc'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nAlgae'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgTracerVerticalAlgaeActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'peakVerticalAlgalConc', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'peakVerticalAlgalConc', r2Ptr)

! Define variable netSpecificAlgalGrowthRate
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'netSpecificAlgalGrowthRate'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', '1/s')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Specific algal growth rate per grid cell')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'netSpecificAlgalGrowthRate', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'netSpecificAlgalGrowthRate', r1Ptr)

! Define variable verticalNitrogenLosses
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'verticalNitrogenLosses'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .true.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nBioLayersP3'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalNitrogenLosses', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalNitrogenLosses', r3Ptr)

! Define variable netNitrateUptake
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'netNitrateUptake'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'mmol/m^2/d')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Total rate of nitrate uptake by algae weighted by ice area')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'netNitrateUptake', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'netNitrateUptake', r1Ptr)

! Define variable netAmmoniumUptake
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'netAmmoniumUptake'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'mmol/m^2/d')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Total rate of ammonium uptake by algae weighted by ice area')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'netAmmoniumUptake', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'netAmmoniumUptake', r1Ptr)

! Define variable primaryProduction
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'primaryProduction'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'mg carbon/m^2/d')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Average total primary production in a grid cell')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'primaryProduction', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'primaryProduction', r1Ptr)

! Define variable totalSkeletalAlgae
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'totalSkeletalAlgae'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'totalSkeletalAlgae', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'totalSkeletalAlgae', r1Ptr)

! Define variable totalVerticalBiologyIce
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'totalVerticalBiologyIce'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nZBGCTracers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'mmol/m2')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Tracers are ordered: diatom nitrogen, smallPlankton nitrogen, '&
//'phaeocystis nitrogen, nitrate, polysaccarid carbon, lipid carbon, ammonium, silicate, DMSPp, DMSPd, DMS, Nonreactive nitrate, '&
//'Protein nitrogen, dissolved iron in umol/m2, particulate iron in umol/m2, humic carbon, black carbon1 in mg/m2, black carbon2 '&
//'in mg/m2,dust1 in mg/m2, dust2 in mg/m2, dust3 in mg/m2, dust4 in mg/m2')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'totalVerticalBiologyIce', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'totalVerticalBiologyIce', r2Ptr)

! Define variable totalVerticalBiologySnow
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'totalVerticalBiologySnow'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nZBGCTracers'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'mmol/m2')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'Tracers are ordered: diatom nitrogen, smallPlankton nitrogen, '&
//'phaeocystis nitrogen, nitrate, polysaccarid carbon, lipid carbon, ammonium, silicate, DMSPp, DMSPd, DMS, Nonreactive nitrate, '&
//'Protein nitrogen, dissolved iron in umol/m2, particulate iron in umol/m2, humic carbon, black carbon1 in mg/m2, black carbon2 '&
//'in mg/m2,dust1 in mg/m2, dust2 in mg/m2, dust3 in mg/m2, dust4 in mg/m2')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'totalVerticalBiologySnow', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'totalVerticalBiologySnow', r2Ptr)

! Define variable totalVerticalSalinity
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'totalVerticalSalinity'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgTracerZSalinityActive .or. pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'totalVerticalSalinity', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'totalVerticalSalinity', r1Ptr)

! Define variable totalChlorophyll
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'totalChlorophyll'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'mg/m^2')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Ice integrated chlorophyll concentration per cell')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'totalChlorophyll', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'totalChlorophyll', r1Ptr)

! Define variable totalNitrate
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'totalNitrate'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'mmol/m^3')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Ice integrated nitrate concentration per cell')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgTracerSkeletalNitrateActive .or. pkgTracerVerticalNitrateActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'totalNitrate', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'totalNitrate', r1Ptr)

! Define variable netBrineHeight
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'netBrineHeight'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Cell average brine height')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive .or. pkgTracerBrineActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'netBrineHeight', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'netBrineHeight', r1Ptr)

! Define variable biologyGrid
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'biologyGrid'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .false.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nBioLayersP2'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive .or. pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'biologyGrid', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'biologyGrid', r1Ptr)

! Define variable interfaceBiologyGrid
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'interfaceBiologyGrid'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .false.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nBioLayersP1'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive .or. pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'interfaceBiologyGrid', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'interfaceBiologyGrid', r1Ptr)

! Define variable verticalGrid
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'verticalGrid'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .false.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nIceLayersP1'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive .or. pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalGrid', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalGrid', r1Ptr)

! Define variable interfaceGrid
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'interfaceGrid'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .false.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nIceLayersP1'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'interfaceGrid', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'interfaceGrid', r1Ptr)

! Define variable verticalShortwaveGrid
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'verticalShortwaveGrid'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .false.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nIceLayersP1'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive .or. pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalShortwaveGrid', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalShortwaveGrid', r1Ptr)

! Define variable carbonToNitrogenRatioAlgae
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'carbonToNitrogenRatioAlgae'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .false.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'maxAlgaeType'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'carbonToNitrogenRatioAlgae', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'carbonToNitrogenRatioAlgae', r1Ptr)

! Define variable carbonToNitrogenRatioDON
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'carbonToNitrogenRatioDON'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .false.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'maxDONType'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnBiogeochemistryActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'carbonToNitrogenRatioDON', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'carbonToNitrogenRatioDON', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_biogeochemistry


   subroutine seaice_generate_pool_prescribed_ice(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'prescribed_ice', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'prescribed_ice', newSubPool)

! Define variable iceCoverage
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'iceCoverage'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgPrescribedActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceCoverage', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceCoverage', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_prescribed_ice


   subroutine seaice_generate_pool_initial(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'initial', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'initial', newSubPool)

! Define variable initialSalinityProfile
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'initialSalinityProfile'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nIceLayersP1'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'initialSalinityProfile', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'initialSalinityProfile', r2Ptr)

! Define variable initialMeltingTemperatureProfile
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'initialMeltingTemperatureProfile'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nIceLayersP1'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgColumnPackageActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'initialMeltingTemperatureProfile', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'initialMeltingTemperatureProfile', r2Ptr)

! Define variable categoryThicknessLimits
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'categoryThicknessLimits'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .false.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCategoriesP1'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgColumnPackageActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'categoryThicknessLimits', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'categoryThicknessLimits', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_initial


   subroutine seaice_generate_pool_regions(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'regions', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'regions', newSubPool)

! Define variable regionCellMasks
      allocate(i2Ptr)

! Setting up time level 1
      i2Ptr % fieldName = 'regionCellMasks'
      i2Ptr % isVarArray = .false.
      i2Ptr % isDecomposed = .true.
      i2Ptr % hasTimeDimension = .false.
      i2Ptr % isPersistent = .true.
      i2Ptr % isActive = .false.
! Setting up dimensions
      i2Ptr % dimNames(1) = 'nRegions'
      i2Ptr % dimNames(2) = 'nCells'
      i2Ptr % defaultValue = 0
      allocate(i2Ptr % attLists(1))
      allocate(i2Ptr % attLists(1) % attList)
      i2Ptr % missingValue = MPAS_INT_FILLVAL
      i2Ptr % block => block

      i2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'regionCellMasks', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'regionCellMasks', i2Ptr)

! Define variable regionVertexMasks
      allocate(i2Ptr)

! Setting up time level 1
      i2Ptr % fieldName = 'regionVertexMasks'
      i2Ptr % isVarArray = .false.
      i2Ptr % isDecomposed = .true.
      i2Ptr % hasTimeDimension = .false.
      i2Ptr % isPersistent = .true.
      i2Ptr % isActive = .false.
! Setting up dimensions
      i2Ptr % dimNames(1) = 'nRegions'
      i2Ptr % dimNames(2) = 'nVertices'
      i2Ptr % defaultValue = 0
      allocate(i2Ptr % attLists(1))
      allocate(i2Ptr % attLists(1) % attList)
      i2Ptr % missingValue = MPAS_INT_FILLVAL
      i2Ptr % block => block

      i2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'regionVertexMasks', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'regionVertexMasks', i2Ptr)

! Define variable regionNames
      allocate(c1Ptr)

! Setting up time level 1
      c1Ptr % fieldName = 'regionNames'
      c1Ptr % isVarArray = .false.
      c1Ptr % isDecomposed = .false.
      c1Ptr % hasTimeDimension = .false.
      c1Ptr % isPersistent = .true.
      c1Ptr % isActive = .false.
! Setting up dimensions
      c1Ptr % dimNames(1) = 'nRegions'
      c1Ptr % defaultValue = ''
      allocate(c1Ptr % attLists(1))
      allocate(c1Ptr % attLists(1) % attList)
      c1Ptr % missingValue = MPAS_CHAR_FILLVAL
      c1Ptr % block => block

      c1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'regionNames', c1Ptr)
      call mpas_pool_add_field(block % allFields, 'regionNames', c1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_regions


   subroutine seaice_generate_pool_diagnostics(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'diagnostics', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'diagnostics', newSubPool)

! Define variable xtime
      allocate(c0Ptr)

! Setting up time level 1
      c0Ptr % fieldName = 'xtime'
      c0Ptr % isVarArray = .false.
      c0Ptr % isDecomposed = .false.
      c0Ptr % hasTimeDimension = .true.
      c0Ptr % defaultValue = ''
      c0Ptr % scalar = ''
      allocate(c0Ptr % attLists(1))
      allocate(c0Ptr % attLists(1) % attList)
      c0Ptr % missingValue = MPAS_CHAR_FILLVAL
      c0Ptr % block => block

      c0Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'xtime', c0Ptr)
      call mpas_pool_add_field(block % allFields, 'xtime', c0Ptr)

! Define variable simulationStartTime
      allocate(c0Ptr)

! Setting up time level 1
      c0Ptr % fieldName = 'simulationStartTime'
      c0Ptr % isVarArray = .false.
      c0Ptr % isDecomposed = .false.
      c0Ptr % hasTimeDimension = .false.
      c0Ptr % defaultValue = ''
      c0Ptr % scalar = ''
      allocate(c0Ptr % attLists(1))
      allocate(c0Ptr % attLists(1) % attList)
      c0Ptr % missingValue = MPAS_CHAR_FILLVAL
      c0Ptr % block => block

      c0Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'simulationStartTime', c0Ptr)
      call mpas_pool_add_field(block % allFields, 'simulationStartTime', c0Ptr)

! Define variable daysSinceStartOfSim
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'daysSinceStartOfSim'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      r0Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'daysSinceStartOfSim', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'daysSinceStartOfSim', r0Ptr)

! Define variable meltOnset
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'meltOnset'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'meltOnset', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'meltOnset', r1Ptr)

! Define variable freezeOnset
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'freezeOnset'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'freezeOnset', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'freezeOnset', r1Ptr)

! Define variable iceAreaTendencyTransport
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'iceAreaTendencyTransport'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceAreaTendencyTransport', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAreaTendencyTransport', r1Ptr)

! Define variable iceVolumeTendencyTransport
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'iceVolumeTendencyTransport'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceVolumeTendencyTransport', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceVolumeTendencyTransport', r1Ptr)

! Define variable iceAgeTendencyTransport
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'iceAgeTendencyTransport'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceAgeTendencyTransport', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAgeTendencyTransport', r1Ptr)

! Define variable iceAreaTendencyThermodynamics
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'iceAreaTendencyThermodynamics'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceAreaTendencyThermodynamics', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAreaTendencyThermodynamics', r1Ptr)

! Define variable iceVolumeTendencyThermodynamics
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'iceVolumeTendencyThermodynamics'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceVolumeTendencyThermodynamics', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceVolumeTendencyThermodynamics', r1Ptr)

! Define variable iceAgeTendencyThermodynamics
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'iceAgeTendencyThermodynamics'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceAgeTendencyThermodynamics', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAgeTendencyThermodynamics', r1Ptr)

! Define variable freezingMeltingPotentialInitial
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'freezingMeltingPotentialInitial'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'freezingMeltingPotentialInitial', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'freezingMeltingPotentialInitial', r1Ptr)

! Define variable timeAverageTestVariable
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'timeAverageTestVariable'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      r0Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'timeAverageTestVariable', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'timeAverageTestVariable', r0Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_diagnostics


   subroutine seaice_generate_pool_testing_system_test(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'testing_system_test', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'testing_system_test', newSubPool)

! Define variable testArrayRegression
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'testArrayRegression'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgTestingSystemTestActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'testArrayRegression', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'testArrayRegression', r1Ptr)

! Define variable testArrayParallelism
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'testArrayParallelism'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgTestingSystemTestActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'testArrayParallelism', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'testArrayParallelism', r1Ptr)

! Define variable testArrayRestartability
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'testArrayRestartability'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pkgTestingSystemTestActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'testArrayRestartability', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'testArrayRestartability', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_testing_system_test


   subroutine seaice_generate_pool_snicar(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'snicar', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'snicar', newSubPool)

! Define variable iceAsymmetryParameterDirect
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'iceAsymmetryParameterDirect'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .false.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nSpectralIntervalsSNICAR'
      r2Ptr % dimNames(2) = 'nSnowGrainRadiusSNICAR'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgSnicarActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceAsymmetryParameterDirect', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAsymmetryParameterDirect', r2Ptr)

! Define variable iceAsymmetryParameterDiffuse
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'iceAsymmetryParameterDiffuse'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .false.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nSpectralIntervalsSNICAR'
      r2Ptr % dimNames(2) = 'nSnowGrainRadiusSNICAR'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgSnicarActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceAsymmetryParameterDiffuse', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAsymmetryParameterDiffuse', r2Ptr)

! Define variable iceSingleScatterAlbedoDirect
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'iceSingleScatterAlbedoDirect'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .false.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nSpectralIntervalsSNICAR'
      r2Ptr % dimNames(2) = 'nSnowGrainRadiusSNICAR'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgSnicarActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceSingleScatterAlbedoDirect', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'iceSingleScatterAlbedoDirect', r2Ptr)

! Define variable iceSingleScatterAlbedoDiffuse
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'iceSingleScatterAlbedoDiffuse'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .false.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nSpectralIntervalsSNICAR'
      r2Ptr % dimNames(2) = 'nSnowGrainRadiusSNICAR'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgSnicarActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceSingleScatterAlbedoDiffuse', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'iceSingleScatterAlbedoDiffuse', r2Ptr)

! Define variable iceMassExtinctionCrossSectionDirect
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'iceMassExtinctionCrossSectionDirect'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .false.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nSpectralIntervalsSNICAR'
      r2Ptr % dimNames(2) = 'nSnowGrainRadiusSNICAR'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgSnicarActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceMassExtinctionCrossSectionDirect', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'iceMassExtinctionCrossSectionDirect', r2Ptr)

! Define variable iceMassExtinctionCrossSectionDiffuse
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'iceMassExtinctionCrossSectionDiffuse'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .false.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nSpectralIntervalsSNICAR'
      r2Ptr % dimNames(2) = 'nSnowGrainRadiusSNICAR'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgSnicarActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceMassExtinctionCrossSectionDiffuse', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'iceMassExtinctionCrossSectionDiffuse', r2Ptr)

! Define variable aerosolMassExtinctionCrossSection5band
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'aerosolMassExtinctionCrossSection5band'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .false.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nSpectralIntervalsSNICAR'
      r2Ptr % dimNames(2) = 'maxAerosolType'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgSnicarActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'aerosolMassExtinctionCrossSection5band', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'aerosolMassExtinctionCrossSection5band', r2Ptr)

! Define variable aerosolSingleScatterAlbedo5band
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'aerosolSingleScatterAlbedo5band'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .false.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nSpectralIntervalsSNICAR'
      r2Ptr % dimNames(2) = 'maxAerosolType'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgSnicarActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'aerosolSingleScatterAlbedo5band', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'aerosolSingleScatterAlbedo5band', r2Ptr)

! Define variable aerosolAsymmetryParameter5band
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'aerosolAsymmetryParameter5band'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .false.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nSpectralIntervalsSNICAR'
      r2Ptr % dimNames(2) = 'maxAerosolType'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgSnicarActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'aerosolAsymmetryParameter5band', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'aerosolAsymmetryParameter5band', r2Ptr)

! Define variable modalMassExtinctionCrossSection5band
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'modalMassExtinctionCrossSection5band'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .false.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nSpectralIntervalsSNICAR'
      r2Ptr % dimNames(2) = 'nModal1'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgSnicarActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'modalMassExtinctionCrossSection5band', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'modalMassExtinctionCrossSection5band', r2Ptr)

! Define variable modalSingleScatterAlbedo5band
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'modalSingleScatterAlbedo5band'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .false.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nSpectralIntervalsSNICAR'
      r2Ptr % dimNames(2) = 'nModal1'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgSnicarActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'modalSingleScatterAlbedo5band', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'modalSingleScatterAlbedo5band', r2Ptr)

! Define variable modalAsymmetryParameter5band
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'modalAsymmetryParameter5band'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .false.
      r2Ptr % hasTimeDimension = .false.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nSpectralIntervalsSNICAR'
      r2Ptr % dimNames(2) = 'nModal1'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pkgSnicarActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'modalAsymmetryParameter5band', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'modalAsymmetryParameter5band', r2Ptr)

! Define variable modalBCabsorptionParameter5band
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'modalBCabsorptionParameter5band'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .false.
      r3Ptr % hasTimeDimension = .false.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSpectralIntervalsSNICAR'
      r3Ptr % dimNames(2) = 'nModal1'
      r3Ptr % dimNames(3) = 'nModal2'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (pkgSnicarActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'modalBCabsorptionParameter5band', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'modalBCabsorptionParameter5band', r3Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_snicar


   subroutine seaice_generate_pool_pointLocations(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'pointLocations', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'pointLocations', newSubPool)

! Define variable pointCellGlobalID
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'pointCellGlobalID'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .false.
      i1Ptr % hasTimeDimension = .false.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nPoints'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'long_name', 'List of global cell IDs in point set.')
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'pointCellGlobalID', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'pointCellGlobalID', i1Ptr)

! Define variable pointCellLocalID
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'pointCellLocalID'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .false.
      i1Ptr % hasTimeDimension = .false.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nPoints'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'long_name', 'List of local cell IDs in point set.')
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'pointCellLocalID', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'pointCellLocalID', i1Ptr)

! Define variable indexToPointCellLocalID
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'indexToPointCellLocalID'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .false.
      i1Ptr % hasTimeDimension = .false.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nPoints'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'long_name', 'Index to list of local cell IDs in point set.')
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'indexToPointCellLocalID', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'indexToPointCellLocalID', i1Ptr)

! Define variable pointVertexGlobalID
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'pointVertexGlobalID'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .false.
      i1Ptr % hasTimeDimension = .false.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nPoints'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'long_name', 'List of global vertex IDs in point set.')
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'pointVertexGlobalID', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'pointVertexGlobalID', i1Ptr)

! Define variable pointVertexLocalID
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'pointVertexLocalID'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .false.
      i1Ptr % hasTimeDimension = .false.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nPoints'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'long_name', 'List of local vertex IDs in point set.')
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'pointVertexLocalID', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'pointVertexLocalID', i1Ptr)

! Define variable indexToPointVertexLocalID
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'indexToPointVertexLocalID'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .false.
      i1Ptr % hasTimeDimension = .false.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nPoints'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'long_name', 'Index to list of local vertex IDs in point set.')
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'indexToPointVertexLocalID', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'indexToPointVertexLocalID', i1Ptr)

! Define variable pointNames
      allocate(c1Ptr)

! Setting up time level 1
      c1Ptr % fieldName = 'pointNames'
      c1Ptr % isVarArray = .false.
      c1Ptr % isDecomposed = .false.
      c1Ptr % hasTimeDimension = .false.
      c1Ptr % isPersistent = .true.
      c1Ptr % isActive = .false.
! Setting up dimensions
      c1Ptr % dimNames(1) = 'nPoints'
      c1Ptr % defaultValue = ''
      allocate(c1Ptr % attLists(1))
      allocate(c1Ptr % attLists(1) % attList)
      call mpas_add_att(c1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(c1Ptr % attLists(1) % attList, 'long_name', 'The names of each point.')
      c1Ptr % missingValue = MPAS_CHAR_FILLVAL
      c1Ptr % block => block

      c1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'pointNames', c1Ptr)
      call mpas_pool_add_field(block % allFields, 'pointNames', c1Ptr)

! Define variable pointGroupNames
      allocate(c1Ptr)

! Setting up time level 1
      c1Ptr % fieldName = 'pointGroupNames'
      c1Ptr % isVarArray = .false.
      c1Ptr % isDecomposed = .false.
      c1Ptr % hasTimeDimension = .false.
      c1Ptr % isPersistent = .true.
      c1Ptr % isActive = .false.
! Setting up dimensions
      c1Ptr % dimNames(1) = 'nPointGroups'
      c1Ptr % defaultValue = ''
      allocate(c1Ptr % attLists(1))
      allocate(c1Ptr % attLists(1) % attList)
      call mpas_add_att(c1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(c1Ptr % attLists(1) % attList, 'long_name', 'The names of each point group.')
      c1Ptr % missingValue = MPAS_CHAR_FILLVAL
      c1Ptr % block => block

      c1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'pointGroupNames', c1Ptr)
      call mpas_pool_add_field(block % allFields, 'pointGroupNames', c1Ptr)

! Define variable nPointsInGroup
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'nPointsInGroup'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .false.
      i1Ptr % hasTimeDimension = .false.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nPointGroups'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'long_name', 'The number of points in each point group.')
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      i1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'nPointsInGroup', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'nPointsInGroup', i1Ptr)

! Define variable pointsInGroup
      allocate(i2Ptr)

! Setting up time level 1
      i2Ptr % fieldName = 'pointsInGroup'
      i2Ptr % isVarArray = .false.
      i2Ptr % isDecomposed = .false.
      i2Ptr % hasTimeDimension = .false.
      i2Ptr % isPersistent = .true.
      i2Ptr % isActive = .false.
! Setting up dimensions
      i2Ptr % dimNames(1) = 'maxPointsInGroup'
      i2Ptr % dimNames(2) = 'nPointGroups'
      i2Ptr % defaultValue = 0
      allocate(i2Ptr % attLists(1))
      allocate(i2Ptr % attLists(1) % attList)
      call mpas_add_att(i2Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr % attLists(1) % attList, 'long_name', 'The indices of each point in a each group.')
      i2Ptr % missingValue = MPAS_INT_FILLVAL
      i2Ptr % block => block

      i2Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'pointsInGroup', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'pointsInGroup', i2Ptr)

! Define variable xPoint
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'xPoint'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .false.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nPoints'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'X Coordinate in cartesian space of point locations.')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'xPoint', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'xPoint', r1Ptr)

! Define variable yPoint
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'yPoint'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .false.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nPoints'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Y Coordinate in cartesian space of point locations.')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'yPoint', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'yPoint', r1Ptr)

! Define variable zPoint
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'zPoint'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .false.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nPoints'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Z Coordinate in cartesian space of point locations.')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'zPoint', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zPoint', r1Ptr)

! Define variable latPoint
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'latPoint'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .false.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nPoints'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'radians')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Latitude of point locations.')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'latPoint', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'latPoint', r1Ptr)

! Define variable lonPoint
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'lonPoint'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .false.
      r1Ptr % hasTimeDimension = .false.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nPoints'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'radians')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Longitude of point locations.')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      r1Ptr % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'lonPoint', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'lonPoint', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_pointLocations


   subroutine seaice_generate_pool_special_boundaries(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'special_boundaries', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'special_boundaries', newSubPool)

! Define variable vertexBoundaryType
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'vertexBoundaryType'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .false.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nVertices'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      if (pkgSpecialBoundariesActive) then
         i1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vertexBoundaryType', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'vertexBoundaryType', i1Ptr)

! Define variable vertexBoundarySource
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'vertexBoundarySource'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .false.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nVertices'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      if (pkgSpecialBoundariesActive) then
         i1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vertexBoundarySource', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'vertexBoundarySource', i1Ptr)

! Define variable vertexBoundarySourceLocal
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'vertexBoundarySourceLocal'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .false.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nVertices'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      if (pkgSpecialBoundariesActive) then
         i1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vertexBoundarySourceLocal', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'vertexBoundarySourceLocal', i1Ptr)

! Define variable solveVelocitySpecialBoundaries
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'solveVelocitySpecialBoundaries'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .false.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nVertices'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      if (pkgSpecialBoundariesActive) then
         i1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'solveVelocitySpecialBoundaries', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'solveVelocitySpecialBoundaries', i1Ptr)

! Define variable solveStressSpecialBoundaries
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'solveStressSpecialBoundaries'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .false.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nCells'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      if (pkgSpecialBoundariesActive) then
         i1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'solveStressSpecialBoundaries', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'solveStressSpecialBoundaries', i1Ptr)

! Define variable tracerBoundaryType
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'tracerBoundaryType'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .true.
      i1Ptr % hasTimeDimension = .false.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nCells'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      if (pkgSpecialBoundariesActive) then
         i1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tracerBoundaryType', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'tracerBoundaryType', i1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_special_boundaries


   subroutine seaice_generate_pool_highFrequencyOutputAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'highFrequencyOutputAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'highFrequencyOutputAM', newSubPool)

! Define variable iceAreaCellCategory1
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'iceAreaCellCategory1'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'area of ice in category 1')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceAreaCellCategory1', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAreaCellCategory1', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_highFrequencyOutputAM


   subroutine seaice_generate_pool_temperaturesAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'temperaturesAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'temperaturesAM', newSubPool)

! Define variable iceTemperature
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'iceTemperature'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .true.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nIceLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      call mpas_add_att(r3Ptr % attLists(1) % attList, 'units', 'degrees C')
      call mpas_add_att(r3Ptr % attLists(1) % attList, 'long_name', 'Ice layer temperature')
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (temperaturesAMPKGActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceTemperature', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'iceTemperature', r3Ptr)

! Define variable snowTemperature
      allocate(r3Ptr)

! Setting up time level 1
      r3Ptr % fieldName = 'snowTemperature'
      r3Ptr % isVarArray = .false.
      r3Ptr % isDecomposed = .true.
      r3Ptr % hasTimeDimension = .true.
      r3Ptr % isPersistent = .true.
      r3Ptr % isActive = .false.
! Setting up dimensions
      r3Ptr % dimNames(1) = 'nSnowLayers'
      r3Ptr % dimNames(2) = 'nCategories'
      r3Ptr % dimNames(3) = 'nCells'
      r3Ptr % defaultValue = 0.0
      allocate(r3Ptr % attLists(1))
      allocate(r3Ptr % attLists(1) % attList)
      call mpas_add_att(r3Ptr % attLists(1) % attList, 'units', 'degrees C')
      call mpas_add_att(r3Ptr % attLists(1) % attList, 'long_name', 'snow layer temperature')
      r3Ptr % missingValue = MPAS_REAL_FILLVAL
      r3Ptr % block => block

      if (temperaturesAMPKGActive) then
         r3Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowTemperature', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'snowTemperature', r3Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_temperaturesAM


   subroutine seaice_generate_pool_regionalStatisticsAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'regionalStatisticsAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'regionalStatisticsAM', newSubPool)

! Define variable totalIceArea
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'totalIceArea'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .false.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nRegions'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'km^2')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Total sea-ice area by region')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (regionalStatisticsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'totalIceArea', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'totalIceArea', r1Ptr)

! Define variable totalIceExtent
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'totalIceExtent'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .false.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nRegions'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'km^2')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Total sea-ice extent by region')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (regionalStatisticsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'totalIceExtent', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'totalIceExtent', r1Ptr)

! Define variable totalIceVolume
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'totalIceVolume'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .false.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nRegions'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'km^3')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Total sea-ice volume by region')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (regionalStatisticsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'totalIceVolume', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'totalIceVolume', r1Ptr)

! Define variable totalSnowVolume
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'totalSnowVolume'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .false.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nRegions'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'km^3')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Total snow volume by region')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (regionalStatisticsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'totalSnowVolume', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'totalSnowVolume', r1Ptr)

! Define variable totalKineticEnergy
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'totalKineticEnergy'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .false.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nRegions'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'J')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Total kinetic energy by region')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (regionalStatisticsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'totalKineticEnergy', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'totalKineticEnergy', r1Ptr)

! Define variable rmsIceSpeed
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'rmsIceSpeed'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .false.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nRegions'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'm/s')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'RMS ice speed by region')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (regionalStatisticsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'rmsIceSpeed', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'rmsIceSpeed', r1Ptr)

! Define variable averageAlbedo
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'averageAlbedo'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .false.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nRegions'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', '-')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Average albedo by region')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (regionalStatisticsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'averageAlbedo', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'averageAlbedo', r1Ptr)

! Define variable maximumIceVolume
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'maximumIceVolume'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .false.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nRegions'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'km^2')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Maximum sea-ice volume by region')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (regionalStatisticsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'maximumIceVolume', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'maximumIceVolume', r1Ptr)

! Define variable maximumIceVolumeLocked
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'maximumIceVolumeLocked'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .false.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nRegions'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'km^2')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Maximum sea-ice volume by region for dynamically locked '&
//'cells')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (regionalStatisticsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'maximumIceVolumeLocked', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'maximumIceVolumeLocked', r1Ptr)

! Define variable maximumIceVolumeNotLocked
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'maximumIceVolumeNotLocked'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .false.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nRegions'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'km^2')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Maximum sea-ice volume by region for non-dynamically locked '&
//'cells')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (regionalStatisticsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'maximumIceVolumeNotLocked', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'maximumIceVolumeNotLocked', r1Ptr)

! Define variable maximumIcePressure
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'maximumIcePressure'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .false.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nRegions'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'kN/m')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Maximum sea-ice pressure by region')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (regionalStatisticsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'maximumIcePressure', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'maximumIcePressure', r1Ptr)

! Define variable maximumIceSpeed
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'maximumIceSpeed'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .false.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nRegions'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'm/s')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Maximum sea-ice speed by region')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (regionalStatisticsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'maximumIceSpeed', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'maximumIceSpeed', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_regionalStatisticsAM


   subroutine seaice_generate_pool_ridgingDiagnosticsAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'ridgingDiagnosticsAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'ridgingDiagnosticsAM', newSubPool)

! Define variable levelIceAreaAverage
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'levelIceAreaAverage'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', '-')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'level ice cell fraction')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (ridgingDiagnosticsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceAreaAverage', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'levelIceAreaAverage', r1Ptr)

! Define variable ridgedIceAreaAverage
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'ridgedIceAreaAverage'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', '-')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'ridged ice cell fraction')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (ridgingDiagnosticsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ridgedIceAreaAverage', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ridgedIceAreaAverage', r1Ptr)

! Define variable levelIceVolumeAverage
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'levelIceVolumeAverage'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', '-')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'level ice cell volume')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (ridgingDiagnosticsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'levelIceVolumeAverage', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'levelIceVolumeAverage', r1Ptr)

! Define variable ridgedIceVolumeAverage
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'ridgedIceVolumeAverage'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', '-')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'ridged ice cell volume')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (ridgingDiagnosticsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ridgedIceVolumeAverage', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ridgedIceVolumeAverage', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_ridgingDiagnosticsAM


   subroutine seaice_generate_pool_conservationCheckAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'conservationCheckAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'conservationCheckAM', newSubPool)

! Define variable performConservationPrecompute
      allocate(i0Ptr)

! Setting up time level 1
      i0Ptr % fieldName = 'performConservationPrecompute'
      i0Ptr % isVarArray = .false.
      i0Ptr % isDecomposed = .false.
      i0Ptr % hasTimeDimension = .false.
      i0Ptr % defaultValue = 1
      i0Ptr % scalar = 1
      allocate(i0Ptr % attLists(1))
      allocate(i0Ptr % attLists(1) % attList)
      call mpas_add_att(i0Ptr % attLists(1) % attList, 'units', '')
      call mpas_add_att(i0Ptr % attLists(1) % attList, 'long_name', '')
      i0Ptr % missingValue = MPAS_INT_FILLVAL
      i0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         i0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'performConservationPrecompute', i0Ptr)
      call mpas_pool_add_field(block % allFields, 'performConservationPrecompute', i0Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_conservationCheckAM


   subroutine seaice_generate_pool_conservationCheckAreaAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'conservationCheckAreaAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'conservationCheckAreaAM', newSubPool)

! Define variable earthArea
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'earthArea'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'm2')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Area of the whole Earth')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'earthArea', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'earthArea', r0Ptr)

! Define variable domainArea
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'domainArea'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'm2')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Area of the domain')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'domainArea', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'domainArea', r0Ptr)

! Define variable domainFraction
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'domainFraction'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', '')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Ratio of domain to Earth area')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'domainFraction', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'domainFraction', r0Ptr)

! Define variable totalSeaiceArea
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'totalSeaiceArea'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'm2')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Total sea-ice area')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'totalSeaiceArea', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'totalSeaiceArea', r0Ptr)

! Define variable NHSeaiceArea
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'NHSeaiceArea'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'm2')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'NH sea-ice area')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'NHSeaiceArea', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'NHSeaiceArea', r0Ptr)

! Define variable SHSeaiceArea
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'SHSeaiceArea'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'm2')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'SH sea-ice area')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'SHSeaiceArea', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'SHSeaiceArea', r0Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_conservationCheckAreaAM


   subroutine seaice_generate_pool_conservationCheckEnergyAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'conservationCheckEnergyAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'conservationCheckEnergyAM', newSubPool)

! Define variable initialEnergy
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'initialEnergy'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'J')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Total initial energy of ice and snow')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'initialEnergy', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'initialEnergy', r0Ptr)

! Define variable finalEnergy
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'finalEnergy'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'J')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Total final energy of ice and snow')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'finalEnergy', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'finalEnergy', r0Ptr)

! Define variable energyChange
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'energyChange'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'J')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Total energy change of ice and snow during time step')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'energyChange', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'energyChange', r0Ptr)

! Define variable netEnergyFlux
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'netEnergyFlux'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'W')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Net energy flux to ice')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'netEnergyFlux', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'netEnergyFlux', r0Ptr)

! Define variable absoluteEnergyError
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'absoluteEnergyError'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'J')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Absolute energy conservation error')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'absoluteEnergyError', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'absoluteEnergyError', r0Ptr)

! Define variable relativeEnergyError
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'relativeEnergyError'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'None')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Relative energy conservation error')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'relativeEnergyError', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'relativeEnergyError', r0Ptr)

! Define variable accumulatedSurfaceHeatFlux
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'accumulatedSurfaceHeatFlux'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'None')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', '')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'accumulatedSurfaceHeatFlux', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'accumulatedSurfaceHeatFlux', r0Ptr)

! Define variable accumulatedOceanHeatFlux
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'accumulatedOceanHeatFlux'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'None')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', '')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'accumulatedOceanHeatFlux', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'accumulatedOceanHeatFlux', r0Ptr)

! Define variable accumulatedFreezingPotential
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'accumulatedFreezingPotential'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'None')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', '')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'accumulatedFreezingPotential', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'accumulatedFreezingPotential', r0Ptr)

! Define variable accumulatedSnowfallHeat
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'accumulatedSnowfallHeat'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'None')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', '')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'accumulatedSnowfallHeat', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'accumulatedSnowfallHeat', r0Ptr)

! Define variable accumulatedLatentHeat
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'accumulatedLatentHeat'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'None')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', '')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'accumulatedLatentHeat', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'accumulatedLatentHeat', r0Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_conservationCheckEnergyAM


   subroutine seaice_generate_pool_conservationCheckMassAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'conservationCheckMassAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'conservationCheckMassAM', newSubPool)

! Define variable initialMass
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'initialMass'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'kg')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Total initial mass of ice and snow')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'initialMass', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'initialMass', r0Ptr)

! Define variable finalMass
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'finalMass'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'kg')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Total final mass of ice and snow')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'finalMass', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'finalMass', r0Ptr)

! Define variable massChange
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'massChange'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'kg')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Total mass change of ice and snow during time step')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'massChange', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'massChange', r0Ptr)

! Define variable netMassFlux
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'netMassFlux'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'kg/s')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Net mass flux to ice')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'netMassFlux', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'netMassFlux', r0Ptr)

! Define variable absoluteMassError
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'absoluteMassError'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'kg')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Absolute mass conservation error')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'absoluteMassError', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'absoluteMassError', r0Ptr)

! Define variable relativeMassError
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'relativeMassError'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'None')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Relative mass conservation error')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'relativeMassError', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'relativeMassError', r0Ptr)

! Define variable accumulatedRainfallRate
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'accumulatedRainfallRate'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'None')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', '')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'accumulatedRainfallRate', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'accumulatedRainfallRate', r0Ptr)

! Define variable accumulatedSnowfallRate
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'accumulatedSnowfallRate'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'None')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', '')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'accumulatedSnowfallRate', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'accumulatedSnowfallRate', r0Ptr)

! Define variable accumulatedEvaporation
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'accumulatedEvaporation'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'None')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', '')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'accumulatedEvaporation', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'accumulatedEvaporation', r0Ptr)

! Define variable accumulatedFreshWater
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'accumulatedFreshWater'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'None')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', '')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'accumulatedFreshWater', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'accumulatedFreshWater', r0Ptr)

! Define variable accumulatedFrazilWater
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'accumulatedFrazilWater'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'None')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', '')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'accumulatedFrazilWater', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'accumulatedFrazilWater', r0Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_conservationCheckMassAM


   subroutine seaice_generate_pool_conservationCheckSaltAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'conservationCheckSaltAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'conservationCheckSaltAM', newSubPool)

! Define variable initialSalt
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'initialSalt'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'kg')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Total initial salt of ice and snow')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'initialSalt', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'initialSalt', r0Ptr)

! Define variable finalSalt
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'finalSalt'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'kg')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Total final salt of ice and snow')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'finalSalt', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'finalSalt', r0Ptr)

! Define variable saltChange
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'saltChange'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'kg')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Total salt change of ice and snow during time step')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'saltChange', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'saltChange', r0Ptr)

! Define variable netSaltFlux
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'netSaltFlux'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'kg/s')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Net salt flux to ice')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'netSaltFlux', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'netSaltFlux', r0Ptr)

! Define variable absoluteSaltError
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'absoluteSaltError'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'kg')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Absolute salt conservation error')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'absoluteSaltError', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'absoluteSaltError', r0Ptr)

! Define variable relativeSaltError
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'relativeSaltError'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'None')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Relative salt conservation error')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'relativeSaltError', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'relativeSaltError', r0Ptr)

! Define variable accumulatedOceanSaltFlux
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'accumulatedOceanSaltFlux'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'None')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', '')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'accumulatedOceanSaltFlux', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'accumulatedOceanSaltFlux', r0Ptr)

! Define variable accumulatedFrazilSaltFlux
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'accumulatedFrazilSaltFlux'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'None')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', '')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'accumulatedFrazilSaltFlux', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'accumulatedFrazilSaltFlux', r0Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_conservationCheckSaltAM


   subroutine seaice_generate_pool_conservationCheckCarbonAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'conservationCheckCarbonAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'conservationCheckCarbonAM', newSubPool)

! Define variable initialCarbon
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'initialCarbon'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'mmol')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Total initial carbon of ice and snow')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'initialCarbon', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'initialCarbon', r0Ptr)

! Define variable finalCarbon
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'finalCarbon'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'mmol')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Total final carbon of ice and snow')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'finalCarbon', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'finalCarbon', r0Ptr)

! Define variable carbonChange
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'carbonChange'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'mmol')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Total carbon change of ice and snow during time step')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'carbonChange', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'carbonChange', r0Ptr)

! Define variable netCarbonFlux
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'netCarbonFlux'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'mmol/s')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Net carbon flux to sea ice')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'netCarbonFlux', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'netCarbonFlux', r0Ptr)

! Define variable absoluteCarbonError
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'absoluteCarbonError'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'mmol')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Absolute carbon conservation error')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'absoluteCarbonError', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'absoluteCarbonError', r0Ptr)

! Define variable relativeCarbonError
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'relativeCarbonError'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'None')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Relative carbon conservation error')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'relativeCarbonError', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'relativeCarbonError', r0Ptr)

! Define variable accumulatedOceanCarbonFlux
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'accumulatedOceanCarbonFlux'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'mmol/s')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Total ocean carbon flux, positive into the ocean')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (conservationCheckAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'accumulatedOceanCarbonFlux', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'accumulatedOceanCarbonFlux', r0Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_conservationCheckCarbonAM


   subroutine seaice_generate_pool_geographicalVectorsAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'geographicalVectorsAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'geographicalVectorsAM', newSubPool)

! Define variable uVelocityGeo
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'uVelocityGeo'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'm/s')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'True eastwards ice velocity')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (geographicalVectorsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'uVelocityGeo', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'uVelocityGeo', r1Ptr)

! Define variable vVelocityGeo
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'vVelocityGeo'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'm/s')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'True northwards ice velocity')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (geographicalVectorsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vVelocityGeo', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'vVelocityGeo', r1Ptr)

! Define variable stressDivergenceUGeo
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'stressDivergenceUGeo'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'N/m^2')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'True eastwards stress divergence')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (geographicalVectorsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'stressDivergenceUGeo', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'stressDivergenceUGeo', r1Ptr)

! Define variable stressDivergenceVGeo
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'stressDivergenceVGeo'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'N/m^2')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'True northwards stress divergence')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (geographicalVectorsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'stressDivergenceVGeo', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'stressDivergenceVGeo', r1Ptr)

! Define variable airStressVertexUGeo
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'airStressVertexUGeo'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'N/m^2')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'True eastwards sea ice-air stress')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (geographicalVectorsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'airStressVertexUGeo', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'airStressVertexUGeo', r1Ptr)

! Define variable airStressVertexVGeo
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'airStressVertexVGeo'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'N/m^2')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'True northwards sea ice-air stress')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (geographicalVectorsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'airStressVertexVGeo', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'airStressVertexVGeo', r1Ptr)

! Define variable oceanStressUGeo
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanStressUGeo'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'N/m^2')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'True eastwards sea ice-ocean stress')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (geographicalVectorsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanStressUGeo', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanStressUGeo', r1Ptr)

! Define variable oceanStressVGeo
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'oceanStressVGeo'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'N/m^2')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'True northwards sea ice-ocean stress')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (geographicalVectorsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanStressVGeo', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanStressVGeo', r1Ptr)

! Define variable surfaceTiltForceUGeo
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'surfaceTiltForceUGeo'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'N/m^2')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'True eastwards sea surface tilt stress')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (geographicalVectorsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'surfaceTiltForceUGeo', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceTiltForceUGeo', r1Ptr)

! Define variable surfaceTiltForceVGeo
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'surfaceTiltForceVGeo'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'N/m^2')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'True northwards sea surface tilt stress')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (geographicalVectorsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'surfaceTiltForceVGeo', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceTiltForceVGeo', r1Ptr)

! Define variable uOceanVelocityVertexGeo
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'uOceanVelocityVertexGeo'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'm/s')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'True eastwards ocean velocity')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (geographicalVectorsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'uOceanVelocityVertexGeo', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'uOceanVelocityVertexGeo', r1Ptr)

! Define variable vOceanVelocityVertexGeo
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'vOceanVelocityVertexGeo'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'm/s')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'True northwards ocean velocity')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (geographicalVectorsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vOceanVelocityVertexGeo', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'vOceanVelocityVertexGeo', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_geographicalVectorsAM


   subroutine seaice_generate_pool_loadBalanceAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'loadBalanceAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'loadBalanceAM', newSubPool)

! Define variable nCellsProcWithSeaIce
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'nCellsProcWithSeaIce'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .false.
      i1Ptr % hasTimeDimension = .true.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nProcs'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'units', '-')
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'long_name', 'Number of cells with sea ice present per processor')
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      if (loadBalanceAMPKGActive) then
         i1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'nCellsProcWithSeaIce', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'nCellsProcWithSeaIce', i1Ptr)

! Define variable nCellsProc
      allocate(i1Ptr)

! Setting up time level 1
      i1Ptr % fieldName = 'nCellsProc'
      i1Ptr % isVarArray = .false.
      i1Ptr % isDecomposed = .false.
      i1Ptr % hasTimeDimension = .false.
      i1Ptr % isPersistent = .true.
      i1Ptr % isActive = .false.
! Setting up dimensions
      i1Ptr % dimNames(1) = 'nProcs'
      i1Ptr % defaultValue = 0
      allocate(i1Ptr % attLists(1))
      allocate(i1Ptr % attLists(1) % attList)
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'units', '-')
      call mpas_add_att(i1Ptr % attLists(1) % attList, 'long_name', 'Number of cells per processor')
      i1Ptr % missingValue = MPAS_INT_FILLVAL
      i1Ptr % block => block

      if (loadBalanceAMPKGActive) then
         i1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'nCellsProc', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'nCellsProc', i1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_loadBalanceAM


   subroutine seaice_generate_pool_maximumIcePresenceAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'maximumIcePresenceAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'maximumIcePresenceAM', newSubPool)

! Define variable maximumIcePresence
      allocate(i2Ptr)

! Setting up time level 1
      i2Ptr % fieldName = 'maximumIcePresence'
      i2Ptr % isVarArray = .false.
      i2Ptr % isDecomposed = .true.
      i2Ptr % hasTimeDimension = .true.
      i2Ptr % isPersistent = .true.
      i2Ptr % isActive = .false.
! Setting up dimensions
      i2Ptr % dimNames(1) = 'nMonths'
      i2Ptr % dimNames(2) = 'nCells'
      i2Ptr % defaultValue = 0
      allocate(i2Ptr % attLists(1))
      allocate(i2Ptr % attLists(1) % attList)
      call mpas_add_att(i2Ptr % attLists(1) % attList, 'units', '-')
      call mpas_add_att(i2Ptr % attLists(1) % attList, 'long_name', 'Maximum extent of sea-ice for the simulation divided by '&
//'months')
      i2Ptr % missingValue = MPAS_INT_FILLVAL
      i2Ptr % block => block

      if (maximumIcePresenceAMPKGActive) then
         i2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'maximumIcePresence', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'maximumIcePresence', i2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_maximumIcePresenceAM


   subroutine seaice_generate_pool_miscellaneousAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'miscellaneousAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'miscellaneousAM', newSubPool)

! Define variable bulkSalinity
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'bulkSalinity'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'ppt')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Bulk salinity of ice in a cell')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (miscellaneousAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'bulkSalinity', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'bulkSalinity', r1Ptr)

! Define variable broadbandAlbedo
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'broadbandAlbedo'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', '-')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'snow/sea ice broadband albedo')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (miscellaneousAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'broadbandAlbedo', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'broadbandAlbedo', r1Ptr)

! Define variable coriolisStressVertexU
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'coriolisStressVertexU'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', '')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Coriolis stress in U direction')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (miscellaneousAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'coriolisStressVertexU', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'coriolisStressVertexU', r1Ptr)

! Define variable coriolisStressVertexV
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'coriolisStressVertexV'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nVertices'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', '')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'Coriolis stress in V direction')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (miscellaneousAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'coriolisStressVertexV', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'coriolisStressVertexV', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_miscellaneousAM


   subroutine seaice_generate_pool_areaVariablesAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'areaVariablesAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'areaVariablesAM', newSubPool)

! Define variable snowfallRateInitialArea
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'snowfallRateInitialArea'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'UNITS HERE')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'DESCRIPTION HERE')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (areaVariablesAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowfallRateInitialArea', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'snowfallRateInitialArea', r1Ptr)

! Define variable rainfallRateInitialArea
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'rainfallRateInitialArea'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'UNITS HERE')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'DESCRIPTION HERE')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (areaVariablesAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'rainfallRateInitialArea', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'rainfallRateInitialArea', r1Ptr)

! Define variable absorbedShortwaveFluxInitialArea
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'absorbedShortwaveFluxInitialArea'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'UNITS HERE')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'DESCRIPTION HERE')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (areaVariablesAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'absorbedShortwaveFluxInitialArea', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'absorbedShortwaveFluxInitialArea', r1Ptr)

! Define variable latentHeatFluxInitialArea
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'latentHeatFluxInitialArea'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'UNITS HERE')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'DESCRIPTION HERE')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (areaVariablesAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'latentHeatFluxInitialArea', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'latentHeatFluxInitialArea', r1Ptr)

! Define variable sensibleHeatFluxInitialArea
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'sensibleHeatFluxInitialArea'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'UNITS HERE')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'DESCRIPTION HERE')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (areaVariablesAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'sensibleHeatFluxInitialArea', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'sensibleHeatFluxInitialArea', r1Ptr)

! Define variable longwaveUpInitialArea
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'longwaveUpInitialArea'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'UNITS HERE')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'DESCRIPTION HERE')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (areaVariablesAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'longwaveUpInitialArea', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'longwaveUpInitialArea', r1Ptr)

! Define variable evaporativeWaterFluxInitialArea
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'evaporativeWaterFluxInitialArea'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'UNITS HERE')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'DESCRIPTION HERE')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (areaVariablesAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'evaporativeWaterFluxInitialArea', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'evaporativeWaterFluxInitialArea', r1Ptr)

! Define variable surfaceHeatFluxInitialArea
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'surfaceHeatFluxInitialArea'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'UNITS HERE')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'DESCRIPTION HERE')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (areaVariablesAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'surfaceHeatFluxInitialArea', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceHeatFluxInitialArea', r1Ptr)

! Define variable surfaceConductiveFluxInitialArea
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'surfaceConductiveFluxInitialArea'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'UNITS HERE')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'DESCRIPTION HERE')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (areaVariablesAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'surfaceConductiveFluxInitialArea', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceConductiveFluxInitialArea', r1Ptr)

! Define variable surfaceHeatFluxCategoryInitialArea
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'surfaceHeatFluxCategoryInitialArea'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'UNITS HERE')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'DESCRIPTION HERE')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (areaVariablesAMPKGActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'surfaceHeatFluxCategoryInitialArea', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceHeatFluxCategoryInitialArea', r2Ptr)

! Define variable surfaceConductiveFluxCategoryInitialArea
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'surfaceConductiveFluxCategoryInitialArea'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'UNITS HERE')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'DESCRIPTION HERE')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (areaVariablesAMPKGActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'surfaceConductiveFluxCategoryInitialArea', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceConductiveFluxCategoryInitialArea', r2Ptr)

! Define variable latentHeatFluxCategoryInitialArea
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'latentHeatFluxCategoryInitialArea'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'UNITS HERE')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'DESCRIPTION HERE')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (areaVariablesAMPKGActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'latentHeatFluxCategoryInitialArea', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'latentHeatFluxCategoryInitialArea', r2Ptr)

! Define variable sensibleHeatFluxCategoryInitialArea
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'sensibleHeatFluxCategoryInitialArea'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'UNITS HERE')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'DESCRIPTION HERE')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (areaVariablesAMPKGActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'sensibleHeatFluxCategoryInitialArea', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'sensibleHeatFluxCategoryInitialArea', r2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_areaVariablesAM


   subroutine seaice_generate_pool_pondDiagnosticsAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'pondDiagnosticsAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'pondDiagnosticsAM', newSubPool)

! Define variable meltPondArea
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'meltPondArea'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'UNITS HERE')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'DESCRIPTION HERE')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pondDiagnosticsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'meltPondArea', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'meltPondArea', r1Ptr)

! Define variable meltPondAreaFinalArea
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'meltPondAreaFinalArea'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'UNITS HERE')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'DESCRIPTION HERE')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pondDiagnosticsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'meltPondAreaFinalArea', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'meltPondAreaFinalArea', r1Ptr)

! Define variable meltPondDepth
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'meltPondDepth'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'UNITS HERE')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'DESCRIPTION HERE')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pondDiagnosticsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'meltPondDepth', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'meltPondDepth', r1Ptr)

! Define variable meltPondDepthFinalArea
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'meltPondDepthFinalArea'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'UNITS HERE')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'DESCRIPTION HERE')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pondDiagnosticsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'meltPondDepthFinalArea', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'meltPondDepthFinalArea', r1Ptr)

! Define variable meltPondLidThickness
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'meltPondLidThickness'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'UNITS HERE')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'DESCRIPTION HERE')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pondDiagnosticsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'meltPondLidThickness', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'meltPondLidThickness', r1Ptr)

! Define variable meltPondLidThicknessFinalArea
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'meltPondLidThicknessFinalArea'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', 'UNITS HERE')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', 'DESCRIPTION HERE')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (pondDiagnosticsAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'meltPondLidThicknessFinalArea', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'meltPondLidThicknessFinalArea', r1Ptr)

! Define variable meltPondDepthCategory
      allocate(r2Ptr)

! Setting up time level 1
      r2Ptr % fieldName = 'meltPondDepthCategory'
      r2Ptr % isVarArray = .false.
      r2Ptr % isDecomposed = .true.
      r2Ptr % hasTimeDimension = .true.
      r2Ptr % isPersistent = .true.
      r2Ptr % isActive = .false.
! Setting up dimensions
      r2Ptr % dimNames(1) = 'nCategories'
      r2Ptr % dimNames(2) = 'nCells'
      r2Ptr % defaultValue = 0.0
      allocate(r2Ptr % attLists(1))
      allocate(r2Ptr % attLists(1) % attList)
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'units', 'UNITS HERE')
      call mpas_add_att(r2Ptr % attLists(1) % attList, 'long_name', 'DESCRIPTION HERE')
      r2Ptr % missingValue = MPAS_REAL_FILLVAL
      r2Ptr % block => block

      if (pondDiagnosticsAMPKGActive) then
         r2Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'meltPondDepthCategory', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'meltPondDepthCategory', r2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_pondDiagnosticsAM


   subroutine seaice_generate_pool_iceShelvesAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'iceShelvesAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'iceShelvesAM', newSubPool)

! Define variable iceAreaOverIceShelves
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'iceAreaOverIceShelves'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', '-')
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'long_name', 'Total ice area present where ice shelves exist')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (iceShelvesAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceAreaOverIceShelves', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'iceAreaOverIceShelves', r0Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_iceShelvesAM


   subroutine seaice_generate_pool_icePresentAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'icePresentAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'icePresentAM', newSubPool)

! Define variable icePresent
      allocate(r1Ptr)

! Setting up time level 1
      r1Ptr % fieldName = 'icePresent'
      r1Ptr % isVarArray = .false.
      r1Ptr % isDecomposed = .true.
      r1Ptr % hasTimeDimension = .true.
      r1Ptr % isPersistent = .true.
      r1Ptr % isActive = .false.
! Setting up dimensions
      r1Ptr % dimNames(1) = 'nCells'
      r1Ptr % defaultValue = 0.0
      allocate(r1Ptr % attLists(1))
      allocate(r1Ptr % attLists(1) % attList)
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'units', '-')
      call mpas_add_att(r1Ptr % attLists(1) % attList, 'long_name', '1.0 if ice present, 0.0 if ice not present')
      r1Ptr % missingValue = MPAS_REAL_FILLVAL
      r1Ptr % block => block

      if (icePresentAMPKGActive) then
         r1Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'icePresent', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'icePresent', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_icePresentAM


   subroutine seaice_generate_pool_timeSeriesStatsAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), pointer :: r0Ptr
      type (field1DReal), pointer :: r1Ptr
      type (field2DReal), pointer :: r2Ptr
      type (field3DReal), pointer :: r3Ptr
      type (field4DReal), pointer :: r4Ptr
      type (field5DReal), pointer :: r5Ptr
      type (field0DInteger), pointer :: i0Ptr
      type (field1DInteger), pointer :: i1Ptr
      type (field2DInteger), pointer :: i2Ptr
      type (field3DInteger), pointer :: i3Ptr
      type (field0DChar), pointer :: c0Ptr
      type (field1DChar), pointer :: c1Ptr
      type (field0DReal), dimension(:), pointer :: r0aPtr
      type (field1DReal), dimension(:), pointer :: r1aPtr
      type (field2DReal), dimension(:), pointer :: r2aPtr
      type (field3DReal), dimension(:), pointer :: r3aPtr
      type (field4DReal), dimension(:), pointer :: r4aPtr
      type (field5DReal), dimension(:), pointer :: r5aPtr
      type (field0DInteger), dimension(:), pointer :: i0aPtr
      type (field1DInteger), dimension(:), pointer :: i1aPtr
      type (field2DInteger), dimension(:), pointer :: i2aPtr
      type (field3DInteger), dimension(:), pointer :: i3aPtr
      type (field0DChar), dimension(:), pointer :: c0aPtr
      type (field1DChar), dimension(:), pointer :: c1aPtr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: pkgWeakActive
      logical, pointer :: pkgVariationalActive
      logical, pointer :: pkgWeakVariationalActive
      logical, pointer :: pkgColumnPackageActive
      logical, pointer :: pkgColumnBiogeochemistryActive
      logical, pointer :: pkgColumnTracerIceAgeActive
      logical, pointer :: pkgColumnTracerFirstYearIceActive
      logical, pointer :: pkgColumnTracerLevelIceActive
      logical, pointer :: pkgColumnTracerPondsActive
      logical, pointer :: pkgColumnTracerLidThicknessActive
      logical, pointer :: pkgColumnTracerAerosolsActive
      logical, pointer :: pkgColumnTracerEffectiveSnowDensityActive
      logical, pointer :: pkgColumnTracerSnowGrainRadiusActive
      logical, pointer :: pkgTracerBrineActive
      logical, pointer :: pkgTracerMobileFractionActive
      logical, pointer :: pkgTracerSkeletalAlgaeActive
      logical, pointer :: pkgTracerSkeletalNitrateActive
      logical, pointer :: pkgTracerSkeletalCarbonActive
      logical, pointer :: pkgTracerSkeletalAmmoniumActive
      logical, pointer :: pkgTracerSkeletalSilicateActive
      logical, pointer :: pkgTracerSkeletalDMSActive
      logical, pointer :: pkgTracerSkeletalNonreactiveActive
      logical, pointer :: pkgTracerSkeletalHumicsActive
      logical, pointer :: pkgTracerSkeletalDONActive
      logical, pointer :: pkgTracerSkeletalIronActive
      logical, pointer :: pkgTracerVerticalAlgaeActive
      logical, pointer :: pkgTracerVerticalNitrateActive
      logical, pointer :: pkgTracerVerticalCarbonActive
      logical, pointer :: pkgTracerVerticalAmmoniumActive
      logical, pointer :: pkgTracerVerticalSilicateActive
      logical, pointer :: pkgTracerVerticalDMSActive
      logical, pointer :: pkgTracerVerticalNonreactiveActive
      logical, pointer :: pkgTracerVerticalHumicsActive
      logical, pointer :: pkgTracerVerticalDONActive
      logical, pointer :: pkgTracerVerticalIronActive
      logical, pointer :: pkgTracerZAerosolsActive
      logical, pointer :: pkgTracerZSalinityActive
      logical, pointer :: pkgColumnFormDragActive
      logical, pointer :: pkgBergsActive
      logical, pointer :: pkgTestingSystemTestActive
      logical, pointer :: pkgForcingActive
      logical, pointer :: pkgSnicarActive
      logical, pointer :: pkgPrescribedActive
      logical, pointer :: pkgSpecialBoundariesActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: temperaturesAMPKGActive
      logical, pointer :: regionalStatisticsAMPKGActive
      logical, pointer :: ridgingDiagnosticsAMPKGActive
      logical, pointer :: conservationCheckAMPKGActive
      logical, pointer :: geographicalVectorsAMPKGActive
      logical, pointer :: loadBalanceAMPKGActive
      logical, pointer :: maximumIcePresenceAMPKGActive
      logical, pointer :: miscellaneousAMPKGActive
      logical, pointer :: areaVariablesAMPKGActive
      logical, pointer :: pondDiagnosticsAMPKGActive
      logical, pointer :: unitConversionAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: iceShelvesAMPKGActive
      logical, pointer :: icePresentAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'pkgWeakActive', pkgWeakActive)
      call mpas_pool_get_package(packagePool, 'pkgVariationalActive', pkgVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgWeakVariationalActive', pkgWeakVariationalActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnPackageActive', pkgColumnPackageActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnBiogeochemistryActive', pkgColumnBiogeochemistryActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerIceAgeActive', pkgColumnTracerIceAgeActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerFirstYearIceActive', pkgColumnTracerFirstYearIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLevelIceActive', pkgColumnTracerLevelIceActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerPondsActive', pkgColumnTracerPondsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerLidThicknessActive', pkgColumnTracerLidThicknessActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerAerosolsActive', pkgColumnTracerAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerEffectiveSnowDensityActive', &
pkgColumnTracerEffectiveSnowDensityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnTracerSnowGrainRadiusActive', pkgColumnTracerSnowGrainRadiusActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerBrineActive', pkgTracerBrineActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerMobileFractionActive', pkgTracerMobileFractionActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAlgaeActive', pkgTracerSkeletalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNitrateActive', pkgTracerSkeletalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalCarbonActive', pkgTracerSkeletalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalAmmoniumActive', pkgTracerSkeletalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalSilicateActive', pkgTracerSkeletalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDMSActive', pkgTracerSkeletalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalNonreactiveActive', pkgTracerSkeletalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalHumicsActive', pkgTracerSkeletalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalDONActive', pkgTracerSkeletalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerSkeletalIronActive', pkgTracerSkeletalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAlgaeActive', pkgTracerVerticalAlgaeActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNitrateActive', pkgTracerVerticalNitrateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalCarbonActive', pkgTracerVerticalCarbonActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalAmmoniumActive', pkgTracerVerticalAmmoniumActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalSilicateActive', pkgTracerVerticalSilicateActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDMSActive', pkgTracerVerticalDMSActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalNonreactiveActive', pkgTracerVerticalNonreactiveActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalHumicsActive', pkgTracerVerticalHumicsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalDONActive', pkgTracerVerticalDONActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerVerticalIronActive', pkgTracerVerticalIronActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZAerosolsActive', pkgTracerZAerosolsActive)
      call mpas_pool_get_package(packagePool, 'pkgTracerZSalinityActive', pkgTracerZSalinityActive)
      call mpas_pool_get_package(packagePool, 'pkgColumnFormDragActive', pkgColumnFormDragActive)
      call mpas_pool_get_package(packagePool, 'pkgBergsActive', pkgBergsActive)
      call mpas_pool_get_package(packagePool, 'pkgTestingSystemTestActive', pkgTestingSystemTestActive)
      call mpas_pool_get_package(packagePool, 'pkgForcingActive', pkgForcingActive)
      call mpas_pool_get_package(packagePool, 'pkgSnicarActive', pkgSnicarActive)
      call mpas_pool_get_package(packagePool, 'pkgPrescribedActive', pkgPrescribedActive)
      call mpas_pool_get_package(packagePool, 'pkgSpecialBoundariesActive', pkgSpecialBoundariesActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'temperaturesAMPKGActive', temperaturesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatisticsAMPKGActive', regionalStatisticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'ridgingDiagnosticsAMPKGActive', ridgingDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'conservationCheckAMPKGActive', conservationCheckAMPKGActive)
      call mpas_pool_get_package(packagePool, 'geographicalVectorsAMPKGActive', geographicalVectorsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'loadBalanceAMPKGActive', loadBalanceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'maximumIcePresenceAMPKGActive', maximumIcePresenceAMPKGActive)
      call mpas_pool_get_package(packagePool, 'miscellaneousAMPKGActive', miscellaneousAMPKGActive)
      call mpas_pool_get_package(packagePool, 'areaVariablesAMPKGActive', areaVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pondDiagnosticsAMPKGActive', pondDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'unitConversionAMPKGActive', unitConversionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'iceShelvesAMPKGActive', iceShelvesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'icePresentAMPKGActive', icePresentAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'timeSeriesStatsAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'timeSeriesStatsAM', newSubPool)

! Define variable timeSeriesStatsOneString
      allocate(c0Ptr)

! Setting up time level 1
      c0Ptr % fieldName = 'timeSeriesStatsOneString'
      c0Ptr % isVarArray = .false.
      c0Ptr % isDecomposed = .false.
      c0Ptr % hasTimeDimension = .true.
      c0Ptr % defaultValue = ''
      c0Ptr % scalar = ''
      allocate(c0Ptr % attLists(1))
      allocate(c0Ptr % attLists(1) % attList)
      call mpas_add_att(c0Ptr % attLists(1) % attList, 'units', 'unitless')
      c0Ptr % missingValue = MPAS_CHAR_FILLVAL
      c0Ptr % block => block

      if (timeSeriesStatsDailyAMPKGActive .or. timeSeriesStatsMonthlyAMPKGActive .or. timeSeriesStatsClimatologyAMPKGActive .or. &
timeSeriesStatsCustomAMPKGActive) then
         c0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'timeSeriesStatsOneString', c0Ptr)
      call mpas_pool_add_field(block % allFields, 'timeSeriesStatsOneString', c0Ptr)

! Define variable timeSeriesStatsOneInteger
      allocate(i0Ptr)

! Setting up time level 1
      i0Ptr % fieldName = 'timeSeriesStatsOneInteger'
      i0Ptr % isVarArray = .false.
      i0Ptr % isDecomposed = .false.
      i0Ptr % hasTimeDimension = .true.
      i0Ptr % defaultValue = 0
      i0Ptr % scalar = 0
      allocate(i0Ptr % attLists(1))
      allocate(i0Ptr % attLists(1) % attList)
      call mpas_add_att(i0Ptr % attLists(1) % attList, 'units', 'unitless')
      i0Ptr % missingValue = MPAS_INT_FILLVAL
      i0Ptr % block => block

      if (timeSeriesStatsDailyAMPKGActive .or. timeSeriesStatsMonthlyAMPKGActive .or. timeSeriesStatsClimatologyAMPKGActive .or. &
timeSeriesStatsCustomAMPKGActive) then
         i0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'timeSeriesStatsOneInteger', i0Ptr)
      call mpas_pool_add_field(block % allFields, 'timeSeriesStatsOneInteger', i0Ptr)

! Define variable timeSeriesStatsOneReal
      allocate(r0Ptr)

! Setting up time level 1
      r0Ptr % fieldName = 'timeSeriesStatsOneReal'
      r0Ptr % isVarArray = .false.
      r0Ptr % isDecomposed = .false.
      r0Ptr % hasTimeDimension = .true.
      r0Ptr % defaultValue = 0.0
      r0Ptr % scalar = 0.0
      allocate(r0Ptr % attLists(1))
      allocate(r0Ptr % attLists(1) % attList)
      call mpas_add_att(r0Ptr % attLists(1) % attList, 'units', 'unitless')
      r0Ptr % missingValue = MPAS_REAL_FILLVAL
      r0Ptr % block => block

      if (timeSeriesStatsDailyAMPKGActive .or. timeSeriesStatsMonthlyAMPKGActive .or. timeSeriesStatsClimatologyAMPKGActive .or. &
timeSeriesStatsCustomAMPKGActive) then
         r0Ptr % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'timeSeriesStatsOneReal', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'timeSeriesStatsOneReal', r0Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine seaice_generate_pool_timeSeriesStatsAM


   subroutine seaice_generate_structs(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_io_units
      implicit none
      type (block_type), pointer, intent(inout) :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      call seaice_generate_pool_mesh(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_tracers(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_tracers_aggregate(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_icestate(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_tracer_tendencies(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_tracer_masks(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_tracer_edge_fluxes(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_tracer_products(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_tracer_triangles(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_tracer_barycenter(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_tracer_reconstruction(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_tracer_conservation(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_tracer_monotonicity(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_rotated_mesh(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_incremental_remap(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_forcing(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_atmos_coupling(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_atmos_forcing(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_alternative_atmos_forcing(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_ocean_coupling(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_boundary(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_velocity_solver(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_velocity_weak(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_velocity_variational(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_velocity_weak_variational(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_ridging(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_melt_growth_rates(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_atmos_fluxes(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_ocean_fluxes(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_berg_forcing(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_berg_fluxes(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_ocean_atmosphere(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_shortwave(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_drag(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_ponds(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_snow(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_aerosols(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_biogeochemistry(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_prescribed_ice(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_initial(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_regions(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_diagnostics(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_testing_system_test(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_snicar(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_pointLocations(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_special_boundaries(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_highFrequencyOutputAM(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_temperaturesAM(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_regionalStatisticsAM(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_ridgingDiagnosticsAM(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_conservationCheckAM(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_conservationCheckAreaAM(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_conservationCheckEnergyAM(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_conservationCheckMassAM(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_conservationCheckSaltAM(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_conservationCheckCarbonAM(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_geographicalVectorsAM(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_loadBalanceAM(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_maximumIcePresenceAM(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_miscellaneousAM(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_areaVariablesAM(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_pondDiagnosticsAM(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_iceShelvesAM(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_icePresentAM(block, structPool, dimensionPool, packagePool)

      call seaice_generate_pool_timeSeriesStatsAM(block, structPool, dimensionPool, packagePool)

   end subroutine seaice_generate_structs

   function seaice_setup_namelists(configPool, namelistFilename, dminfo) result(iErr)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_abort, only : mpas_dmpar_global_abort
      use mpas_log, only : mpas_log_write
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      character (len=*), intent(in) :: namelistFilename
      type (dm_info), intent(in) :: dminfo
      integer :: iErr

      integer :: unitNumber
      logical :: nmlExists

      iErr = 0
      unitNumber = 21
      call mpas_log_write('Reading namelist from file '//trim(namelistFilename))
      inquire(file=trim(namelistFilename), exist=nmlExists)
      if ( .not. nmlExists ) then
         call mpas_dmpar_global_abort('ERROR: Namelist file '//trim(namelistFilename)//' does not exist.')
      end if
      open(unitNumber,file=trim(namelistFilename),status='old',form='formatted')

      call seaice_setup_nmlrec_seaice_model(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_io(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_decomposition(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_restart(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_dimensions(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_initialize(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_use_sections(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_forcing(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_testing(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_velocity_solver(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_advection(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_column_package(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_column_tracers(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_biogeochemistry(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_shortwave(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_snow(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_meltponds(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_thermodynamics(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_itd(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_ridging(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_atmosphere(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_ocean(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_diagnostics(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_prescribed_ice(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_AM_highFrequencyOutput(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_AM_temperatures(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_AM_regionalStatistics(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_AM_ridgingDiagnostics(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_AM_conservationCheck(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_AM_geographicalVectors(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_AM_loadBalance(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_AM_maximumIcePresence(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_AM_miscellaneous(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_AM_areaVariables(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_AM_pondDiagnostics(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_AM_unitConversion(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_AM_pointwiseStats(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_AM_iceShelves(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_AM_icePresent(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_AM_timeSeriesStatsDaily(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_AM_timeSeriesStatsMonthly(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_AM_timeSeriesStatsClimatology(configPool, unitNumber, dminfo)
      call seaice_setup_nmlrec_AM_timeSeriesStatsCustom(configPool, unitNumber, dminfo)

      close(unitNumber)
   end function seaice_setup_namelists

   subroutine seaice_setup_nmlrec_seaice_model(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      real (kind=RKIND) :: config_dt = 3600.000000
      character (len=StrKIND) :: config_calendar_type = 'gregorian_noleap'
      character (len=StrKIND) :: config_start_time = '2000-01-01_00:00:00'
      character (len=StrKIND) :: config_stop_time = 'none'
      character (len=StrKIND) :: config_run_duration = '00-00-01_00:00:00'
      integer :: config_num_halos = 2

      namelist /seaice_model/ &
         config_dt, &
         config_calendar_type, &
         config_start_time, &
         config_stop_time, &
         config_run_duration, &
         config_num_halos
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, seaice_model, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_real(dminfo, config_dt)
         call mpas_dmpar_bcast_char(dminfo, config_calendar_type)
         call mpas_dmpar_bcast_char(dminfo, config_start_time)
         call mpas_dmpar_bcast_char(dminfo, config_stop_time)
         call mpas_dmpar_bcast_char(dminfo, config_run_duration)
         call mpas_dmpar_bcast_int(dminfo, config_num_halos)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record seaice_model')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_dt = $r', realArgs=(/config_dt/))
            call mpas_log_write('        config_calendar_type = '//mpas_log_escape_dollars(config_calendar_type))
            call mpas_log_write('        config_start_time = '//mpas_log_escape_dollars(config_start_time))
            call mpas_log_write('        config_stop_time = '//mpas_log_escape_dollars(config_stop_time))
            call mpas_log_write('        config_run_duration = '//mpas_log_escape_dollars(config_run_duration))
            call mpas_log_write('        config_num_halos = $i', intArgs=(/config_num_halos/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record seaice_model.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_dt', config_dt)
      call mpas_pool_add_config(configPool, 'config_calendar_type', config_calendar_type)
      call mpas_pool_add_config(configPool, 'config_start_time', config_start_time)
      call mpas_pool_add_config(configPool, 'config_stop_time', config_stop_time)
      call mpas_pool_add_config(configPool, 'config_run_duration', config_run_duration)
      call mpas_pool_add_config(configPool, 'config_num_halos', config_num_halos)

   end subroutine seaice_setup_nmlrec_seaice_model


   subroutine seaice_setup_nmlrec_io(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      integer :: config_pio_num_iotasks = 0
      integer :: config_pio_stride = 1
      logical :: config_write_output_on_startup = .false.
      logical :: config_test_case_diag = .false.
      character (len=StrKIND) :: config_test_case_diag_type = 'none'
      logical :: config_full_abort_write = .true.

      namelist /io/ &
         config_pio_num_iotasks, &
         config_pio_stride, &
         config_write_output_on_startup, &
         config_test_case_diag, &
         config_test_case_diag_type, &
         config_full_abort_write
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, io, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_int(dminfo, config_pio_num_iotasks)
         call mpas_dmpar_bcast_int(dminfo, config_pio_stride)
         call mpas_dmpar_bcast_logical(dminfo, config_write_output_on_startup)
         call mpas_dmpar_bcast_logical(dminfo, config_test_case_diag)
         call mpas_dmpar_bcast_char(dminfo, config_test_case_diag_type)
         call mpas_dmpar_bcast_logical(dminfo, config_full_abort_write)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record io')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_pio_num_iotasks = $i', intArgs=(/config_pio_num_iotasks/))
            call mpas_log_write('        config_pio_stride = $i', intArgs=(/config_pio_stride/))
            call mpas_log_write('        config_write_output_on_startup = $l', logicArgs=(/config_write_output_on_startup/))
            call mpas_log_write('        config_test_case_diag = $l', logicArgs=(/config_test_case_diag/))
            call mpas_log_write('        config_test_case_diag_type = '//mpas_log_escape_dollars(config_test_case_diag_type))
            call mpas_log_write('        config_full_abort_write = $l', logicArgs=(/config_full_abort_write/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record io.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_pio_num_iotasks', config_pio_num_iotasks)
      call mpas_pool_add_config(configPool, 'config_pio_stride', config_pio_stride)
      call mpas_pool_add_config(configPool, 'config_write_output_on_startup', config_write_output_on_startup)
      call mpas_pool_add_config(configPool, 'config_test_case_diag', config_test_case_diag)
      call mpas_pool_add_config(configPool, 'config_test_case_diag_type', config_test_case_diag_type)
      call mpas_pool_add_config(configPool, 'config_full_abort_write', config_full_abort_write)

   end subroutine seaice_setup_nmlrec_io


   subroutine seaice_setup_nmlrec_decomposition(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      character (len=StrKIND) :: config_block_decomp_file_prefix = 'graphs/graph.info.part.'
      integer :: config_number_of_blocks = 0
      logical :: config_explicit_proc_decomp = .false.
      character (len=StrKIND) :: config_proc_decomp_file_prefix = 'graphs/graph.info.part.'
      logical :: config_use_halo_exch = .true.
      logical :: config_aggregate_halo_exch = .false.
      logical :: config_reuse_halo_exch = .false.
      logical :: config_load_balance_timers = .false.

      namelist /decomposition/ &
         config_block_decomp_file_prefix, &
         config_number_of_blocks, &
         config_explicit_proc_decomp, &
         config_proc_decomp_file_prefix, &
         config_use_halo_exch, &
         config_aggregate_halo_exch, &
         config_reuse_halo_exch, &
         config_load_balance_timers
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, decomposition, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_char(dminfo, config_block_decomp_file_prefix)
         call mpas_dmpar_bcast_int(dminfo, config_number_of_blocks)
         call mpas_dmpar_bcast_logical(dminfo, config_explicit_proc_decomp)
         call mpas_dmpar_bcast_char(dminfo, config_proc_decomp_file_prefix)
         call mpas_dmpar_bcast_logical(dminfo, config_use_halo_exch)
         call mpas_dmpar_bcast_logical(dminfo, config_aggregate_halo_exch)
         call mpas_dmpar_bcast_logical(dminfo, config_reuse_halo_exch)
         call mpas_dmpar_bcast_logical(dminfo, config_load_balance_timers)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record decomposition')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_block_decomp_file_prefix = '&
//''//mpas_log_escape_dollars(config_block_decomp_file_prefix))
            call mpas_log_write('        config_number_of_blocks = $i', intArgs=(/config_number_of_blocks/))
            call mpas_log_write('        config_explicit_proc_decomp = $l', logicArgs=(/config_explicit_proc_decomp/))
            call mpas_log_write('        config_proc_decomp_file_prefix = '&
//''//mpas_log_escape_dollars(config_proc_decomp_file_prefix))
            call mpas_log_write('        config_use_halo_exch = $l', logicArgs=(/config_use_halo_exch/))
            call mpas_log_write('        config_aggregate_halo_exch = $l', logicArgs=(/config_aggregate_halo_exch/))
            call mpas_log_write('        config_reuse_halo_exch = $l', logicArgs=(/config_reuse_halo_exch/))
            call mpas_log_write('        config_load_balance_timers = $l', logicArgs=(/config_load_balance_timers/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record decomposition.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_block_decomp_file_prefix', config_block_decomp_file_prefix)
      call mpas_pool_add_config(configPool, 'config_number_of_blocks', config_number_of_blocks)
      call mpas_pool_add_config(configPool, 'config_explicit_proc_decomp', config_explicit_proc_decomp)
      call mpas_pool_add_config(configPool, 'config_proc_decomp_file_prefix', config_proc_decomp_file_prefix)
      call mpas_pool_add_config(configPool, 'config_use_halo_exch', config_use_halo_exch)
      call mpas_pool_add_config(configPool, 'config_aggregate_halo_exch', config_aggregate_halo_exch)
      call mpas_pool_add_config(configPool, 'config_reuse_halo_exch', config_reuse_halo_exch)
      call mpas_pool_add_config(configPool, 'config_load_balance_timers', config_load_balance_timers)

   end subroutine seaice_setup_nmlrec_decomposition


   subroutine seaice_setup_nmlrec_restart(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_do_restart = .false.
      character (len=StrKIND) :: config_restart_timestamp_name = 'restart_timestamp'
      logical :: config_do_restart_hbrine = .false.
      logical :: config_do_restart_zsalinity = .false.
      logical :: config_do_restart_bgc = .false.
      logical :: config_do_restart_snow_density = .false.
      logical :: config_do_restart_snow_grain_radius = .false.

      namelist /restart/ &
         config_do_restart, &
         config_restart_timestamp_name, &
         config_do_restart_hbrine, &
         config_do_restart_zsalinity, &
         config_do_restart_bgc, &
         config_do_restart_snow_density, &
         config_do_restart_snow_grain_radius
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, restart, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_do_restart)
         call mpas_dmpar_bcast_char(dminfo, config_restart_timestamp_name)
         call mpas_dmpar_bcast_logical(dminfo, config_do_restart_hbrine)
         call mpas_dmpar_bcast_logical(dminfo, config_do_restart_zsalinity)
         call mpas_dmpar_bcast_logical(dminfo, config_do_restart_bgc)
         call mpas_dmpar_bcast_logical(dminfo, config_do_restart_snow_density)
         call mpas_dmpar_bcast_logical(dminfo, config_do_restart_snow_grain_radius)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record restart')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_do_restart = $l', logicArgs=(/config_do_restart/))
            call mpas_log_write('        config_restart_timestamp_name = '//mpas_log_escape_dollars(config_restart_timestamp_name))
            call mpas_log_write('        config_do_restart_hbrine = $l', logicArgs=(/config_do_restart_hbrine/))
            call mpas_log_write('        config_do_restart_zsalinity = $l', logicArgs=(/config_do_restart_zsalinity/))
            call mpas_log_write('        config_do_restart_bgc = $l', logicArgs=(/config_do_restart_bgc/))
            call mpas_log_write('        config_do_restart_snow_density = $l', logicArgs=(/config_do_restart_snow_density/))
            call mpas_log_write('        config_do_restart_snow_grain_radius = $l', &
logicArgs=(/config_do_restart_snow_grain_radius/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record restart.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_do_restart', config_do_restart)
      call mpas_pool_add_config(configPool, 'config_restart_timestamp_name', config_restart_timestamp_name)
      call mpas_pool_add_config(configPool, 'config_do_restart_hbrine', config_do_restart_hbrine)
      call mpas_pool_add_config(configPool, 'config_do_restart_zsalinity', config_do_restart_zsalinity)
      call mpas_pool_add_config(configPool, 'config_do_restart_bgc', config_do_restart_bgc)
      call mpas_pool_add_config(configPool, 'config_do_restart_snow_density', config_do_restart_snow_density)
      call mpas_pool_add_config(configPool, 'config_do_restart_snow_grain_radius', config_do_restart_snow_grain_radius)

   end subroutine seaice_setup_nmlrec_restart


   subroutine seaice_setup_nmlrec_dimensions(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      integer :: config_nCategories = 5
      integer :: config_nIceLayers = 7
      integer :: config_nSnowLayers = 1

      namelist /dimensions/ &
         config_nCategories, &
         config_nIceLayers, &
         config_nSnowLayers
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, dimensions, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_int(dminfo, config_nCategories)
         call mpas_dmpar_bcast_int(dminfo, config_nIceLayers)
         call mpas_dmpar_bcast_int(dminfo, config_nSnowLayers)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record dimensions')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_nCategories = $i', intArgs=(/config_nCategories/))
            call mpas_log_write('        config_nIceLayers = $i', intArgs=(/config_nIceLayers/))
            call mpas_log_write('        config_nSnowLayers = $i', intArgs=(/config_nSnowLayers/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record dimensions.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_nCategories', config_nCategories)
      call mpas_pool_add_config(configPool, 'config_nIceLayers', config_nIceLayers)
      call mpas_pool_add_config(configPool, 'config_nSnowLayers', config_nSnowLayers)

   end subroutine seaice_setup_nmlrec_dimensions


   subroutine seaice_setup_nmlrec_initialize(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      real (kind=RKIND) :: config_earth_radius = 6371229.000000
      character (len=StrKIND) :: config_initial_condition_type = 'cice_default'
      real (kind=RKIND) :: config_initial_ice_area = 1.000000
      real (kind=RKIND) :: config_initial_ice_volume = 1.000000
      real (kind=RKIND) :: config_initial_snow_volume = 0.000000
      real (kind=RKIND) :: config_initial_latitude_north = 70.000000
      real (kind=RKIND) :: config_initial_latitude_south = -60.000000
      character (len=StrKIND) :: config_initial_velocity_type = 'uniform'
      real (kind=RKIND) :: config_initial_uvelocity = 0.000000
      real (kind=RKIND) :: config_initial_vvelocity = 0.000000
      logical :: config_calculate_coriolis = .true.

      namelist /initialize/ &
         config_earth_radius, &
         config_initial_condition_type, &
         config_initial_ice_area, &
         config_initial_ice_volume, &
         config_initial_snow_volume, &
         config_initial_latitude_north, &
         config_initial_latitude_south, &
         config_initial_velocity_type, &
         config_initial_uvelocity, &
         config_initial_vvelocity, &
         config_calculate_coriolis
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, initialize, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_real(dminfo, config_earth_radius)
         call mpas_dmpar_bcast_char(dminfo, config_initial_condition_type)
         call mpas_dmpar_bcast_real(dminfo, config_initial_ice_area)
         call mpas_dmpar_bcast_real(dminfo, config_initial_ice_volume)
         call mpas_dmpar_bcast_real(dminfo, config_initial_snow_volume)
         call mpas_dmpar_bcast_real(dminfo, config_initial_latitude_north)
         call mpas_dmpar_bcast_real(dminfo, config_initial_latitude_south)
         call mpas_dmpar_bcast_char(dminfo, config_initial_velocity_type)
         call mpas_dmpar_bcast_real(dminfo, config_initial_uvelocity)
         call mpas_dmpar_bcast_real(dminfo, config_initial_vvelocity)
         call mpas_dmpar_bcast_logical(dminfo, config_calculate_coriolis)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record initialize')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_earth_radius = $r', realArgs=(/config_earth_radius/))
            call mpas_log_write('        config_initial_condition_type = '//mpas_log_escape_dollars(config_initial_condition_type))
            call mpas_log_write('        config_initial_ice_area = $r', realArgs=(/config_initial_ice_area/))
            call mpas_log_write('        config_initial_ice_volume = $r', realArgs=(/config_initial_ice_volume/))
            call mpas_log_write('        config_initial_snow_volume = $r', realArgs=(/config_initial_snow_volume/))
            call mpas_log_write('        config_initial_latitude_north = $r', realArgs=(/config_initial_latitude_north/))
            call mpas_log_write('        config_initial_latitude_south = $r', realArgs=(/config_initial_latitude_south/))
            call mpas_log_write('        config_initial_velocity_type = '//mpas_log_escape_dollars(config_initial_velocity_type))
            call mpas_log_write('        config_initial_uvelocity = $r', realArgs=(/config_initial_uvelocity/))
            call mpas_log_write('        config_initial_vvelocity = $r', realArgs=(/config_initial_vvelocity/))
            call mpas_log_write('        config_calculate_coriolis = $l', logicArgs=(/config_calculate_coriolis/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record initialize.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_earth_radius', config_earth_radius)
      call mpas_pool_add_config(configPool, 'config_initial_condition_type', config_initial_condition_type)
      call mpas_pool_add_config(configPool, 'config_initial_ice_area', config_initial_ice_area)
      call mpas_pool_add_config(configPool, 'config_initial_ice_volume', config_initial_ice_volume)
      call mpas_pool_add_config(configPool, 'config_initial_snow_volume', config_initial_snow_volume)
      call mpas_pool_add_config(configPool, 'config_initial_latitude_north', config_initial_latitude_north)
      call mpas_pool_add_config(configPool, 'config_initial_latitude_south', config_initial_latitude_south)
      call mpas_pool_add_config(configPool, 'config_initial_velocity_type', config_initial_velocity_type)
      call mpas_pool_add_config(configPool, 'config_initial_uvelocity', config_initial_uvelocity)
      call mpas_pool_add_config(configPool, 'config_initial_vvelocity', config_initial_vvelocity)
      call mpas_pool_add_config(configPool, 'config_calculate_coriolis', config_calculate_coriolis)

   end subroutine seaice_setup_nmlrec_initialize


   subroutine seaice_setup_nmlrec_use_sections(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_use_dynamics = .true.
      logical :: config_use_velocity_solver = .true.
      logical :: config_use_advection = .true.
      logical :: config_use_forcing = .true.
      logical :: config_use_column_package = .true.
      logical :: config_use_prescribed_ice = .false.
      logical :: config_use_prescribed_ice_forcing = .false.

      namelist /use_sections/ &
         config_use_dynamics, &
         config_use_velocity_solver, &
         config_use_advection, &
         config_use_forcing, &
         config_use_column_package, &
         config_use_prescribed_ice, &
         config_use_prescribed_ice_forcing
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, use_sections, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_use_dynamics)
         call mpas_dmpar_bcast_logical(dminfo, config_use_velocity_solver)
         call mpas_dmpar_bcast_logical(dminfo, config_use_advection)
         call mpas_dmpar_bcast_logical(dminfo, config_use_forcing)
         call mpas_dmpar_bcast_logical(dminfo, config_use_column_package)
         call mpas_dmpar_bcast_logical(dminfo, config_use_prescribed_ice)
         call mpas_dmpar_bcast_logical(dminfo, config_use_prescribed_ice_forcing)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record use_sections')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_use_dynamics = $l', logicArgs=(/config_use_dynamics/))
            call mpas_log_write('        config_use_velocity_solver = $l', logicArgs=(/config_use_velocity_solver/))
            call mpas_log_write('        config_use_advection = $l', logicArgs=(/config_use_advection/))
            call mpas_log_write('        config_use_forcing = $l', logicArgs=(/config_use_forcing/))
            call mpas_log_write('        config_use_column_package = $l', logicArgs=(/config_use_column_package/))
            call mpas_log_write('        config_use_prescribed_ice = $l', logicArgs=(/config_use_prescribed_ice/))
            call mpas_log_write('        config_use_prescribed_ice_forcing = $l', logicArgs=(/config_use_prescribed_ice_forcing/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record use_sections.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_use_dynamics', config_use_dynamics)
      call mpas_pool_add_config(configPool, 'config_use_velocity_solver', config_use_velocity_solver)
      call mpas_pool_add_config(configPool, 'config_use_advection', config_use_advection)
      call mpas_pool_add_config(configPool, 'config_use_forcing', config_use_forcing)
      call mpas_pool_add_config(configPool, 'config_use_column_package', config_use_column_package)
      call mpas_pool_add_config(configPool, 'config_use_prescribed_ice', config_use_prescribed_ice)
      call mpas_pool_add_config(configPool, 'config_use_prescribed_ice_forcing', config_use_prescribed_ice_forcing)

   end subroutine seaice_setup_nmlrec_use_sections


   subroutine seaice_setup_nmlrec_forcing(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      character (len=StrKIND) :: config_atmospheric_forcing_type = 'CORE'
      character (len=StrKIND) :: config_forcing_start_time = '2000-01-01_00:00:00'
      character (len=StrKIND) :: config_forcing_cycle_start = '2000-01-01_00:00:00'
      character (len=StrKIND) :: config_forcing_cycle_duration = '2-00-00_00:00:00'
      character (len=StrKIND) :: config_forcing_precipitation_units = 'mm_per_sec'
      character (len=StrKIND) :: config_forcing_sst_type = 'ncar'
      logical :: config_update_ocean_fluxes = .false.
      logical :: config_include_pond_freshwater_feedback = .false.

      namelist /forcing/ &
         config_atmospheric_forcing_type, &
         config_forcing_start_time, &
         config_forcing_cycle_start, &
         config_forcing_cycle_duration, &
         config_forcing_precipitation_units, &
         config_forcing_sst_type, &
         config_update_ocean_fluxes, &
         config_include_pond_freshwater_feedback
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, forcing, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_char(dminfo, config_atmospheric_forcing_type)
         call mpas_dmpar_bcast_char(dminfo, config_forcing_start_time)
         call mpas_dmpar_bcast_char(dminfo, config_forcing_cycle_start)
         call mpas_dmpar_bcast_char(dminfo, config_forcing_cycle_duration)
         call mpas_dmpar_bcast_char(dminfo, config_forcing_precipitation_units)
         call mpas_dmpar_bcast_char(dminfo, config_forcing_sst_type)
         call mpas_dmpar_bcast_logical(dminfo, config_update_ocean_fluxes)
         call mpas_dmpar_bcast_logical(dminfo, config_include_pond_freshwater_feedback)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record forcing')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_atmospheric_forcing_type = '&
//''//mpas_log_escape_dollars(config_atmospheric_forcing_type))
            call mpas_log_write('        config_forcing_start_time = '//mpas_log_escape_dollars(config_forcing_start_time))
            call mpas_log_write('        config_forcing_cycle_start = '//mpas_log_escape_dollars(config_forcing_cycle_start))
            call mpas_log_write('        config_forcing_cycle_duration = '//mpas_log_escape_dollars(config_forcing_cycle_duration))
            call mpas_log_write('        config_forcing_precipitation_units = '&
//''//mpas_log_escape_dollars(config_forcing_precipitation_units))
            call mpas_log_write('        config_forcing_sst_type = '//mpas_log_escape_dollars(config_forcing_sst_type))
            call mpas_log_write('        config_update_ocean_fluxes = $l', logicArgs=(/config_update_ocean_fluxes/))
            call mpas_log_write('        config_include_pond_freshwater_feedback = $l', &
logicArgs=(/config_include_pond_freshwater_feedback/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record forcing.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_atmospheric_forcing_type', config_atmospheric_forcing_type)
      call mpas_pool_add_config(configPool, 'config_forcing_start_time', config_forcing_start_time)
      call mpas_pool_add_config(configPool, 'config_forcing_cycle_start', config_forcing_cycle_start)
      call mpas_pool_add_config(configPool, 'config_forcing_cycle_duration', config_forcing_cycle_duration)
      call mpas_pool_add_config(configPool, 'config_forcing_precipitation_units', config_forcing_precipitation_units)
      call mpas_pool_add_config(configPool, 'config_forcing_sst_type', config_forcing_sst_type)
      call mpas_pool_add_config(configPool, 'config_update_ocean_fluxes', config_update_ocean_fluxes)
      call mpas_pool_add_config(configPool, 'config_include_pond_freshwater_feedback', config_include_pond_freshwater_feedback)

   end subroutine seaice_setup_nmlrec_forcing


   subroutine seaice_setup_nmlrec_testing(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_use_test_ice_shelf = .false.
      logical :: config_testing_system_test = .false.

      namelist /testing/ &
         config_use_test_ice_shelf, &
         config_testing_system_test
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, testing, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_use_test_ice_shelf)
         call mpas_dmpar_bcast_logical(dminfo, config_testing_system_test)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record testing')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_use_test_ice_shelf = $l', logicArgs=(/config_use_test_ice_shelf/))
            call mpas_log_write('        config_testing_system_test = $l', logicArgs=(/config_testing_system_test/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record testing.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_use_test_ice_shelf', config_use_test_ice_shelf)
      call mpas_pool_add_config(configPool, 'config_testing_system_test', config_testing_system_test)

   end subroutine seaice_setup_nmlrec_testing


   subroutine seaice_setup_nmlrec_velocity_solver(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      integer :: config_dynamics_subcycle_number = 1
      logical :: config_rotate_cartesian_grid = .true.
      logical :: config_include_metric_terms = .true.
      integer :: config_elastic_subcycle_number = 120
      character (len=StrKIND) :: config_strain_scheme = 'variational'
      character (len=StrKIND) :: config_constitutive_relation_type = 'evp'
      character (len=StrKIND) :: config_stress_divergence_scheme = 'variational'
      character (len=StrKIND) :: config_variational_basis = 'wachspress'
      character (len=StrKIND) :: config_variational_denominator_type = 'original'
      character (len=StrKIND) :: config_wachspress_integration_type = 'dunavant'
      integer :: config_wachspress_integration_order = 8
      logical :: config_calc_velocity_masks = .true.
      logical :: config_average_variational_strain = .false.
      logical :: config_use_air_stress = .true.
      logical :: config_use_ocean_stress = .true.
      logical :: config_use_surface_tilt = .true.
      logical :: config_geostrophic_surface_tilt = .true.
      character (len=StrKIND) :: config_ocean_stress_type = 'quadratic'
      logical :: config_use_special_boundaries_velocity = .false.
      logical :: config_use_special_boundaries_velocity_masks = .false.
      logical :: config_use_c_grid = .false.
      logical :: config_use_projected_b_grid = .false.

      namelist /velocity_solver/ &
         config_dynamics_subcycle_number, &
         config_rotate_cartesian_grid, &
         config_include_metric_terms, &
         config_elastic_subcycle_number, &
         config_strain_scheme, &
         config_constitutive_relation_type, &
         config_stress_divergence_scheme, &
         config_variational_basis, &
         config_variational_denominator_type, &
         config_wachspress_integration_type, &
         config_wachspress_integration_order, &
         config_calc_velocity_masks, &
         config_average_variational_strain, &
         config_use_air_stress, &
         config_use_ocean_stress, &
         config_use_surface_tilt, &
         config_geostrophic_surface_tilt, &
         config_ocean_stress_type, &
         config_use_special_boundaries_velocity, &
         config_use_special_boundaries_velocity_masks, &
         config_use_c_grid, &
         config_use_projected_b_grid
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, velocity_solver, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_int(dminfo, config_dynamics_subcycle_number)
         call mpas_dmpar_bcast_logical(dminfo, config_rotate_cartesian_grid)
         call mpas_dmpar_bcast_logical(dminfo, config_include_metric_terms)
         call mpas_dmpar_bcast_int(dminfo, config_elastic_subcycle_number)
         call mpas_dmpar_bcast_char(dminfo, config_strain_scheme)
         call mpas_dmpar_bcast_char(dminfo, config_constitutive_relation_type)
         call mpas_dmpar_bcast_char(dminfo, config_stress_divergence_scheme)
         call mpas_dmpar_bcast_char(dminfo, config_variational_basis)
         call mpas_dmpar_bcast_char(dminfo, config_variational_denominator_type)
         call mpas_dmpar_bcast_char(dminfo, config_wachspress_integration_type)
         call mpas_dmpar_bcast_int(dminfo, config_wachspress_integration_order)
         call mpas_dmpar_bcast_logical(dminfo, config_calc_velocity_masks)
         call mpas_dmpar_bcast_logical(dminfo, config_average_variational_strain)
         call mpas_dmpar_bcast_logical(dminfo, config_use_air_stress)
         call mpas_dmpar_bcast_logical(dminfo, config_use_ocean_stress)
         call mpas_dmpar_bcast_logical(dminfo, config_use_surface_tilt)
         call mpas_dmpar_bcast_logical(dminfo, config_geostrophic_surface_tilt)
         call mpas_dmpar_bcast_char(dminfo, config_ocean_stress_type)
         call mpas_dmpar_bcast_logical(dminfo, config_use_special_boundaries_velocity)
         call mpas_dmpar_bcast_logical(dminfo, config_use_special_boundaries_velocity_masks)
         call mpas_dmpar_bcast_logical(dminfo, config_use_c_grid)
         call mpas_dmpar_bcast_logical(dminfo, config_use_projected_b_grid)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record velocity_solver')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_dynamics_subcycle_number = $i', intArgs=(/config_dynamics_subcycle_number/))
            call mpas_log_write('        config_rotate_cartesian_grid = $l', logicArgs=(/config_rotate_cartesian_grid/))
            call mpas_log_write('        config_include_metric_terms = $l', logicArgs=(/config_include_metric_terms/))
            call mpas_log_write('        config_elastic_subcycle_number = $i', intArgs=(/config_elastic_subcycle_number/))
            call mpas_log_write('        config_strain_scheme = '//mpas_log_escape_dollars(config_strain_scheme))
            call mpas_log_write('        config_constitutive_relation_type = '&
//''//mpas_log_escape_dollars(config_constitutive_relation_type))
            call mpas_log_write('        config_stress_divergence_scheme = '&
//''//mpas_log_escape_dollars(config_stress_divergence_scheme))
            call mpas_log_write('        config_variational_basis = '//mpas_log_escape_dollars(config_variational_basis))
            call mpas_log_write('        config_variational_denominator_type = '&
//''//mpas_log_escape_dollars(config_variational_denominator_type))
            call mpas_log_write('        config_wachspress_integration_type = '&
//''//mpas_log_escape_dollars(config_wachspress_integration_type))
            call mpas_log_write('        config_wachspress_integration_order = $i', &
intArgs=(/config_wachspress_integration_order/))
            call mpas_log_write('        config_calc_velocity_masks = $l', logicArgs=(/config_calc_velocity_masks/))
            call mpas_log_write('        config_average_variational_strain = $l', logicArgs=(/config_average_variational_strain/))
            call mpas_log_write('        config_use_air_stress = $l', logicArgs=(/config_use_air_stress/))
            call mpas_log_write('        config_use_ocean_stress = $l', logicArgs=(/config_use_ocean_stress/))
            call mpas_log_write('        config_use_surface_tilt = $l', logicArgs=(/config_use_surface_tilt/))
            call mpas_log_write('        config_geostrophic_surface_tilt = $l', logicArgs=(/config_geostrophic_surface_tilt/))
            call mpas_log_write('        config_ocean_stress_type = '//mpas_log_escape_dollars(config_ocean_stress_type))
            call mpas_log_write('        config_use_special_boundaries_velocity = $l', &
logicArgs=(/config_use_special_boundaries_velocity/))
            call mpas_log_write('        config_use_special_boundaries_velocity_masks = $l', &
logicArgs=(/config_use_special_boundaries_velocity_masks/))
            call mpas_log_write('        config_use_c_grid = $l', logicArgs=(/config_use_c_grid/))
            call mpas_log_write('        config_use_projected_b_grid = $l', logicArgs=(/config_use_projected_b_grid/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record velocity_solver.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_dynamics_subcycle_number', config_dynamics_subcycle_number)
      call mpas_pool_add_config(configPool, 'config_rotate_cartesian_grid', config_rotate_cartesian_grid)
      call mpas_pool_add_config(configPool, 'config_include_metric_terms', config_include_metric_terms)
      call mpas_pool_add_config(configPool, 'config_elastic_subcycle_number', config_elastic_subcycle_number)
      call mpas_pool_add_config(configPool, 'config_strain_scheme', config_strain_scheme)
      call mpas_pool_add_config(configPool, 'config_constitutive_relation_type', config_constitutive_relation_type)
      call mpas_pool_add_config(configPool, 'config_stress_divergence_scheme', config_stress_divergence_scheme)
      call mpas_pool_add_config(configPool, 'config_variational_basis', config_variational_basis)
      call mpas_pool_add_config(configPool, 'config_variational_denominator_type', config_variational_denominator_type)
      call mpas_pool_add_config(configPool, 'config_wachspress_integration_type', config_wachspress_integration_type)
      call mpas_pool_add_config(configPool, 'config_wachspress_integration_order', config_wachspress_integration_order)
      call mpas_pool_add_config(configPool, 'config_calc_velocity_masks', config_calc_velocity_masks)
      call mpas_pool_add_config(configPool, 'config_average_variational_strain', config_average_variational_strain)
      call mpas_pool_add_config(configPool, 'config_use_air_stress', config_use_air_stress)
      call mpas_pool_add_config(configPool, 'config_use_ocean_stress', config_use_ocean_stress)
      call mpas_pool_add_config(configPool, 'config_use_surface_tilt', config_use_surface_tilt)
      call mpas_pool_add_config(configPool, 'config_geostrophic_surface_tilt', config_geostrophic_surface_tilt)
      call mpas_pool_add_config(configPool, 'config_ocean_stress_type', config_ocean_stress_type)
      call mpas_pool_add_config(configPool, 'config_use_special_boundaries_velocity', config_use_special_boundaries_velocity)
      call mpas_pool_add_config(configPool, 'config_use_special_boundaries_velocity_masks', &
config_use_special_boundaries_velocity_masks)
      call mpas_pool_add_config(configPool, 'config_use_c_grid', config_use_c_grid)
      call mpas_pool_add_config(configPool, 'config_use_projected_b_grid', config_use_projected_b_grid)

   end subroutine seaice_setup_nmlrec_velocity_solver


   subroutine seaice_setup_nmlrec_advection(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      character (len=StrKIND) :: config_advection_type = 'incremental_remap'
      logical :: config_monotonic = .true.
      logical :: config_conservation_check = .false.
      logical :: config_monotonicity_check = .false.
      logical :: config_recover_tracer_means_check = .false.

      namelist /advection/ &
         config_advection_type, &
         config_monotonic, &
         config_conservation_check, &
         config_monotonicity_check, &
         config_recover_tracer_means_check
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, advection, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_char(dminfo, config_advection_type)
         call mpas_dmpar_bcast_logical(dminfo, config_monotonic)
         call mpas_dmpar_bcast_logical(dminfo, config_conservation_check)
         call mpas_dmpar_bcast_logical(dminfo, config_monotonicity_check)
         call mpas_dmpar_bcast_logical(dminfo, config_recover_tracer_means_check)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record advection')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_advection_type = '//mpas_log_escape_dollars(config_advection_type))
            call mpas_log_write('        config_monotonic = $l', logicArgs=(/config_monotonic/))
            call mpas_log_write('        config_conservation_check = $l', logicArgs=(/config_conservation_check/))
            call mpas_log_write('        config_monotonicity_check = $l', logicArgs=(/config_monotonicity_check/))
            call mpas_log_write('        config_recover_tracer_means_check = $l', logicArgs=(/config_recover_tracer_means_check/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record advection.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_advection_type', config_advection_type)
      call mpas_pool_add_config(configPool, 'config_monotonic', config_monotonic)
      call mpas_pool_add_config(configPool, 'config_conservation_check', config_conservation_check)
      call mpas_pool_add_config(configPool, 'config_monotonicity_check', config_monotonicity_check)
      call mpas_pool_add_config(configPool, 'config_recover_tracer_means_check', config_recover_tracer_means_check)

   end subroutine seaice_setup_nmlrec_advection


   subroutine seaice_setup_nmlrec_column_package(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_use_column_shortwave = .true.
      logical :: config_use_column_vertical_thermodynamics = .true.
      logical :: config_use_column_biogeochemistry = .false.
      logical :: config_use_column_itd_thermodynamics = .true.
      logical :: config_use_column_ridging = .true.
      logical :: config_use_column_snow_tracers = .false.

      namelist /column_package/ &
         config_use_column_shortwave, &
         config_use_column_vertical_thermodynamics, &
         config_use_column_biogeochemistry, &
         config_use_column_itd_thermodynamics, &
         config_use_column_ridging, &
         config_use_column_snow_tracers
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, column_package, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_use_column_shortwave)
         call mpas_dmpar_bcast_logical(dminfo, config_use_column_vertical_thermodynamics)
         call mpas_dmpar_bcast_logical(dminfo, config_use_column_biogeochemistry)
         call mpas_dmpar_bcast_logical(dminfo, config_use_column_itd_thermodynamics)
         call mpas_dmpar_bcast_logical(dminfo, config_use_column_ridging)
         call mpas_dmpar_bcast_logical(dminfo, config_use_column_snow_tracers)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record column_package')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_use_column_shortwave = $l', logicArgs=(/config_use_column_shortwave/))
            call mpas_log_write('        config_use_column_vertical_thermodynamics = $l', &
logicArgs=(/config_use_column_vertical_thermodynamics/))
            call mpas_log_write('        config_use_column_biogeochemistry = $l', logicArgs=(/config_use_column_biogeochemistry/))
            call mpas_log_write('        config_use_column_itd_thermodynamics = $l', &
logicArgs=(/config_use_column_itd_thermodynamics/))
            call mpas_log_write('        config_use_column_ridging = $l', logicArgs=(/config_use_column_ridging/))
            call mpas_log_write('        config_use_column_snow_tracers = $l', logicArgs=(/config_use_column_snow_tracers/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record column_package.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_use_column_shortwave', config_use_column_shortwave)
      call mpas_pool_add_config(configPool, 'config_use_column_vertical_thermodynamics', config_use_column_vertical_thermodynamics)
      call mpas_pool_add_config(configPool, 'config_use_column_biogeochemistry', config_use_column_biogeochemistry)
      call mpas_pool_add_config(configPool, 'config_use_column_itd_thermodynamics', config_use_column_itd_thermodynamics)
      call mpas_pool_add_config(configPool, 'config_use_column_ridging', config_use_column_ridging)
      call mpas_pool_add_config(configPool, 'config_use_column_snow_tracers', config_use_column_snow_tracers)

   end subroutine seaice_setup_nmlrec_column_package


   subroutine seaice_setup_nmlrec_column_tracers(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_use_ice_age = .true.
      logical :: config_use_first_year_ice = .true.
      logical :: config_use_level_ice = .true.
      logical :: config_use_cesm_meltponds = .false.
      logical :: config_use_level_meltponds = .true.
      logical :: config_use_topo_meltponds = .false.
      logical :: config_use_aerosols = .false.
      logical :: config_use_effective_snow_density = .false.
      logical :: config_use_snow_grain_radius = .false.
      logical :: config_use_special_boundaries_zero_tracers = .false.

      namelist /column_tracers/ &
         config_use_ice_age, &
         config_use_first_year_ice, &
         config_use_level_ice, &
         config_use_cesm_meltponds, &
         config_use_level_meltponds, &
         config_use_topo_meltponds, &
         config_use_aerosols, &
         config_use_effective_snow_density, &
         config_use_snow_grain_radius, &
         config_use_special_boundaries_zero_tracers
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, column_tracers, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_use_ice_age)
         call mpas_dmpar_bcast_logical(dminfo, config_use_first_year_ice)
         call mpas_dmpar_bcast_logical(dminfo, config_use_level_ice)
         call mpas_dmpar_bcast_logical(dminfo, config_use_cesm_meltponds)
         call mpas_dmpar_bcast_logical(dminfo, config_use_level_meltponds)
         call mpas_dmpar_bcast_logical(dminfo, config_use_topo_meltponds)
         call mpas_dmpar_bcast_logical(dminfo, config_use_aerosols)
         call mpas_dmpar_bcast_logical(dminfo, config_use_effective_snow_density)
         call mpas_dmpar_bcast_logical(dminfo, config_use_snow_grain_radius)
         call mpas_dmpar_bcast_logical(dminfo, config_use_special_boundaries_zero_tracers)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record column_tracers')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_use_ice_age = $l', logicArgs=(/config_use_ice_age/))
            call mpas_log_write('        config_use_first_year_ice = $l', logicArgs=(/config_use_first_year_ice/))
            call mpas_log_write('        config_use_level_ice = $l', logicArgs=(/config_use_level_ice/))
            call mpas_log_write('        config_use_cesm_meltponds = $l', logicArgs=(/config_use_cesm_meltponds/))
            call mpas_log_write('        config_use_level_meltponds = $l', logicArgs=(/config_use_level_meltponds/))
            call mpas_log_write('        config_use_topo_meltponds = $l', logicArgs=(/config_use_topo_meltponds/))
            call mpas_log_write('        config_use_aerosols = $l', logicArgs=(/config_use_aerosols/))
            call mpas_log_write('        config_use_effective_snow_density = $l', logicArgs=(/config_use_effective_snow_density/))
            call mpas_log_write('        config_use_snow_grain_radius = $l', logicArgs=(/config_use_snow_grain_radius/))
            call mpas_log_write('        config_use_special_boundaries_zero_tracers = $l', &
logicArgs=(/config_use_special_boundaries_zero_tracers/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record column_tracers.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_use_ice_age', config_use_ice_age)
      call mpas_pool_add_config(configPool, 'config_use_first_year_ice', config_use_first_year_ice)
      call mpas_pool_add_config(configPool, 'config_use_level_ice', config_use_level_ice)
      call mpas_pool_add_config(configPool, 'config_use_cesm_meltponds', config_use_cesm_meltponds)
      call mpas_pool_add_config(configPool, 'config_use_level_meltponds', config_use_level_meltponds)
      call mpas_pool_add_config(configPool, 'config_use_topo_meltponds', config_use_topo_meltponds)
      call mpas_pool_add_config(configPool, 'config_use_aerosols', config_use_aerosols)
      call mpas_pool_add_config(configPool, 'config_use_effective_snow_density', config_use_effective_snow_density)
      call mpas_pool_add_config(configPool, 'config_use_snow_grain_radius', config_use_snow_grain_radius)
      call mpas_pool_add_config(configPool, 'config_use_special_boundaries_zero_tracers', &
config_use_special_boundaries_zero_tracers)

   end subroutine seaice_setup_nmlrec_column_tracers


   subroutine seaice_setup_nmlrec_biogeochemistry(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_use_brine = .false.
      logical :: config_use_vertical_zsalinity = .false.
      logical :: config_use_vertical_biochemistry = .false.
      logical :: config_use_shortwave_bioabsorption = .false.
      logical :: config_use_vertical_tracers = .false.
      logical :: config_use_skeletal_biochemistry = .false.
      logical :: config_use_nitrate = .false.
      logical :: config_use_carbon = .false.
      logical :: config_use_chlorophyll = .false.
      logical :: config_use_ammonium = .false.
      logical :: config_use_silicate = .false.
      logical :: config_use_DMS = .false.
      logical :: config_use_nonreactive = .false.
      logical :: config_use_humics = .false.
      logical :: config_use_DON = .false.
      logical :: config_use_iron = .false.
      logical :: config_use_modal_aerosols = .false.
      logical :: config_use_zaerosols = .false.
      character (len=StrKIND) :: config_skeletal_bgc_flux_type = 'Jin2006'
      logical :: config_scale_initial_vertical_bgc = .false.
      real (kind=RKIND) :: config_biogrid_bottom_molecular_sublayer = 0.006000
      real (kind=RKIND) :: config_biogrid_top_molecular_sublayer = 0.006000
      real (kind=RKIND) :: config_bio_gravity_drainage_length_scale = 2.000000
      real (kind=RKIND) :: config_zsalinity_molecular_sublayer = 0.000000
      real (kind=RKIND) :: config_zsalinity_gravity_drainage_scale = 0.028000
      real (kind=RKIND) :: config_snow_porosity_at_ice_surface = -0.300000
      real (kind=RKIND) :: config_new_ice_fraction_biotracer = 1.000000
      real (kind=RKIND) :: config_fraction_biotracer_in_frazil = 0.800000
      real (kind=RKIND) :: config_ratio_Si_to_N_diatoms = 1.800000
      real (kind=RKIND) :: config_ratio_Si_to_N_small_plankton = 0.000000
      real (kind=RKIND) :: config_ratio_Si_to_N_phaeocystis = 0.000000
      real (kind=RKIND) :: config_ratio_S_to_N_diatoms = 0.030000
      real (kind=RKIND) :: config_ratio_S_to_N_small_plankton = 0.030000
      real (kind=RKIND) :: config_ratio_S_to_N_phaeocystis = 0.030000
      real (kind=RKIND) :: config_ratio_Fe_to_C_diatoms = 0.003300
      real (kind=RKIND) :: config_ratio_Fe_to_C_small_plankton = 0.003300
      real (kind=RKIND) :: config_ratio_Fe_to_C_phaeocystis = 0.100000
      real (kind=RKIND) :: config_ratio_Fe_to_N_diatoms = 0.023000
      real (kind=RKIND) :: config_ratio_Fe_to_N_small_plankton = 0.023000
      real (kind=RKIND) :: config_ratio_Fe_to_N_phaeocystis = 0.700000
      real (kind=RKIND) :: config_ratio_Fe_to_DON = 0.023000
      real (kind=RKIND) :: config_ratio_Fe_to_DOC_saccharids = 0.100000
      real (kind=RKIND) :: config_ratio_Fe_to_DOC_lipids = 0.033000
      real (kind=RKIND) :: config_respiration_fraction_of_growth = 0.050000
      real (kind=RKIND) :: config_rapid_mobile_to_stationary_time = 3600.000000
      real (kind=RKIND) :: config_long_mobile_to_stationary_time = 604800.000000
      real (kind=RKIND) :: config_algal_maximum_velocity = 0.000000
      real (kind=RKIND) :: config_ratio_Fe_to_dust = 0.035000
      real (kind=RKIND) :: config_solubility_of_Fe_in_dust = 0.005000
      real (kind=RKIND) :: config_chla_absorptivity_of_diatoms = 0.030000
      real (kind=RKIND) :: config_chla_absorptivity_of_small_plankton = 0.010000
      real (kind=RKIND) :: config_chla_absorptivity_of_phaeocystis = 0.050000
      real (kind=RKIND) :: config_light_attenuation_diatoms = 0.300000
      real (kind=RKIND) :: config_light_attenuation_small_plankton = 0.200000
      real (kind=RKIND) :: config_light_attenuation_phaeocystis = 0.170000
      real (kind=RKIND) :: config_light_inhibition_diatoms = 0.001000
      real (kind=RKIND) :: config_light_inhibition_small_plankton = 0.001000
      real (kind=RKIND) :: config_light_inhibition_phaeocystis = 0.040000
      real (kind=RKIND) :: config_maximum_growth_rate_diatoms = 1.440000
      real (kind=RKIND) :: config_maximum_growth_rate_small_plankton = 0.410000
      real (kind=RKIND) :: config_maximum_growth_rate_phaeocystis = 0.630000
      real (kind=RKIND) :: config_temperature_growth_diatoms = 0.063000
      real (kind=RKIND) :: config_temperature_growth_small_plankton = 0.063000
      real (kind=RKIND) :: config_temperature_growth_phaeocystis = 0.063000
      real (kind=RKIND) :: config_grazed_fraction_diatoms = 0.190000
      real (kind=RKIND) :: config_grazed_fraction_small_plankton = 0.190000
      real (kind=RKIND) :: config_grazed_fraction_phaeocystis = 0.190000
      real (kind=RKIND) :: config_mortality_diatoms = 0.007000
      real (kind=RKIND) :: config_mortality_small_plankton = 0.007000
      real (kind=RKIND) :: config_mortality_phaeocystis = 0.007000
      real (kind=RKIND) :: config_temperature_mortality_diatoms = 0.030000
      real (kind=RKIND) :: config_temperature_mortality_small_plankton = 0.030000
      real (kind=RKIND) :: config_temperature_mortality_phaeocystis = 0.030000
      real (kind=RKIND) :: config_exudation_diatoms = 0.000000
      real (kind=RKIND) :: config_exudation_small_plankton = 0.000000
      real (kind=RKIND) :: config_exudation_phaeocystis = 0.000000
      real (kind=RKIND) :: config_nitrate_saturation_diatoms = 1.000000
      real (kind=RKIND) :: config_nitrate_saturation_small_plankton = 1.000000
      real (kind=RKIND) :: config_nitrate_saturation_phaeocystis = 1.000000
      real (kind=RKIND) :: config_ammonium_saturation_diatoms = 0.300000
      real (kind=RKIND) :: config_ammonium_saturation_small_plankton = 0.300000
      real (kind=RKIND) :: config_ammonium_saturation_phaeocystis = 0.300000
      real (kind=RKIND) :: config_silicate_saturation_diatoms = 4.000000
      real (kind=RKIND) :: config_silicate_saturation_small_plankton = 0.000000
      real (kind=RKIND) :: config_silicate_saturation_phaeocystis = 0.000000
      real (kind=RKIND) :: config_iron_saturation_diatoms = 1.000000
      real (kind=RKIND) :: config_iron_saturation_small_plankton = 0.200000
      real (kind=RKIND) :: config_iron_saturation_phaeocystis = 0.100000
      real (kind=RKIND) :: config_fraction_spilled_to_DON = 0.600000
      real (kind=RKIND) :: config_degredation_of_DON = 0.200000
      real (kind=RKIND) :: config_fraction_DON_ammonium = 1.000000
      real (kind=RKIND) :: config_fraction_loss_to_saccharids = 0.500000
      real (kind=RKIND) :: config_fraction_loss_to_lipids = 0.500000
      real (kind=RKIND) :: config_fraction_exudation_to_saccharids = 1.000000
      real (kind=RKIND) :: config_fraction_exudation_to_lipids = 1.000000
      real (kind=RKIND) :: config_remineralization_saccharids = 0.030000
      real (kind=RKIND) :: config_remineralization_lipids = 0.030000
      real (kind=RKIND) :: config_maximum_brine_temperature = 0.000000
      real (kind=RKIND) :: config_salinity_dependence_of_growth = 1.000000
      real (kind=RKIND) :: config_minimum_optical_depth = 0.100000
      real (kind=RKIND) :: config_slopped_grazing_fraction = 0.500000
      real (kind=RKIND) :: config_excreted_fraction = 0.500000
      real (kind=RKIND) :: config_fraction_mortality_to_ammonium = 0.900000
      real (kind=RKIND) :: config_fraction_iron_remineralized = 1.000000
      real (kind=RKIND) :: config_nitrification_rate = 0.046000
      real (kind=RKIND) :: config_desorption_loss_particulate_iron = 3065.000000
      real (kind=RKIND) :: config_maximum_loss_fraction = 0.900000
      real (kind=RKIND) :: config_maximum_ratio_iron_to_saccharids = 0.200000
      real (kind=RKIND) :: config_respiration_loss_to_DMSPd = 0.900000
      real (kind=RKIND) :: config_DMSP_to_DMS_conversion_fraction = 0.700000
      real (kind=RKIND) :: config_DMSP_to_DMS_conversion_time = 5.000000
      real (kind=RKIND) :: config_DMS_oxidation_time = 12.000000
      real (kind=RKIND) :: config_mobility_type_diatoms = 0.000000
      real (kind=RKIND) :: config_mobility_type_small_plankton = 0.000000
      real (kind=RKIND) :: config_mobility_type_phaeocystis = 0.000000
      real (kind=RKIND) :: config_mobility_type_nitrate = -1.000000
      real (kind=RKIND) :: config_mobility_type_ammonium = 0.000000
      real (kind=RKIND) :: config_mobility_type_silicate = -1.000000
      real (kind=RKIND) :: config_mobility_type_DMSPp = 0.500000
      real (kind=RKIND) :: config_mobility_type_DMSPd = 0.000000
      real (kind=RKIND) :: config_mobility_type_humics = 0.000000
      real (kind=RKIND) :: config_mobility_type_saccharids = 0.000000
      real (kind=RKIND) :: config_mobility_type_lipids = 0.000000
      real (kind=RKIND) :: config_mobility_type_inorganic_carbon = -1.000000
      real (kind=RKIND) :: config_mobility_type_proteins = 0.000000
      real (kind=RKIND) :: config_mobility_type_dissolved_iron = 0.000000
      real (kind=RKIND) :: config_mobility_type_particulate_iron = 0.500000
      real (kind=RKIND) :: config_mobility_type_black_carbon1 = 0.000000
      real (kind=RKIND) :: config_mobility_type_black_carbon2 = 0.000000
      real (kind=RKIND) :: config_mobility_type_dust1 = 0.000000
      real (kind=RKIND) :: config_mobility_type_dust2 = 0.000000
      real (kind=RKIND) :: config_mobility_type_dust3 = 0.000000
      real (kind=RKIND) :: config_mobility_type_dust4 = 0.000000
      real (kind=RKIND) :: config_ratio_C_to_N_diatoms = 7.000000
      real (kind=RKIND) :: config_ratio_C_to_N_small_plankton = 7.000000
      real (kind=RKIND) :: config_ratio_C_to_N_phaeocystis = 7.000000
      real (kind=RKIND) :: config_ratio_chla_to_N_diatoms = 2.100000
      real (kind=RKIND) :: config_ratio_chla_to_N_small_plankton = 1.100000
      real (kind=RKIND) :: config_ratio_chla_to_N_phaeocystis = 0.840000
      real (kind=RKIND) :: config_scales_absorption_diatoms = 2.000000
      real (kind=RKIND) :: config_scales_absorption_small_plankton = 4.000000
      real (kind=RKIND) :: config_scales_absorption_phaeocystis = 5.000000
      real (kind=RKIND) :: config_ratio_C_to_N_proteins = 5.000000

      namelist /biogeochemistry/ &
         config_use_brine, &
         config_use_vertical_zsalinity, &
         config_use_vertical_biochemistry, &
         config_use_shortwave_bioabsorption, &
         config_use_vertical_tracers, &
         config_use_skeletal_biochemistry, &
         config_use_nitrate, &
         config_use_carbon, &
         config_use_chlorophyll, &
         config_use_ammonium, &
         config_use_silicate, &
         config_use_DMS, &
         config_use_nonreactive, &
         config_use_humics, &
         config_use_DON, &
         config_use_iron, &
         config_use_modal_aerosols, &
         config_use_zaerosols, &
         config_skeletal_bgc_flux_type, &
         config_scale_initial_vertical_bgc, &
         config_biogrid_bottom_molecular_sublayer, &
         config_biogrid_top_molecular_sublayer, &
         config_bio_gravity_drainage_length_scale, &
         config_zsalinity_molecular_sublayer, &
         config_zsalinity_gravity_drainage_scale, &
         config_snow_porosity_at_ice_surface, &
         config_new_ice_fraction_biotracer, &
         config_fraction_biotracer_in_frazil, &
         config_ratio_Si_to_N_diatoms, &
         config_ratio_Si_to_N_small_plankton, &
         config_ratio_Si_to_N_phaeocystis, &
         config_ratio_S_to_N_diatoms, &
         config_ratio_S_to_N_small_plankton, &
         config_ratio_S_to_N_phaeocystis, &
         config_ratio_Fe_to_C_diatoms, &
         config_ratio_Fe_to_C_small_plankton, &
         config_ratio_Fe_to_C_phaeocystis, &
         config_ratio_Fe_to_N_diatoms, &
         config_ratio_Fe_to_N_small_plankton, &
         config_ratio_Fe_to_N_phaeocystis, &
         config_ratio_Fe_to_DON, &
         config_ratio_Fe_to_DOC_saccharids, &
         config_ratio_Fe_to_DOC_lipids, &
         config_respiration_fraction_of_growth, &
         config_rapid_mobile_to_stationary_time, &
         config_long_mobile_to_stationary_time, &
         config_algal_maximum_velocity, &
         config_ratio_Fe_to_dust, &
         config_solubility_of_Fe_in_dust, &
         config_chla_absorptivity_of_diatoms, &
         config_chla_absorptivity_of_small_plankton, &
         config_chla_absorptivity_of_phaeocystis, &
         config_light_attenuation_diatoms, &
         config_light_attenuation_small_plankton, &
         config_light_attenuation_phaeocystis, &
         config_light_inhibition_diatoms, &
         config_light_inhibition_small_plankton, &
         config_light_inhibition_phaeocystis, &
         config_maximum_growth_rate_diatoms, &
         config_maximum_growth_rate_small_plankton, &
         config_maximum_growth_rate_phaeocystis, &
         config_temperature_growth_diatoms, &
         config_temperature_growth_small_plankton, &
         config_temperature_growth_phaeocystis, &
         config_grazed_fraction_diatoms, &
         config_grazed_fraction_small_plankton, &
         config_grazed_fraction_phaeocystis, &
         config_mortality_diatoms, &
         config_mortality_small_plankton, &
         config_mortality_phaeocystis, &
         config_temperature_mortality_diatoms, &
         config_temperature_mortality_small_plankton, &
         config_temperature_mortality_phaeocystis, &
         config_exudation_diatoms, &
         config_exudation_small_plankton, &
         config_exudation_phaeocystis, &
         config_nitrate_saturation_diatoms, &
         config_nitrate_saturation_small_plankton, &
         config_nitrate_saturation_phaeocystis, &
         config_ammonium_saturation_diatoms, &
         config_ammonium_saturation_small_plankton, &
         config_ammonium_saturation_phaeocystis, &
         config_silicate_saturation_diatoms, &
         config_silicate_saturation_small_plankton, &
         config_silicate_saturation_phaeocystis, &
         config_iron_saturation_diatoms, &
         config_iron_saturation_small_plankton, &
         config_iron_saturation_phaeocystis, &
         config_fraction_spilled_to_DON, &
         config_degredation_of_DON, &
         config_fraction_DON_ammonium, &
         config_fraction_loss_to_saccharids, &
         config_fraction_loss_to_lipids, &
         config_fraction_exudation_to_saccharids, &
         config_fraction_exudation_to_lipids, &
         config_remineralization_saccharids, &
         config_remineralization_lipids, &
         config_maximum_brine_temperature, &
         config_salinity_dependence_of_growth, &
         config_minimum_optical_depth, &
         config_slopped_grazing_fraction, &
         config_excreted_fraction, &
         config_fraction_mortality_to_ammonium, &
         config_fraction_iron_remineralized, &
         config_nitrification_rate, &
         config_desorption_loss_particulate_iron, &
         config_maximum_loss_fraction, &
         config_maximum_ratio_iron_to_saccharids, &
         config_respiration_loss_to_DMSPd, &
         config_DMSP_to_DMS_conversion_fraction, &
         config_DMSP_to_DMS_conversion_time, &
         config_DMS_oxidation_time, &
         config_mobility_type_diatoms, &
         config_mobility_type_small_plankton, &
         config_mobility_type_phaeocystis, &
         config_mobility_type_nitrate, &
         config_mobility_type_ammonium, &
         config_mobility_type_silicate, &
         config_mobility_type_DMSPp, &
         config_mobility_type_DMSPd, &
         config_mobility_type_humics, &
         config_mobility_type_saccharids, &
         config_mobility_type_lipids, &
         config_mobility_type_inorganic_carbon, &
         config_mobility_type_proteins, &
         config_mobility_type_dissolved_iron, &
         config_mobility_type_particulate_iron, &
         config_mobility_type_black_carbon1, &
         config_mobility_type_black_carbon2, &
         config_mobility_type_dust1, &
         config_mobility_type_dust2, &
         config_mobility_type_dust3, &
         config_mobility_type_dust4, &
         config_ratio_C_to_N_diatoms, &
         config_ratio_C_to_N_small_plankton, &
         config_ratio_C_to_N_phaeocystis, &
         config_ratio_chla_to_N_diatoms, &
         config_ratio_chla_to_N_small_plankton, &
         config_ratio_chla_to_N_phaeocystis, &
         config_scales_absorption_diatoms, &
         config_scales_absorption_small_plankton, &
         config_scales_absorption_phaeocystis, &
         config_ratio_C_to_N_proteins
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, biogeochemistry, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_use_brine)
         call mpas_dmpar_bcast_logical(dminfo, config_use_vertical_zsalinity)
         call mpas_dmpar_bcast_logical(dminfo, config_use_vertical_biochemistry)
         call mpas_dmpar_bcast_logical(dminfo, config_use_shortwave_bioabsorption)
         call mpas_dmpar_bcast_logical(dminfo, config_use_vertical_tracers)
         call mpas_dmpar_bcast_logical(dminfo, config_use_skeletal_biochemistry)
         call mpas_dmpar_bcast_logical(dminfo, config_use_nitrate)
         call mpas_dmpar_bcast_logical(dminfo, config_use_carbon)
         call mpas_dmpar_bcast_logical(dminfo, config_use_chlorophyll)
         call mpas_dmpar_bcast_logical(dminfo, config_use_ammonium)
         call mpas_dmpar_bcast_logical(dminfo, config_use_silicate)
         call mpas_dmpar_bcast_logical(dminfo, config_use_DMS)
         call mpas_dmpar_bcast_logical(dminfo, config_use_nonreactive)
         call mpas_dmpar_bcast_logical(dminfo, config_use_humics)
         call mpas_dmpar_bcast_logical(dminfo, config_use_DON)
         call mpas_dmpar_bcast_logical(dminfo, config_use_iron)
         call mpas_dmpar_bcast_logical(dminfo, config_use_modal_aerosols)
         call mpas_dmpar_bcast_logical(dminfo, config_use_zaerosols)
         call mpas_dmpar_bcast_char(dminfo, config_skeletal_bgc_flux_type)
         call mpas_dmpar_bcast_logical(dminfo, config_scale_initial_vertical_bgc)
         call mpas_dmpar_bcast_real(dminfo, config_biogrid_bottom_molecular_sublayer)
         call mpas_dmpar_bcast_real(dminfo, config_biogrid_top_molecular_sublayer)
         call mpas_dmpar_bcast_real(dminfo, config_bio_gravity_drainage_length_scale)
         call mpas_dmpar_bcast_real(dminfo, config_zsalinity_molecular_sublayer)
         call mpas_dmpar_bcast_real(dminfo, config_zsalinity_gravity_drainage_scale)
         call mpas_dmpar_bcast_real(dminfo, config_snow_porosity_at_ice_surface)
         call mpas_dmpar_bcast_real(dminfo, config_new_ice_fraction_biotracer)
         call mpas_dmpar_bcast_real(dminfo, config_fraction_biotracer_in_frazil)
         call mpas_dmpar_bcast_real(dminfo, config_ratio_Si_to_N_diatoms)
         call mpas_dmpar_bcast_real(dminfo, config_ratio_Si_to_N_small_plankton)
         call mpas_dmpar_bcast_real(dminfo, config_ratio_Si_to_N_phaeocystis)
         call mpas_dmpar_bcast_real(dminfo, config_ratio_S_to_N_diatoms)
         call mpas_dmpar_bcast_real(dminfo, config_ratio_S_to_N_small_plankton)
         call mpas_dmpar_bcast_real(dminfo, config_ratio_S_to_N_phaeocystis)
         call mpas_dmpar_bcast_real(dminfo, config_ratio_Fe_to_C_diatoms)
         call mpas_dmpar_bcast_real(dminfo, config_ratio_Fe_to_C_small_plankton)
         call mpas_dmpar_bcast_real(dminfo, config_ratio_Fe_to_C_phaeocystis)
         call mpas_dmpar_bcast_real(dminfo, config_ratio_Fe_to_N_diatoms)
         call mpas_dmpar_bcast_real(dminfo, config_ratio_Fe_to_N_small_plankton)
         call mpas_dmpar_bcast_real(dminfo, config_ratio_Fe_to_N_phaeocystis)
         call mpas_dmpar_bcast_real(dminfo, config_ratio_Fe_to_DON)
         call mpas_dmpar_bcast_real(dminfo, config_ratio_Fe_to_DOC_saccharids)
         call mpas_dmpar_bcast_real(dminfo, config_ratio_Fe_to_DOC_lipids)
         call mpas_dmpar_bcast_real(dminfo, config_respiration_fraction_of_growth)
         call mpas_dmpar_bcast_real(dminfo, config_rapid_mobile_to_stationary_time)
         call mpas_dmpar_bcast_real(dminfo, config_long_mobile_to_stationary_time)
         call mpas_dmpar_bcast_real(dminfo, config_algal_maximum_velocity)
         call mpas_dmpar_bcast_real(dminfo, config_ratio_Fe_to_dust)
         call mpas_dmpar_bcast_real(dminfo, config_solubility_of_Fe_in_dust)
         call mpas_dmpar_bcast_real(dminfo, config_chla_absorptivity_of_diatoms)
         call mpas_dmpar_bcast_real(dminfo, config_chla_absorptivity_of_small_plankton)
         call mpas_dmpar_bcast_real(dminfo, config_chla_absorptivity_of_phaeocystis)
         call mpas_dmpar_bcast_real(dminfo, config_light_attenuation_diatoms)
         call mpas_dmpar_bcast_real(dminfo, config_light_attenuation_small_plankton)
         call mpas_dmpar_bcast_real(dminfo, config_light_attenuation_phaeocystis)
         call mpas_dmpar_bcast_real(dminfo, config_light_inhibition_diatoms)
         call mpas_dmpar_bcast_real(dminfo, config_light_inhibition_small_plankton)
         call mpas_dmpar_bcast_real(dminfo, config_light_inhibition_phaeocystis)
         call mpas_dmpar_bcast_real(dminfo, config_maximum_growth_rate_diatoms)
         call mpas_dmpar_bcast_real(dminfo, config_maximum_growth_rate_small_plankton)
         call mpas_dmpar_bcast_real(dminfo, config_maximum_growth_rate_phaeocystis)
         call mpas_dmpar_bcast_real(dminfo, config_temperature_growth_diatoms)
         call mpas_dmpar_bcast_real(dminfo, config_temperature_growth_small_plankton)
         call mpas_dmpar_bcast_real(dminfo, config_temperature_growth_phaeocystis)
         call mpas_dmpar_bcast_real(dminfo, config_grazed_fraction_diatoms)
         call mpas_dmpar_bcast_real(dminfo, config_grazed_fraction_small_plankton)
         call mpas_dmpar_bcast_real(dminfo, config_grazed_fraction_phaeocystis)
         call mpas_dmpar_bcast_real(dminfo, config_mortality_diatoms)
         call mpas_dmpar_bcast_real(dminfo, config_mortality_small_plankton)
         call mpas_dmpar_bcast_real(dminfo, config_mortality_phaeocystis)
         call mpas_dmpar_bcast_real(dminfo, config_temperature_mortality_diatoms)
         call mpas_dmpar_bcast_real(dminfo, config_temperature_mortality_small_plankton)
         call mpas_dmpar_bcast_real(dminfo, config_temperature_mortality_phaeocystis)
         call mpas_dmpar_bcast_real(dminfo, config_exudation_diatoms)
         call mpas_dmpar_bcast_real(dminfo, config_exudation_small_plankton)
         call mpas_dmpar_bcast_real(dminfo, config_exudation_phaeocystis)
         call mpas_dmpar_bcast_real(dminfo, config_nitrate_saturation_diatoms)
         call mpas_dmpar_bcast_real(dminfo, config_nitrate_saturation_small_plankton)
         call mpas_dmpar_bcast_real(dminfo, config_nitrate_saturation_phaeocystis)
         call mpas_dmpar_bcast_real(dminfo, config_ammonium_saturation_diatoms)
         call mpas_dmpar_bcast_real(dminfo, config_ammonium_saturation_small_plankton)
         call mpas_dmpar_bcast_real(dminfo, config_ammonium_saturation_phaeocystis)
         call mpas_dmpar_bcast_real(dminfo, config_silicate_saturation_diatoms)
         call mpas_dmpar_bcast_real(dminfo, config_silicate_saturation_small_plankton)
         call mpas_dmpar_bcast_real(dminfo, config_silicate_saturation_phaeocystis)
         call mpas_dmpar_bcast_real(dminfo, config_iron_saturation_diatoms)
         call mpas_dmpar_bcast_real(dminfo, config_iron_saturation_small_plankton)
         call mpas_dmpar_bcast_real(dminfo, config_iron_saturation_phaeocystis)
         call mpas_dmpar_bcast_real(dminfo, config_fraction_spilled_to_DON)
         call mpas_dmpar_bcast_real(dminfo, config_degredation_of_DON)
         call mpas_dmpar_bcast_real(dminfo, config_fraction_DON_ammonium)
         call mpas_dmpar_bcast_real(dminfo, config_fraction_loss_to_saccharids)
         call mpas_dmpar_bcast_real(dminfo, config_fraction_loss_to_lipids)
         call mpas_dmpar_bcast_real(dminfo, config_fraction_exudation_to_saccharids)
         call mpas_dmpar_bcast_real(dminfo, config_fraction_exudation_to_lipids)
         call mpas_dmpar_bcast_real(dminfo, config_remineralization_saccharids)
         call mpas_dmpar_bcast_real(dminfo, config_remineralization_lipids)
         call mpas_dmpar_bcast_real(dminfo, config_maximum_brine_temperature)
         call mpas_dmpar_bcast_real(dminfo, config_salinity_dependence_of_growth)
         call mpas_dmpar_bcast_real(dminfo, config_minimum_optical_depth)
         call mpas_dmpar_bcast_real(dminfo, config_slopped_grazing_fraction)
         call mpas_dmpar_bcast_real(dminfo, config_excreted_fraction)
         call mpas_dmpar_bcast_real(dminfo, config_fraction_mortality_to_ammonium)
         call mpas_dmpar_bcast_real(dminfo, config_fraction_iron_remineralized)
         call mpas_dmpar_bcast_real(dminfo, config_nitrification_rate)
         call mpas_dmpar_bcast_real(dminfo, config_desorption_loss_particulate_iron)
         call mpas_dmpar_bcast_real(dminfo, config_maximum_loss_fraction)
         call mpas_dmpar_bcast_real(dminfo, config_maximum_ratio_iron_to_saccharids)
         call mpas_dmpar_bcast_real(dminfo, config_respiration_loss_to_DMSPd)
         call mpas_dmpar_bcast_real(dminfo, config_DMSP_to_DMS_conversion_fraction)
         call mpas_dmpar_bcast_real(dminfo, config_DMSP_to_DMS_conversion_time)
         call mpas_dmpar_bcast_real(dminfo, config_DMS_oxidation_time)
         call mpas_dmpar_bcast_real(dminfo, config_mobility_type_diatoms)
         call mpas_dmpar_bcast_real(dminfo, config_mobility_type_small_plankton)
         call mpas_dmpar_bcast_real(dminfo, config_mobility_type_phaeocystis)
         call mpas_dmpar_bcast_real(dminfo, config_mobility_type_nitrate)
         call mpas_dmpar_bcast_real(dminfo, config_mobility_type_ammonium)
         call mpas_dmpar_bcast_real(dminfo, config_mobility_type_silicate)
         call mpas_dmpar_bcast_real(dminfo, config_mobility_type_DMSPp)
         call mpas_dmpar_bcast_real(dminfo, config_mobility_type_DMSPd)
         call mpas_dmpar_bcast_real(dminfo, config_mobility_type_humics)
         call mpas_dmpar_bcast_real(dminfo, config_mobility_type_saccharids)
         call mpas_dmpar_bcast_real(dminfo, config_mobility_type_lipids)
         call mpas_dmpar_bcast_real(dminfo, config_mobility_type_inorganic_carbon)
         call mpas_dmpar_bcast_real(dminfo, config_mobility_type_proteins)
         call mpas_dmpar_bcast_real(dminfo, config_mobility_type_dissolved_iron)
         call mpas_dmpar_bcast_real(dminfo, config_mobility_type_particulate_iron)
         call mpas_dmpar_bcast_real(dminfo, config_mobility_type_black_carbon1)
         call mpas_dmpar_bcast_real(dminfo, config_mobility_type_black_carbon2)
         call mpas_dmpar_bcast_real(dminfo, config_mobility_type_dust1)
         call mpas_dmpar_bcast_real(dminfo, config_mobility_type_dust2)
         call mpas_dmpar_bcast_real(dminfo, config_mobility_type_dust3)
         call mpas_dmpar_bcast_real(dminfo, config_mobility_type_dust4)
         call mpas_dmpar_bcast_real(dminfo, config_ratio_C_to_N_diatoms)
         call mpas_dmpar_bcast_real(dminfo, config_ratio_C_to_N_small_plankton)
         call mpas_dmpar_bcast_real(dminfo, config_ratio_C_to_N_phaeocystis)
         call mpas_dmpar_bcast_real(dminfo, config_ratio_chla_to_N_diatoms)
         call mpas_dmpar_bcast_real(dminfo, config_ratio_chla_to_N_small_plankton)
         call mpas_dmpar_bcast_real(dminfo, config_ratio_chla_to_N_phaeocystis)
         call mpas_dmpar_bcast_real(dminfo, config_scales_absorption_diatoms)
         call mpas_dmpar_bcast_real(dminfo, config_scales_absorption_small_plankton)
         call mpas_dmpar_bcast_real(dminfo, config_scales_absorption_phaeocystis)
         call mpas_dmpar_bcast_real(dminfo, config_ratio_C_to_N_proteins)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record biogeochemistry')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_use_brine = $l', logicArgs=(/config_use_brine/))
            call mpas_log_write('        config_use_vertical_zsalinity = $l', logicArgs=(/config_use_vertical_zsalinity/))
            call mpas_log_write('        config_use_vertical_biochemistry = $l', logicArgs=(/config_use_vertical_biochemistry/))
            call mpas_log_write('        config_use_shortwave_bioabsorption = $l', &
logicArgs=(/config_use_shortwave_bioabsorption/))
            call mpas_log_write('        config_use_vertical_tracers = $l', logicArgs=(/config_use_vertical_tracers/))
            call mpas_log_write('        config_use_skeletal_biochemistry = $l', logicArgs=(/config_use_skeletal_biochemistry/))
            call mpas_log_write('        config_use_nitrate = $l', logicArgs=(/config_use_nitrate/))
            call mpas_log_write('        config_use_carbon = $l', logicArgs=(/config_use_carbon/))
            call mpas_log_write('        config_use_chlorophyll = $l', logicArgs=(/config_use_chlorophyll/))
            call mpas_log_write('        config_use_ammonium = $l', logicArgs=(/config_use_ammonium/))
            call mpas_log_write('        config_use_silicate = $l', logicArgs=(/config_use_silicate/))
            call mpas_log_write('        config_use_DMS = $l', logicArgs=(/config_use_DMS/))
            call mpas_log_write('        config_use_nonreactive = $l', logicArgs=(/config_use_nonreactive/))
            call mpas_log_write('        config_use_humics = $l', logicArgs=(/config_use_humics/))
            call mpas_log_write('        config_use_DON = $l', logicArgs=(/config_use_DON/))
            call mpas_log_write('        config_use_iron = $l', logicArgs=(/config_use_iron/))
            call mpas_log_write('        config_use_modal_aerosols = $l', logicArgs=(/config_use_modal_aerosols/))
            call mpas_log_write('        config_use_zaerosols = $l', logicArgs=(/config_use_zaerosols/))
            call mpas_log_write('        config_skeletal_bgc_flux_type = '//mpas_log_escape_dollars(config_skeletal_bgc_flux_type))
            call mpas_log_write('        config_scale_initial_vertical_bgc = $l', logicArgs=(/config_scale_initial_vertical_bgc/))
            call mpas_log_write('        config_biogrid_bottom_molecular_sublayer = $r', &
realArgs=(/config_biogrid_bottom_molecular_sublayer/))
            call mpas_log_write('        config_biogrid_top_molecular_sublayer = $r', &
realArgs=(/config_biogrid_top_molecular_sublayer/))
            call mpas_log_write('        config_bio_gravity_drainage_length_scale = $r', &
realArgs=(/config_bio_gravity_drainage_length_scale/))
            call mpas_log_write('        config_zsalinity_molecular_sublayer = $r', &
realArgs=(/config_zsalinity_molecular_sublayer/))
            call mpas_log_write('        config_zsalinity_gravity_drainage_scale = $r', &
realArgs=(/config_zsalinity_gravity_drainage_scale/))
            call mpas_log_write('        config_snow_porosity_at_ice_surface = $r', &
realArgs=(/config_snow_porosity_at_ice_surface/))
            call mpas_log_write('        config_new_ice_fraction_biotracer = $r', realArgs=(/config_new_ice_fraction_biotracer/))
            call mpas_log_write('        config_fraction_biotracer_in_frazil = $r', &
realArgs=(/config_fraction_biotracer_in_frazil/))
            call mpas_log_write('        config_ratio_Si_to_N_diatoms = $r', realArgs=(/config_ratio_Si_to_N_diatoms/))
            call mpas_log_write('        config_ratio_Si_to_N_small_plankton = $r', &
realArgs=(/config_ratio_Si_to_N_small_plankton/))
            call mpas_log_write('        config_ratio_Si_to_N_phaeocystis = $r', realArgs=(/config_ratio_Si_to_N_phaeocystis/))
            call mpas_log_write('        config_ratio_S_to_N_diatoms = $r', realArgs=(/config_ratio_S_to_N_diatoms/))
            call mpas_log_write('        config_ratio_S_to_N_small_plankton = $r', realArgs=(/config_ratio_S_to_N_small_plankton/))
            call mpas_log_write('        config_ratio_S_to_N_phaeocystis = $r', realArgs=(/config_ratio_S_to_N_phaeocystis/))
            call mpas_log_write('        config_ratio_Fe_to_C_diatoms = $r', realArgs=(/config_ratio_Fe_to_C_diatoms/))
            call mpas_log_write('        config_ratio_Fe_to_C_small_plankton = $r', &
realArgs=(/config_ratio_Fe_to_C_small_plankton/))
            call mpas_log_write('        config_ratio_Fe_to_C_phaeocystis = $r', realArgs=(/config_ratio_Fe_to_C_phaeocystis/))
            call mpas_log_write('        config_ratio_Fe_to_N_diatoms = $r', realArgs=(/config_ratio_Fe_to_N_diatoms/))
            call mpas_log_write('        config_ratio_Fe_to_N_small_plankton = $r', &
realArgs=(/config_ratio_Fe_to_N_small_plankton/))
            call mpas_log_write('        config_ratio_Fe_to_N_phaeocystis = $r', realArgs=(/config_ratio_Fe_to_N_phaeocystis/))
            call mpas_log_write('        config_ratio_Fe_to_DON = $r', realArgs=(/config_ratio_Fe_to_DON/))
            call mpas_log_write('        config_ratio_Fe_to_DOC_saccharids = $r', realArgs=(/config_ratio_Fe_to_DOC_saccharids/))
            call mpas_log_write('        config_ratio_Fe_to_DOC_lipids = $r', realArgs=(/config_ratio_Fe_to_DOC_lipids/))
            call mpas_log_write('        config_respiration_fraction_of_growth = $r', &
realArgs=(/config_respiration_fraction_of_growth/))
            call mpas_log_write('        config_rapid_mobile_to_stationary_time = $r', &
realArgs=(/config_rapid_mobile_to_stationary_time/))
            call mpas_log_write('        config_long_mobile_to_stationary_time = $r', &
realArgs=(/config_long_mobile_to_stationary_time/))
            call mpas_log_write('        config_algal_maximum_velocity = $r', realArgs=(/config_algal_maximum_velocity/))
            call mpas_log_write('        config_ratio_Fe_to_dust = $r', realArgs=(/config_ratio_Fe_to_dust/))
            call mpas_log_write('        config_solubility_of_Fe_in_dust = $r', realArgs=(/config_solubility_of_Fe_in_dust/))
            call mpas_log_write('        config_chla_absorptivity_of_diatoms = $r', &
realArgs=(/config_chla_absorptivity_of_diatoms/))
            call mpas_log_write('        config_chla_absorptivity_of_small_plankton = $r', &
realArgs=(/config_chla_absorptivity_of_small_plankton/))
            call mpas_log_write('        config_chla_absorptivity_of_phaeocystis = $r', &
realArgs=(/config_chla_absorptivity_of_phaeocystis/))
            call mpas_log_write('        config_light_attenuation_diatoms = $r', realArgs=(/config_light_attenuation_diatoms/))
            call mpas_log_write('        config_light_attenuation_small_plankton = $r', &
realArgs=(/config_light_attenuation_small_plankton/))
            call mpas_log_write('        config_light_attenuation_phaeocystis = $r', &
realArgs=(/config_light_attenuation_phaeocystis/))
            call mpas_log_write('        config_light_inhibition_diatoms = $r', realArgs=(/config_light_inhibition_diatoms/))
            call mpas_log_write('        config_light_inhibition_small_plankton = $r', &
realArgs=(/config_light_inhibition_small_plankton/))
            call mpas_log_write('        config_light_inhibition_phaeocystis = $r', &
realArgs=(/config_light_inhibition_phaeocystis/))
            call mpas_log_write('        config_maximum_growth_rate_diatoms = $r', realArgs=(/config_maximum_growth_rate_diatoms/))
            call mpas_log_write('        config_maximum_growth_rate_small_plankton = $r', &
realArgs=(/config_maximum_growth_rate_small_plankton/))
            call mpas_log_write('        config_maximum_growth_rate_phaeocystis = $r', &
realArgs=(/config_maximum_growth_rate_phaeocystis/))
            call mpas_log_write('        config_temperature_growth_diatoms = $r', realArgs=(/config_temperature_growth_diatoms/))
            call mpas_log_write('        config_temperature_growth_small_plankton = $r', &
realArgs=(/config_temperature_growth_small_plankton/))
            call mpas_log_write('        config_temperature_growth_phaeocystis = $r', &
realArgs=(/config_temperature_growth_phaeocystis/))
            call mpas_log_write('        config_grazed_fraction_diatoms = $r', realArgs=(/config_grazed_fraction_diatoms/))
            call mpas_log_write('        config_grazed_fraction_small_plankton = $r', &
realArgs=(/config_grazed_fraction_small_plankton/))
            call mpas_log_write('        config_grazed_fraction_phaeocystis = $r', realArgs=(/config_grazed_fraction_phaeocystis/))
            call mpas_log_write('        config_mortality_diatoms = $r', realArgs=(/config_mortality_diatoms/))
            call mpas_log_write('        config_mortality_small_plankton = $r', realArgs=(/config_mortality_small_plankton/))
            call mpas_log_write('        config_mortality_phaeocystis = $r', realArgs=(/config_mortality_phaeocystis/))
            call mpas_log_write('        config_temperature_mortality_diatoms = $r', &
realArgs=(/config_temperature_mortality_diatoms/))
            call mpas_log_write('        config_temperature_mortality_small_plankton = $r', &
realArgs=(/config_temperature_mortality_small_plankton/))
            call mpas_log_write('        config_temperature_mortality_phaeocystis = $r', &
realArgs=(/config_temperature_mortality_phaeocystis/))
            call mpas_log_write('        config_exudation_diatoms = $r', realArgs=(/config_exudation_diatoms/))
            call mpas_log_write('        config_exudation_small_plankton = $r', realArgs=(/config_exudation_small_plankton/))
            call mpas_log_write('        config_exudation_phaeocystis = $r', realArgs=(/config_exudation_phaeocystis/))
            call mpas_log_write('        config_nitrate_saturation_diatoms = $r', realArgs=(/config_nitrate_saturation_diatoms/))
            call mpas_log_write('        config_nitrate_saturation_small_plankton = $r', &
realArgs=(/config_nitrate_saturation_small_plankton/))
            call mpas_log_write('        config_nitrate_saturation_phaeocystis = $r', &
realArgs=(/config_nitrate_saturation_phaeocystis/))
            call mpas_log_write('        config_ammonium_saturation_diatoms = $r', realArgs=(/config_ammonium_saturation_diatoms/))
            call mpas_log_write('        config_ammonium_saturation_small_plankton = $r', &
realArgs=(/config_ammonium_saturation_small_plankton/))
            call mpas_log_write('        config_ammonium_saturation_phaeocystis = $r', &
realArgs=(/config_ammonium_saturation_phaeocystis/))
            call mpas_log_write('        config_silicate_saturation_diatoms = $r', realArgs=(/config_silicate_saturation_diatoms/))
            call mpas_log_write('        config_silicate_saturation_small_plankton = $r', &
realArgs=(/config_silicate_saturation_small_plankton/))
            call mpas_log_write('        config_silicate_saturation_phaeocystis = $r', &
realArgs=(/config_silicate_saturation_phaeocystis/))
            call mpas_log_write('        config_iron_saturation_diatoms = $r', realArgs=(/config_iron_saturation_diatoms/))
            call mpas_log_write('        config_iron_saturation_small_plankton = $r', &
realArgs=(/config_iron_saturation_small_plankton/))
            call mpas_log_write('        config_iron_saturation_phaeocystis = $r', realArgs=(/config_iron_saturation_phaeocystis/))
            call mpas_log_write('        config_fraction_spilled_to_DON = $r', realArgs=(/config_fraction_spilled_to_DON/))
            call mpas_log_write('        config_degredation_of_DON = $r', realArgs=(/config_degredation_of_DON/))
            call mpas_log_write('        config_fraction_DON_ammonium = $r', realArgs=(/config_fraction_DON_ammonium/))
            call mpas_log_write('        config_fraction_loss_to_saccharids = $r', realArgs=(/config_fraction_loss_to_saccharids/))
            call mpas_log_write('        config_fraction_loss_to_lipids = $r', realArgs=(/config_fraction_loss_to_lipids/))
            call mpas_log_write('        config_fraction_exudation_to_saccharids = $r', &
realArgs=(/config_fraction_exudation_to_saccharids/))
            call mpas_log_write('        config_fraction_exudation_to_lipids = $r', &
realArgs=(/config_fraction_exudation_to_lipids/))
            call mpas_log_write('        config_remineralization_saccharids = $r', realArgs=(/config_remineralization_saccharids/))
            call mpas_log_write('        config_remineralization_lipids = $r', realArgs=(/config_remineralization_lipids/))
            call mpas_log_write('        config_maximum_brine_temperature = $r', realArgs=(/config_maximum_brine_temperature/))
            call mpas_log_write('        config_salinity_dependence_of_growth = $r', &
realArgs=(/config_salinity_dependence_of_growth/))
            call mpas_log_write('        config_minimum_optical_depth = $r', realArgs=(/config_minimum_optical_depth/))
            call mpas_log_write('        config_slopped_grazing_fraction = $r', realArgs=(/config_slopped_grazing_fraction/))
            call mpas_log_write('        config_excreted_fraction = $r', realArgs=(/config_excreted_fraction/))
            call mpas_log_write('        config_fraction_mortality_to_ammonium = $r', &
realArgs=(/config_fraction_mortality_to_ammonium/))
            call mpas_log_write('        config_fraction_iron_remineralized = $r', realArgs=(/config_fraction_iron_remineralized/))
            call mpas_log_write('        config_nitrification_rate = $r', realArgs=(/config_nitrification_rate/))
            call mpas_log_write('        config_desorption_loss_particulate_iron = $r', &
realArgs=(/config_desorption_loss_particulate_iron/))
            call mpas_log_write('        config_maximum_loss_fraction = $r', realArgs=(/config_maximum_loss_fraction/))
            call mpas_log_write('        config_maximum_ratio_iron_to_saccharids = $r', &
realArgs=(/config_maximum_ratio_iron_to_saccharids/))
            call mpas_log_write('        config_respiration_loss_to_DMSPd = $r', realArgs=(/config_respiration_loss_to_DMSPd/))
            call mpas_log_write('        config_DMSP_to_DMS_conversion_fraction = $r', &
realArgs=(/config_DMSP_to_DMS_conversion_fraction/))
            call mpas_log_write('        config_DMSP_to_DMS_conversion_time = $r', realArgs=(/config_DMSP_to_DMS_conversion_time/))
            call mpas_log_write('        config_DMS_oxidation_time = $r', realArgs=(/config_DMS_oxidation_time/))
            call mpas_log_write('        config_mobility_type_diatoms = $r', realArgs=(/config_mobility_type_diatoms/))
            call mpas_log_write('        config_mobility_type_small_plankton = $r', &
realArgs=(/config_mobility_type_small_plankton/))
            call mpas_log_write('        config_mobility_type_phaeocystis = $r', realArgs=(/config_mobility_type_phaeocystis/))
            call mpas_log_write('        config_mobility_type_nitrate = $r', realArgs=(/config_mobility_type_nitrate/))
            call mpas_log_write('        config_mobility_type_ammonium = $r', realArgs=(/config_mobility_type_ammonium/))
            call mpas_log_write('        config_mobility_type_silicate = $r', realArgs=(/config_mobility_type_silicate/))
            call mpas_log_write('        config_mobility_type_DMSPp = $r', realArgs=(/config_mobility_type_DMSPp/))
            call mpas_log_write('        config_mobility_type_DMSPd = $r', realArgs=(/config_mobility_type_DMSPd/))
            call mpas_log_write('        config_mobility_type_humics = $r', realArgs=(/config_mobility_type_humics/))
            call mpas_log_write('        config_mobility_type_saccharids = $r', realArgs=(/config_mobility_type_saccharids/))
            call mpas_log_write('        config_mobility_type_lipids = $r', realArgs=(/config_mobility_type_lipids/))
            call mpas_log_write('        config_mobility_type_inorganic_carbon = $r', &
realArgs=(/config_mobility_type_inorganic_carbon/))
            call mpas_log_write('        config_mobility_type_proteins = $r', realArgs=(/config_mobility_type_proteins/))
            call mpas_log_write('        config_mobility_type_dissolved_iron = $r', &
realArgs=(/config_mobility_type_dissolved_iron/))
            call mpas_log_write('        config_mobility_type_particulate_iron = $r', &
realArgs=(/config_mobility_type_particulate_iron/))
            call mpas_log_write('        config_mobility_type_black_carbon1 = $r', realArgs=(/config_mobility_type_black_carbon1/))
            call mpas_log_write('        config_mobility_type_black_carbon2 = $r', realArgs=(/config_mobility_type_black_carbon2/))
            call mpas_log_write('        config_mobility_type_dust1 = $r', realArgs=(/config_mobility_type_dust1/))
            call mpas_log_write('        config_mobility_type_dust2 = $r', realArgs=(/config_mobility_type_dust2/))
            call mpas_log_write('        config_mobility_type_dust3 = $r', realArgs=(/config_mobility_type_dust3/))
            call mpas_log_write('        config_mobility_type_dust4 = $r', realArgs=(/config_mobility_type_dust4/))
            call mpas_log_write('        config_ratio_C_to_N_diatoms = $r', realArgs=(/config_ratio_C_to_N_diatoms/))
            call mpas_log_write('        config_ratio_C_to_N_small_plankton = $r', realArgs=(/config_ratio_C_to_N_small_plankton/))
            call mpas_log_write('        config_ratio_C_to_N_phaeocystis = $r', realArgs=(/config_ratio_C_to_N_phaeocystis/))
            call mpas_log_write('        config_ratio_chla_to_N_diatoms = $r', realArgs=(/config_ratio_chla_to_N_diatoms/))
            call mpas_log_write('        config_ratio_chla_to_N_small_plankton = $r', &
realArgs=(/config_ratio_chla_to_N_small_plankton/))
            call mpas_log_write('        config_ratio_chla_to_N_phaeocystis = $r', realArgs=(/config_ratio_chla_to_N_phaeocystis/))
            call mpas_log_write('        config_scales_absorption_diatoms = $r', realArgs=(/config_scales_absorption_diatoms/))
            call mpas_log_write('        config_scales_absorption_small_plankton = $r', &
realArgs=(/config_scales_absorption_small_plankton/))
            call mpas_log_write('        config_scales_absorption_phaeocystis = $r', &
realArgs=(/config_scales_absorption_phaeocystis/))
            call mpas_log_write('        config_ratio_C_to_N_proteins = $r', realArgs=(/config_ratio_C_to_N_proteins/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record biogeochemistry.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_use_brine', config_use_brine)
      call mpas_pool_add_config(configPool, 'config_use_vertical_zsalinity', config_use_vertical_zsalinity)
      call mpas_pool_add_config(configPool, 'config_use_vertical_biochemistry', config_use_vertical_biochemistry)
      call mpas_pool_add_config(configPool, 'config_use_shortwave_bioabsorption', config_use_shortwave_bioabsorption)
      call mpas_pool_add_config(configPool, 'config_use_vertical_tracers', config_use_vertical_tracers)
      call mpas_pool_add_config(configPool, 'config_use_skeletal_biochemistry', config_use_skeletal_biochemistry)
      call mpas_pool_add_config(configPool, 'config_use_nitrate', config_use_nitrate)
      call mpas_pool_add_config(configPool, 'config_use_carbon', config_use_carbon)
      call mpas_pool_add_config(configPool, 'config_use_chlorophyll', config_use_chlorophyll)
      call mpas_pool_add_config(configPool, 'config_use_ammonium', config_use_ammonium)
      call mpas_pool_add_config(configPool, 'config_use_silicate', config_use_silicate)
      call mpas_pool_add_config(configPool, 'config_use_DMS', config_use_DMS)
      call mpas_pool_add_config(configPool, 'config_use_nonreactive', config_use_nonreactive)
      call mpas_pool_add_config(configPool, 'config_use_humics', config_use_humics)
      call mpas_pool_add_config(configPool, 'config_use_DON', config_use_DON)
      call mpas_pool_add_config(configPool, 'config_use_iron', config_use_iron)
      call mpas_pool_add_config(configPool, 'config_use_modal_aerosols', config_use_modal_aerosols)
      call mpas_pool_add_config(configPool, 'config_use_zaerosols', config_use_zaerosols)
      call mpas_pool_add_config(configPool, 'config_skeletal_bgc_flux_type', config_skeletal_bgc_flux_type)
      call mpas_pool_add_config(configPool, 'config_scale_initial_vertical_bgc', config_scale_initial_vertical_bgc)
      call mpas_pool_add_config(configPool, 'config_biogrid_bottom_molecular_sublayer', config_biogrid_bottom_molecular_sublayer)
      call mpas_pool_add_config(configPool, 'config_biogrid_top_molecular_sublayer', config_biogrid_top_molecular_sublayer)
      call mpas_pool_add_config(configPool, 'config_bio_gravity_drainage_length_scale', config_bio_gravity_drainage_length_scale)
      call mpas_pool_add_config(configPool, 'config_zsalinity_molecular_sublayer', config_zsalinity_molecular_sublayer)
      call mpas_pool_add_config(configPool, 'config_zsalinity_gravity_drainage_scale', config_zsalinity_gravity_drainage_scale)
      call mpas_pool_add_config(configPool, 'config_snow_porosity_at_ice_surface', config_snow_porosity_at_ice_surface)
      call mpas_pool_add_config(configPool, 'config_new_ice_fraction_biotracer', config_new_ice_fraction_biotracer)
      call mpas_pool_add_config(configPool, 'config_fraction_biotracer_in_frazil', config_fraction_biotracer_in_frazil)
      call mpas_pool_add_config(configPool, 'config_ratio_Si_to_N_diatoms', config_ratio_Si_to_N_diatoms)
      call mpas_pool_add_config(configPool, 'config_ratio_Si_to_N_small_plankton', config_ratio_Si_to_N_small_plankton)
      call mpas_pool_add_config(configPool, 'config_ratio_Si_to_N_phaeocystis', config_ratio_Si_to_N_phaeocystis)
      call mpas_pool_add_config(configPool, 'config_ratio_S_to_N_diatoms', config_ratio_S_to_N_diatoms)
      call mpas_pool_add_config(configPool, 'config_ratio_S_to_N_small_plankton', config_ratio_S_to_N_small_plankton)
      call mpas_pool_add_config(configPool, 'config_ratio_S_to_N_phaeocystis', config_ratio_S_to_N_phaeocystis)
      call mpas_pool_add_config(configPool, 'config_ratio_Fe_to_C_diatoms', config_ratio_Fe_to_C_diatoms)
      call mpas_pool_add_config(configPool, 'config_ratio_Fe_to_C_small_plankton', config_ratio_Fe_to_C_small_plankton)
      call mpas_pool_add_config(configPool, 'config_ratio_Fe_to_C_phaeocystis', config_ratio_Fe_to_C_phaeocystis)
      call mpas_pool_add_config(configPool, 'config_ratio_Fe_to_N_diatoms', config_ratio_Fe_to_N_diatoms)
      call mpas_pool_add_config(configPool, 'config_ratio_Fe_to_N_small_plankton', config_ratio_Fe_to_N_small_plankton)
      call mpas_pool_add_config(configPool, 'config_ratio_Fe_to_N_phaeocystis', config_ratio_Fe_to_N_phaeocystis)
      call mpas_pool_add_config(configPool, 'config_ratio_Fe_to_DON', config_ratio_Fe_to_DON)
      call mpas_pool_add_config(configPool, 'config_ratio_Fe_to_DOC_saccharids', config_ratio_Fe_to_DOC_saccharids)
      call mpas_pool_add_config(configPool, 'config_ratio_Fe_to_DOC_lipids', config_ratio_Fe_to_DOC_lipids)
      call mpas_pool_add_config(configPool, 'config_respiration_fraction_of_growth', config_respiration_fraction_of_growth)
      call mpas_pool_add_config(configPool, 'config_rapid_mobile_to_stationary_time', config_rapid_mobile_to_stationary_time)
      call mpas_pool_add_config(configPool, 'config_long_mobile_to_stationary_time', config_long_mobile_to_stationary_time)
      call mpas_pool_add_config(configPool, 'config_algal_maximum_velocity', config_algal_maximum_velocity)
      call mpas_pool_add_config(configPool, 'config_ratio_Fe_to_dust', config_ratio_Fe_to_dust)
      call mpas_pool_add_config(configPool, 'config_solubility_of_Fe_in_dust', config_solubility_of_Fe_in_dust)
      call mpas_pool_add_config(configPool, 'config_chla_absorptivity_of_diatoms', config_chla_absorptivity_of_diatoms)
      call mpas_pool_add_config(configPool, 'config_chla_absorptivity_of_small_plankton', &
config_chla_absorptivity_of_small_plankton)
      call mpas_pool_add_config(configPool, 'config_chla_absorptivity_of_phaeocystis', config_chla_absorptivity_of_phaeocystis)
      call mpas_pool_add_config(configPool, 'config_light_attenuation_diatoms', config_light_attenuation_diatoms)
      call mpas_pool_add_config(configPool, 'config_light_attenuation_small_plankton', config_light_attenuation_small_plankton)
      call mpas_pool_add_config(configPool, 'config_light_attenuation_phaeocystis', config_light_attenuation_phaeocystis)
      call mpas_pool_add_config(configPool, 'config_light_inhibition_diatoms', config_light_inhibition_diatoms)
      call mpas_pool_add_config(configPool, 'config_light_inhibition_small_plankton', config_light_inhibition_small_plankton)
      call mpas_pool_add_config(configPool, 'config_light_inhibition_phaeocystis', config_light_inhibition_phaeocystis)
      call mpas_pool_add_config(configPool, 'config_maximum_growth_rate_diatoms', config_maximum_growth_rate_diatoms)
      call mpas_pool_add_config(configPool, 'config_maximum_growth_rate_small_plankton', config_maximum_growth_rate_small_plankton)
      call mpas_pool_add_config(configPool, 'config_maximum_growth_rate_phaeocystis', config_maximum_growth_rate_phaeocystis)
      call mpas_pool_add_config(configPool, 'config_temperature_growth_diatoms', config_temperature_growth_diatoms)
      call mpas_pool_add_config(configPool, 'config_temperature_growth_small_plankton', config_temperature_growth_small_plankton)
      call mpas_pool_add_config(configPool, 'config_temperature_growth_phaeocystis', config_temperature_growth_phaeocystis)
      call mpas_pool_add_config(configPool, 'config_grazed_fraction_diatoms', config_grazed_fraction_diatoms)
      call mpas_pool_add_config(configPool, 'config_grazed_fraction_small_plankton', config_grazed_fraction_small_plankton)
      call mpas_pool_add_config(configPool, 'config_grazed_fraction_phaeocystis', config_grazed_fraction_phaeocystis)
      call mpas_pool_add_config(configPool, 'config_mortality_diatoms', config_mortality_diatoms)
      call mpas_pool_add_config(configPool, 'config_mortality_small_plankton', config_mortality_small_plankton)
      call mpas_pool_add_config(configPool, 'config_mortality_phaeocystis', config_mortality_phaeocystis)
      call mpas_pool_add_config(configPool, 'config_temperature_mortality_diatoms', config_temperature_mortality_diatoms)
      call mpas_pool_add_config(configPool, 'config_temperature_mortality_small_plankton', &
config_temperature_mortality_small_plankton)
      call mpas_pool_add_config(configPool, 'config_temperature_mortality_phaeocystis', config_temperature_mortality_phaeocystis)
      call mpas_pool_add_config(configPool, 'config_exudation_diatoms', config_exudation_diatoms)
      call mpas_pool_add_config(configPool, 'config_exudation_small_plankton', config_exudation_small_plankton)
      call mpas_pool_add_config(configPool, 'config_exudation_phaeocystis', config_exudation_phaeocystis)
      call mpas_pool_add_config(configPool, 'config_nitrate_saturation_diatoms', config_nitrate_saturation_diatoms)
      call mpas_pool_add_config(configPool, 'config_nitrate_saturation_small_plankton', config_nitrate_saturation_small_plankton)
      call mpas_pool_add_config(configPool, 'config_nitrate_saturation_phaeocystis', config_nitrate_saturation_phaeocystis)
      call mpas_pool_add_config(configPool, 'config_ammonium_saturation_diatoms', config_ammonium_saturation_diatoms)
      call mpas_pool_add_config(configPool, 'config_ammonium_saturation_small_plankton', config_ammonium_saturation_small_plankton)
      call mpas_pool_add_config(configPool, 'config_ammonium_saturation_phaeocystis', config_ammonium_saturation_phaeocystis)
      call mpas_pool_add_config(configPool, 'config_silicate_saturation_diatoms', config_silicate_saturation_diatoms)
      call mpas_pool_add_config(configPool, 'config_silicate_saturation_small_plankton', config_silicate_saturation_small_plankton)
      call mpas_pool_add_config(configPool, 'config_silicate_saturation_phaeocystis', config_silicate_saturation_phaeocystis)
      call mpas_pool_add_config(configPool, 'config_iron_saturation_diatoms', config_iron_saturation_diatoms)
      call mpas_pool_add_config(configPool, 'config_iron_saturation_small_plankton', config_iron_saturation_small_plankton)
      call mpas_pool_add_config(configPool, 'config_iron_saturation_phaeocystis', config_iron_saturation_phaeocystis)
      call mpas_pool_add_config(configPool, 'config_fraction_spilled_to_DON', config_fraction_spilled_to_DON)
      call mpas_pool_add_config(configPool, 'config_degredation_of_DON', config_degredation_of_DON)
      call mpas_pool_add_config(configPool, 'config_fraction_DON_ammonium', config_fraction_DON_ammonium)
      call mpas_pool_add_config(configPool, 'config_fraction_loss_to_saccharids', config_fraction_loss_to_saccharids)
      call mpas_pool_add_config(configPool, 'config_fraction_loss_to_lipids', config_fraction_loss_to_lipids)
      call mpas_pool_add_config(configPool, 'config_fraction_exudation_to_saccharids', config_fraction_exudation_to_saccharids)
      call mpas_pool_add_config(configPool, 'config_fraction_exudation_to_lipids', config_fraction_exudation_to_lipids)
      call mpas_pool_add_config(configPool, 'config_remineralization_saccharids', config_remineralization_saccharids)
      call mpas_pool_add_config(configPool, 'config_remineralization_lipids', config_remineralization_lipids)
      call mpas_pool_add_config(configPool, 'config_maximum_brine_temperature', config_maximum_brine_temperature)
      call mpas_pool_add_config(configPool, 'config_salinity_dependence_of_growth', config_salinity_dependence_of_growth)
      call mpas_pool_add_config(configPool, 'config_minimum_optical_depth', config_minimum_optical_depth)
      call mpas_pool_add_config(configPool, 'config_slopped_grazing_fraction', config_slopped_grazing_fraction)
      call mpas_pool_add_config(configPool, 'config_excreted_fraction', config_excreted_fraction)
      call mpas_pool_add_config(configPool, 'config_fraction_mortality_to_ammonium', config_fraction_mortality_to_ammonium)
      call mpas_pool_add_config(configPool, 'config_fraction_iron_remineralized', config_fraction_iron_remineralized)
      call mpas_pool_add_config(configPool, 'config_nitrification_rate', config_nitrification_rate)
      call mpas_pool_add_config(configPool, 'config_desorption_loss_particulate_iron', config_desorption_loss_particulate_iron)
      call mpas_pool_add_config(configPool, 'config_maximum_loss_fraction', config_maximum_loss_fraction)
      call mpas_pool_add_config(configPool, 'config_maximum_ratio_iron_to_saccharids', config_maximum_ratio_iron_to_saccharids)
      call mpas_pool_add_config(configPool, 'config_respiration_loss_to_DMSPd', config_respiration_loss_to_DMSPd)
      call mpas_pool_add_config(configPool, 'config_DMSP_to_DMS_conversion_fraction', config_DMSP_to_DMS_conversion_fraction)
      call mpas_pool_add_config(configPool, 'config_DMSP_to_DMS_conversion_time', config_DMSP_to_DMS_conversion_time)
      call mpas_pool_add_config(configPool, 'config_DMS_oxidation_time', config_DMS_oxidation_time)
      call mpas_pool_add_config(configPool, 'config_mobility_type_diatoms', config_mobility_type_diatoms)
      call mpas_pool_add_config(configPool, 'config_mobility_type_small_plankton', config_mobility_type_small_plankton)
      call mpas_pool_add_config(configPool, 'config_mobility_type_phaeocystis', config_mobility_type_phaeocystis)
      call mpas_pool_add_config(configPool, 'config_mobility_type_nitrate', config_mobility_type_nitrate)
      call mpas_pool_add_config(configPool, 'config_mobility_type_ammonium', config_mobility_type_ammonium)
      call mpas_pool_add_config(configPool, 'config_mobility_type_silicate', config_mobility_type_silicate)
      call mpas_pool_add_config(configPool, 'config_mobility_type_DMSPp', config_mobility_type_DMSPp)
      call mpas_pool_add_config(configPool, 'config_mobility_type_DMSPd', config_mobility_type_DMSPd)
      call mpas_pool_add_config(configPool, 'config_mobility_type_humics', config_mobility_type_humics)
      call mpas_pool_add_config(configPool, 'config_mobility_type_saccharids', config_mobility_type_saccharids)
      call mpas_pool_add_config(configPool, 'config_mobility_type_lipids', config_mobility_type_lipids)
      call mpas_pool_add_config(configPool, 'config_mobility_type_inorganic_carbon', config_mobility_type_inorganic_carbon)
      call mpas_pool_add_config(configPool, 'config_mobility_type_proteins', config_mobility_type_proteins)
      call mpas_pool_add_config(configPool, 'config_mobility_type_dissolved_iron', config_mobility_type_dissolved_iron)
      call mpas_pool_add_config(configPool, 'config_mobility_type_particulate_iron', config_mobility_type_particulate_iron)
      call mpas_pool_add_config(configPool, 'config_mobility_type_black_carbon1', config_mobility_type_black_carbon1)
      call mpas_pool_add_config(configPool, 'config_mobility_type_black_carbon2', config_mobility_type_black_carbon2)
      call mpas_pool_add_config(configPool, 'config_mobility_type_dust1', config_mobility_type_dust1)
      call mpas_pool_add_config(configPool, 'config_mobility_type_dust2', config_mobility_type_dust2)
      call mpas_pool_add_config(configPool, 'config_mobility_type_dust3', config_mobility_type_dust3)
      call mpas_pool_add_config(configPool, 'config_mobility_type_dust4', config_mobility_type_dust4)
      call mpas_pool_add_config(configPool, 'config_ratio_C_to_N_diatoms', config_ratio_C_to_N_diatoms)
      call mpas_pool_add_config(configPool, 'config_ratio_C_to_N_small_plankton', config_ratio_C_to_N_small_plankton)
      call mpas_pool_add_config(configPool, 'config_ratio_C_to_N_phaeocystis', config_ratio_C_to_N_phaeocystis)
      call mpas_pool_add_config(configPool, 'config_ratio_chla_to_N_diatoms', config_ratio_chla_to_N_diatoms)
      call mpas_pool_add_config(configPool, 'config_ratio_chla_to_N_small_plankton', config_ratio_chla_to_N_small_plankton)
      call mpas_pool_add_config(configPool, 'config_ratio_chla_to_N_phaeocystis', config_ratio_chla_to_N_phaeocystis)
      call mpas_pool_add_config(configPool, 'config_scales_absorption_diatoms', config_scales_absorption_diatoms)
      call mpas_pool_add_config(configPool, 'config_scales_absorption_small_plankton', config_scales_absorption_small_plankton)
      call mpas_pool_add_config(configPool, 'config_scales_absorption_phaeocystis', config_scales_absorption_phaeocystis)
      call mpas_pool_add_config(configPool, 'config_ratio_C_to_N_proteins', config_ratio_C_to_N_proteins)

   end subroutine seaice_setup_nmlrec_biogeochemistry


   subroutine seaice_setup_nmlrec_shortwave(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      character (len=StrKIND) :: config_shortwave_type = 'dEdd'
      character (len=StrKIND) :: config_albedo_type = 'ccsm3'
      logical :: config_use_snicar_ad = .false.
      real (kind=RKIND) :: config_visible_ice_albedo = 0.780000
      real (kind=RKIND) :: config_infrared_ice_albedo = 0.360000
      real (kind=RKIND) :: config_visible_snow_albedo = 0.980000
      real (kind=RKIND) :: config_infrared_snow_albedo = 0.700000
      real (kind=RKIND) :: config_variable_albedo_thickness_limit = 0.300000
      real (kind=RKIND) :: config_ice_shortwave_tuning_parameter = 0.000000
      real (kind=RKIND) :: config_pond_shortwave_tuning_parameter = 0.000000
      real (kind=RKIND) :: config_snow_shortwave_tuning_parameter = 1.500000
      real (kind=RKIND) :: config_temp_change_snow_grain_radius_change = 1.500000
      real (kind=RKIND) :: config_max_melting_snow_grain_radius = 1500.000000
      real (kind=RKIND) :: config_algae_absorption_coefficient = 0.600000

      namelist /shortwave/ &
         config_shortwave_type, &
         config_albedo_type, &
         config_use_snicar_ad, &
         config_visible_ice_albedo, &
         config_infrared_ice_albedo, &
         config_visible_snow_albedo, &
         config_infrared_snow_albedo, &
         config_variable_albedo_thickness_limit, &
         config_ice_shortwave_tuning_parameter, &
         config_pond_shortwave_tuning_parameter, &
         config_snow_shortwave_tuning_parameter, &
         config_temp_change_snow_grain_radius_change, &
         config_max_melting_snow_grain_radius, &
         config_algae_absorption_coefficient
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, shortwave, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_char(dminfo, config_shortwave_type)
         call mpas_dmpar_bcast_char(dminfo, config_albedo_type)
         call mpas_dmpar_bcast_logical(dminfo, config_use_snicar_ad)
         call mpas_dmpar_bcast_real(dminfo, config_visible_ice_albedo)
         call mpas_dmpar_bcast_real(dminfo, config_infrared_ice_albedo)
         call mpas_dmpar_bcast_real(dminfo, config_visible_snow_albedo)
         call mpas_dmpar_bcast_real(dminfo, config_infrared_snow_albedo)
         call mpas_dmpar_bcast_real(dminfo, config_variable_albedo_thickness_limit)
         call mpas_dmpar_bcast_real(dminfo, config_ice_shortwave_tuning_parameter)
         call mpas_dmpar_bcast_real(dminfo, config_pond_shortwave_tuning_parameter)
         call mpas_dmpar_bcast_real(dminfo, config_snow_shortwave_tuning_parameter)
         call mpas_dmpar_bcast_real(dminfo, config_temp_change_snow_grain_radius_change)
         call mpas_dmpar_bcast_real(dminfo, config_max_melting_snow_grain_radius)
         call mpas_dmpar_bcast_real(dminfo, config_algae_absorption_coefficient)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record shortwave')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_shortwave_type = '//mpas_log_escape_dollars(config_shortwave_type))
            call mpas_log_write('        config_albedo_type = '//mpas_log_escape_dollars(config_albedo_type))
            call mpas_log_write('        config_use_snicar_ad = $l', logicArgs=(/config_use_snicar_ad/))
            call mpas_log_write('        config_visible_ice_albedo = $r', realArgs=(/config_visible_ice_albedo/))
            call mpas_log_write('        config_infrared_ice_albedo = $r', realArgs=(/config_infrared_ice_albedo/))
            call mpas_log_write('        config_visible_snow_albedo = $r', realArgs=(/config_visible_snow_albedo/))
            call mpas_log_write('        config_infrared_snow_albedo = $r', realArgs=(/config_infrared_snow_albedo/))
            call mpas_log_write('        config_variable_albedo_thickness_limit = $r', &
realArgs=(/config_variable_albedo_thickness_limit/))
            call mpas_log_write('        config_ice_shortwave_tuning_parameter = $r', &
realArgs=(/config_ice_shortwave_tuning_parameter/))
            call mpas_log_write('        config_pond_shortwave_tuning_parameter = $r', &
realArgs=(/config_pond_shortwave_tuning_parameter/))
            call mpas_log_write('        config_snow_shortwave_tuning_parameter = $r', &
realArgs=(/config_snow_shortwave_tuning_parameter/))
            call mpas_log_write('        config_temp_change_snow_grain_radius_change = $r', &
realArgs=(/config_temp_change_snow_grain_radius_change/))
            call mpas_log_write('        config_max_melting_snow_grain_radius = $r', &
realArgs=(/config_max_melting_snow_grain_radius/))
            call mpas_log_write('        config_algae_absorption_coefficient = $r', &
realArgs=(/config_algae_absorption_coefficient/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record shortwave.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_shortwave_type', config_shortwave_type)
      call mpas_pool_add_config(configPool, 'config_albedo_type', config_albedo_type)
      call mpas_pool_add_config(configPool, 'config_use_snicar_ad', config_use_snicar_ad)
      call mpas_pool_add_config(configPool, 'config_visible_ice_albedo', config_visible_ice_albedo)
      call mpas_pool_add_config(configPool, 'config_infrared_ice_albedo', config_infrared_ice_albedo)
      call mpas_pool_add_config(configPool, 'config_visible_snow_albedo', config_visible_snow_albedo)
      call mpas_pool_add_config(configPool, 'config_infrared_snow_albedo', config_infrared_snow_albedo)
      call mpas_pool_add_config(configPool, 'config_variable_albedo_thickness_limit', config_variable_albedo_thickness_limit)
      call mpas_pool_add_config(configPool, 'config_ice_shortwave_tuning_parameter', config_ice_shortwave_tuning_parameter)
      call mpas_pool_add_config(configPool, 'config_pond_shortwave_tuning_parameter', config_pond_shortwave_tuning_parameter)
      call mpas_pool_add_config(configPool, 'config_snow_shortwave_tuning_parameter', config_snow_shortwave_tuning_parameter)
      call mpas_pool_add_config(configPool, 'config_temp_change_snow_grain_radius_change', &
config_temp_change_snow_grain_radius_change)
      call mpas_pool_add_config(configPool, 'config_max_melting_snow_grain_radius', config_max_melting_snow_grain_radius)
      call mpas_pool_add_config(configPool, 'config_algae_absorption_coefficient', config_algae_absorption_coefficient)

   end subroutine seaice_setup_nmlrec_shortwave


   subroutine seaice_setup_nmlrec_snow(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      character (len=StrKIND) :: config_snow_redistribution_scheme = 'none'
      real (kind=RKIND) :: config_fallen_snow_radius = 54.400000
      logical :: config_use_snow_liquid_ponds = .false.
      real (kind=RKIND) :: config_new_snow_density = 100.000000
      real (kind=RKIND) :: config_max_snow_density = 450.000000
      real (kind=RKIND) :: config_minimum_wind_compaction = 10.000000
      real (kind=RKIND) :: config_wind_compaction_factor = 27.300000
      real (kind=RKIND) :: config_max_dry_snow_radius = 2800.000000

      namelist /snow/ &
         config_snow_redistribution_scheme, &
         config_fallen_snow_radius, &
         config_use_snow_liquid_ponds, &
         config_new_snow_density, &
         config_max_snow_density, &
         config_minimum_wind_compaction, &
         config_wind_compaction_factor, &
         config_max_dry_snow_radius
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, snow, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_char(dminfo, config_snow_redistribution_scheme)
         call mpas_dmpar_bcast_real(dminfo, config_fallen_snow_radius)
         call mpas_dmpar_bcast_logical(dminfo, config_use_snow_liquid_ponds)
         call mpas_dmpar_bcast_real(dminfo, config_new_snow_density)
         call mpas_dmpar_bcast_real(dminfo, config_max_snow_density)
         call mpas_dmpar_bcast_real(dminfo, config_minimum_wind_compaction)
         call mpas_dmpar_bcast_real(dminfo, config_wind_compaction_factor)
         call mpas_dmpar_bcast_real(dminfo, config_max_dry_snow_radius)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record snow')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_snow_redistribution_scheme = '&
//''//mpas_log_escape_dollars(config_snow_redistribution_scheme))
            call mpas_log_write('        config_fallen_snow_radius = $r', realArgs=(/config_fallen_snow_radius/))
            call mpas_log_write('        config_use_snow_liquid_ponds = $l', logicArgs=(/config_use_snow_liquid_ponds/))
            call mpas_log_write('        config_new_snow_density = $r', realArgs=(/config_new_snow_density/))
            call mpas_log_write('        config_max_snow_density = $r', realArgs=(/config_max_snow_density/))
            call mpas_log_write('        config_minimum_wind_compaction = $r', realArgs=(/config_minimum_wind_compaction/))
            call mpas_log_write('        config_wind_compaction_factor = $r', realArgs=(/config_wind_compaction_factor/))
            call mpas_log_write('        config_max_dry_snow_radius = $r', realArgs=(/config_max_dry_snow_radius/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record snow.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_snow_redistribution_scheme', config_snow_redistribution_scheme)
      call mpas_pool_add_config(configPool, 'config_fallen_snow_radius', config_fallen_snow_radius)
      call mpas_pool_add_config(configPool, 'config_use_snow_liquid_ponds', config_use_snow_liquid_ponds)
      call mpas_pool_add_config(configPool, 'config_new_snow_density', config_new_snow_density)
      call mpas_pool_add_config(configPool, 'config_max_snow_density', config_max_snow_density)
      call mpas_pool_add_config(configPool, 'config_minimum_wind_compaction', config_minimum_wind_compaction)
      call mpas_pool_add_config(configPool, 'config_wind_compaction_factor', config_wind_compaction_factor)
      call mpas_pool_add_config(configPool, 'config_max_dry_snow_radius', config_max_dry_snow_radius)

   end subroutine seaice_setup_nmlrec_snow


   subroutine seaice_setup_nmlrec_meltponds(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      real (kind=RKIND) :: config_snow_to_ice_transition_depth = 0.000000
      character (len=StrKIND) :: config_pond_refreezing_type = 'hlid'
      real (kind=RKIND) :: config_pond_flushing_timescale = 0.001000
      real (kind=RKIND) :: config_min_meltwater_retained_fraction = 0.150000
      real (kind=RKIND) :: config_max_meltwater_retained_fraction = 1.000000
      real (kind=RKIND) :: config_pond_depth_to_fraction_ratio = 0.800000
      real (kind=RKIND) :: config_snow_on_pond_ice_tapering_parameter = 0.030000
      real (kind=RKIND) :: config_critical_pond_ice_thickness = 0.010000

      namelist /meltponds/ &
         config_snow_to_ice_transition_depth, &
         config_pond_refreezing_type, &
         config_pond_flushing_timescale, &
         config_min_meltwater_retained_fraction, &
         config_max_meltwater_retained_fraction, &
         config_pond_depth_to_fraction_ratio, &
         config_snow_on_pond_ice_tapering_parameter, &
         config_critical_pond_ice_thickness
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, meltponds, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_real(dminfo, config_snow_to_ice_transition_depth)
         call mpas_dmpar_bcast_char(dminfo, config_pond_refreezing_type)
         call mpas_dmpar_bcast_real(dminfo, config_pond_flushing_timescale)
         call mpas_dmpar_bcast_real(dminfo, config_min_meltwater_retained_fraction)
         call mpas_dmpar_bcast_real(dminfo, config_max_meltwater_retained_fraction)
         call mpas_dmpar_bcast_real(dminfo, config_pond_depth_to_fraction_ratio)
         call mpas_dmpar_bcast_real(dminfo, config_snow_on_pond_ice_tapering_parameter)
         call mpas_dmpar_bcast_real(dminfo, config_critical_pond_ice_thickness)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record meltponds')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_snow_to_ice_transition_depth = $r', &
realArgs=(/config_snow_to_ice_transition_depth/))
            call mpas_log_write('        config_pond_refreezing_type = '//mpas_log_escape_dollars(config_pond_refreezing_type))
            call mpas_log_write('        config_pond_flushing_timescale = $r', realArgs=(/config_pond_flushing_timescale/))
            call mpas_log_write('        config_min_meltwater_retained_fraction = $r', &
realArgs=(/config_min_meltwater_retained_fraction/))
            call mpas_log_write('        config_max_meltwater_retained_fraction = $r', &
realArgs=(/config_max_meltwater_retained_fraction/))
            call mpas_log_write('        config_pond_depth_to_fraction_ratio = $r', &
realArgs=(/config_pond_depth_to_fraction_ratio/))
            call mpas_log_write('        config_snow_on_pond_ice_tapering_parameter = $r', &
realArgs=(/config_snow_on_pond_ice_tapering_parameter/))
            call mpas_log_write('        config_critical_pond_ice_thickness = $r', realArgs=(/config_critical_pond_ice_thickness/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record meltponds.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_snow_to_ice_transition_depth', config_snow_to_ice_transition_depth)
      call mpas_pool_add_config(configPool, 'config_pond_refreezing_type', config_pond_refreezing_type)
      call mpas_pool_add_config(configPool, 'config_pond_flushing_timescale', config_pond_flushing_timescale)
      call mpas_pool_add_config(configPool, 'config_min_meltwater_retained_fraction', config_min_meltwater_retained_fraction)
      call mpas_pool_add_config(configPool, 'config_max_meltwater_retained_fraction', config_max_meltwater_retained_fraction)
      call mpas_pool_add_config(configPool, 'config_pond_depth_to_fraction_ratio', config_pond_depth_to_fraction_ratio)
      call mpas_pool_add_config(configPool, 'config_snow_on_pond_ice_tapering_parameter', &
config_snow_on_pond_ice_tapering_parameter)
      call mpas_pool_add_config(configPool, 'config_critical_pond_ice_thickness', config_critical_pond_ice_thickness)

   end subroutine seaice_setup_nmlrec_meltponds


   subroutine seaice_setup_nmlrec_thermodynamics(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      character (len=StrKIND) :: config_thermodynamics_type = 'mushy'
      character (len=StrKIND) :: config_heat_conductivity_type = 'bubbly'
      real (kind=RKIND) :: config_rapid_mode_channel_radius = 0.000500
      real (kind=RKIND) :: config_rapid_model_critical_Ra = 10.000000
      real (kind=RKIND) :: config_rapid_mode_aspect_ratio = 1.000000
      real (kind=RKIND) :: config_slow_mode_drainage_strength = -0.000000
      real (kind=RKIND) :: config_slow_mode_critical_porosity = 0.050000
      real (kind=RKIND) :: config_congelation_ice_porosity = 0.850000

      namelist /thermodynamics/ &
         config_thermodynamics_type, &
         config_heat_conductivity_type, &
         config_rapid_mode_channel_radius, &
         config_rapid_model_critical_Ra, &
         config_rapid_mode_aspect_ratio, &
         config_slow_mode_drainage_strength, &
         config_slow_mode_critical_porosity, &
         config_congelation_ice_porosity
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, thermodynamics, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_char(dminfo, config_thermodynamics_type)
         call mpas_dmpar_bcast_char(dminfo, config_heat_conductivity_type)
         call mpas_dmpar_bcast_real(dminfo, config_rapid_mode_channel_radius)
         call mpas_dmpar_bcast_real(dminfo, config_rapid_model_critical_Ra)
         call mpas_dmpar_bcast_real(dminfo, config_rapid_mode_aspect_ratio)
         call mpas_dmpar_bcast_real(dminfo, config_slow_mode_drainage_strength)
         call mpas_dmpar_bcast_real(dminfo, config_slow_mode_critical_porosity)
         call mpas_dmpar_bcast_real(dminfo, config_congelation_ice_porosity)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record thermodynamics')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_thermodynamics_type = '//mpas_log_escape_dollars(config_thermodynamics_type))
            call mpas_log_write('        config_heat_conductivity_type = '//mpas_log_escape_dollars(config_heat_conductivity_type))
            call mpas_log_write('        config_rapid_mode_channel_radius = $r', realArgs=(/config_rapid_mode_channel_radius/))
            call mpas_log_write('        config_rapid_model_critical_Ra = $r', realArgs=(/config_rapid_model_critical_Ra/))
            call mpas_log_write('        config_rapid_mode_aspect_ratio = $r', realArgs=(/config_rapid_mode_aspect_ratio/))
            call mpas_log_write('        config_slow_mode_drainage_strength = $r', realArgs=(/config_slow_mode_drainage_strength/))
            call mpas_log_write('        config_slow_mode_critical_porosity = $r', realArgs=(/config_slow_mode_critical_porosity/))
            call mpas_log_write('        config_congelation_ice_porosity = $r', realArgs=(/config_congelation_ice_porosity/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record thermodynamics.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_thermodynamics_type', config_thermodynamics_type)
      call mpas_pool_add_config(configPool, 'config_heat_conductivity_type', config_heat_conductivity_type)
      call mpas_pool_add_config(configPool, 'config_rapid_mode_channel_radius', config_rapid_mode_channel_radius)
      call mpas_pool_add_config(configPool, 'config_rapid_model_critical_Ra', config_rapid_model_critical_Ra)
      call mpas_pool_add_config(configPool, 'config_rapid_mode_aspect_ratio', config_rapid_mode_aspect_ratio)
      call mpas_pool_add_config(configPool, 'config_slow_mode_drainage_strength', config_slow_mode_drainage_strength)
      call mpas_pool_add_config(configPool, 'config_slow_mode_critical_porosity', config_slow_mode_critical_porosity)
      call mpas_pool_add_config(configPool, 'config_congelation_ice_porosity', config_congelation_ice_porosity)

   end subroutine seaice_setup_nmlrec_thermodynamics


   subroutine seaice_setup_nmlrec_itd(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      character (len=StrKIND) :: config_itd_conversion_type = 'linear remap'
      character (len=StrKIND) :: config_category_bounds_type = 'original'

      namelist /itd/ &
         config_itd_conversion_type, &
         config_category_bounds_type
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, itd, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_char(dminfo, config_itd_conversion_type)
         call mpas_dmpar_bcast_char(dminfo, config_category_bounds_type)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record itd')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_itd_conversion_type = '//mpas_log_escape_dollars(config_itd_conversion_type))
            call mpas_log_write('        config_category_bounds_type = '//mpas_log_escape_dollars(config_category_bounds_type))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record itd.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_itd_conversion_type', config_itd_conversion_type)
      call mpas_pool_add_config(configPool, 'config_category_bounds_type', config_category_bounds_type)

   end subroutine seaice_setup_nmlrec_itd


   subroutine seaice_setup_nmlrec_ridging(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      character (len=StrKIND) :: config_ice_strength_formulation = 'Rothrock75'
      character (len=StrKIND) :: config_ridging_participation_function = 'exponential'
      character (len=StrKIND) :: config_ridging_redistribution_function = 'exponential'
      real (kind=RKIND) :: config_ridiging_efolding_scale = 3.000000
      real (kind=RKIND) :: config_ratio_ridging_work_to_PE = 17.000000

      namelist /ridging/ &
         config_ice_strength_formulation, &
         config_ridging_participation_function, &
         config_ridging_redistribution_function, &
         config_ridiging_efolding_scale, &
         config_ratio_ridging_work_to_PE
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, ridging, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_char(dminfo, config_ice_strength_formulation)
         call mpas_dmpar_bcast_char(dminfo, config_ridging_participation_function)
         call mpas_dmpar_bcast_char(dminfo, config_ridging_redistribution_function)
         call mpas_dmpar_bcast_real(dminfo, config_ridiging_efolding_scale)
         call mpas_dmpar_bcast_real(dminfo, config_ratio_ridging_work_to_PE)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record ridging')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_ice_strength_formulation = '&
//''//mpas_log_escape_dollars(config_ice_strength_formulation))
            call mpas_log_write('        config_ridging_participation_function = '&
//''//mpas_log_escape_dollars(config_ridging_participation_function))
            call mpas_log_write('        config_ridging_redistribution_function = '&
//''//mpas_log_escape_dollars(config_ridging_redistribution_function))
            call mpas_log_write('        config_ridiging_efolding_scale = $r', realArgs=(/config_ridiging_efolding_scale/))
            call mpas_log_write('        config_ratio_ridging_work_to_PE = $r', realArgs=(/config_ratio_ridging_work_to_PE/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record ridging.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_ice_strength_formulation', config_ice_strength_formulation)
      call mpas_pool_add_config(configPool, 'config_ridging_participation_function', config_ridging_participation_function)
      call mpas_pool_add_config(configPool, 'config_ridging_redistribution_function', config_ridging_redistribution_function)
      call mpas_pool_add_config(configPool, 'config_ridiging_efolding_scale', config_ridiging_efolding_scale)
      call mpas_pool_add_config(configPool, 'config_ratio_ridging_work_to_PE', config_ratio_ridging_work_to_PE)

   end subroutine seaice_setup_nmlrec_ridging


   subroutine seaice_setup_nmlrec_atmosphere(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      character (len=StrKIND) :: config_atmos_boundary_method = 'ccsm3'
      logical :: config_calc_surface_stresses = .true.
      logical :: config_calc_surface_temperature = .true.
      logical :: config_use_form_drag = .false.
      logical :: config_use_high_frequency_coupling = .false.
      integer :: config_boundary_layer_iteration_number = 4

      namelist /atmosphere/ &
         config_atmos_boundary_method, &
         config_calc_surface_stresses, &
         config_calc_surface_temperature, &
         config_use_form_drag, &
         config_use_high_frequency_coupling, &
         config_boundary_layer_iteration_number
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, atmosphere, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_char(dminfo, config_atmos_boundary_method)
         call mpas_dmpar_bcast_logical(dminfo, config_calc_surface_stresses)
         call mpas_dmpar_bcast_logical(dminfo, config_calc_surface_temperature)
         call mpas_dmpar_bcast_logical(dminfo, config_use_form_drag)
         call mpas_dmpar_bcast_logical(dminfo, config_use_high_frequency_coupling)
         call mpas_dmpar_bcast_int(dminfo, config_boundary_layer_iteration_number)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record atmosphere')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_atmos_boundary_method = '//mpas_log_escape_dollars(config_atmos_boundary_method))
            call mpas_log_write('        config_calc_surface_stresses = $l', logicArgs=(/config_calc_surface_stresses/))
            call mpas_log_write('        config_calc_surface_temperature = $l', logicArgs=(/config_calc_surface_temperature/))
            call mpas_log_write('        config_use_form_drag = $l', logicArgs=(/config_use_form_drag/))
            call mpas_log_write('        config_use_high_frequency_coupling = $l', &
logicArgs=(/config_use_high_frequency_coupling/))
            call mpas_log_write('        config_boundary_layer_iteration_number = $i', &
intArgs=(/config_boundary_layer_iteration_number/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record atmosphere.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_atmos_boundary_method', config_atmos_boundary_method)
      call mpas_pool_add_config(configPool, 'config_calc_surface_stresses', config_calc_surface_stresses)
      call mpas_pool_add_config(configPool, 'config_calc_surface_temperature', config_calc_surface_temperature)
      call mpas_pool_add_config(configPool, 'config_use_form_drag', config_use_form_drag)
      call mpas_pool_add_config(configPool, 'config_use_high_frequency_coupling', config_use_high_frequency_coupling)
      call mpas_pool_add_config(configPool, 'config_boundary_layer_iteration_number', config_boundary_layer_iteration_number)

   end subroutine seaice_setup_nmlrec_atmosphere


   subroutine seaice_setup_nmlrec_ocean(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_use_ocean_mixed_layer = .true.
      real (kind=RKIND) :: config_min_friction_velocity = 0.000500
      character (len=StrKIND) :: config_ocean_heat_transfer_type = 'constant'
      character (len=StrKIND) :: config_sea_freezing_temperature_type = 'mushy'
      character (len=StrKIND) :: config_ocean_surface_type = 'free'
      logical :: config_couple_biogeochemistry_fields = .false.
      logical :: config_use_data_icebergs = .false.

      namelist /ocean/ &
         config_use_ocean_mixed_layer, &
         config_min_friction_velocity, &
         config_ocean_heat_transfer_type, &
         config_sea_freezing_temperature_type, &
         config_ocean_surface_type, &
         config_couple_biogeochemistry_fields, &
         config_use_data_icebergs
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, ocean, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_use_ocean_mixed_layer)
         call mpas_dmpar_bcast_real(dminfo, config_min_friction_velocity)
         call mpas_dmpar_bcast_char(dminfo, config_ocean_heat_transfer_type)
         call mpas_dmpar_bcast_char(dminfo, config_sea_freezing_temperature_type)
         call mpas_dmpar_bcast_char(dminfo, config_ocean_surface_type)
         call mpas_dmpar_bcast_logical(dminfo, config_couple_biogeochemistry_fields)
         call mpas_dmpar_bcast_logical(dminfo, config_use_data_icebergs)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record ocean')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_use_ocean_mixed_layer = $l', logicArgs=(/config_use_ocean_mixed_layer/))
            call mpas_log_write('        config_min_friction_velocity = $r', realArgs=(/config_min_friction_velocity/))
            call mpas_log_write('        config_ocean_heat_transfer_type = '&
//''//mpas_log_escape_dollars(config_ocean_heat_transfer_type))
            call mpas_log_write('        config_sea_freezing_temperature_type = '&
//''//mpas_log_escape_dollars(config_sea_freezing_temperature_type))
            call mpas_log_write('        config_ocean_surface_type = '//mpas_log_escape_dollars(config_ocean_surface_type))
            call mpas_log_write('        config_couple_biogeochemistry_fields = $l', &
logicArgs=(/config_couple_biogeochemistry_fields/))
            call mpas_log_write('        config_use_data_icebergs = $l', logicArgs=(/config_use_data_icebergs/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record ocean.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_use_ocean_mixed_layer', config_use_ocean_mixed_layer)
      call mpas_pool_add_config(configPool, 'config_min_friction_velocity', config_min_friction_velocity)
      call mpas_pool_add_config(configPool, 'config_ocean_heat_transfer_type', config_ocean_heat_transfer_type)
      call mpas_pool_add_config(configPool, 'config_sea_freezing_temperature_type', config_sea_freezing_temperature_type)
      call mpas_pool_add_config(configPool, 'config_ocean_surface_type', config_ocean_surface_type)
      call mpas_pool_add_config(configPool, 'config_couple_biogeochemistry_fields', config_couple_biogeochemistry_fields)
      call mpas_pool_add_config(configPool, 'config_use_data_icebergs', config_use_data_icebergs)

   end subroutine seaice_setup_nmlrec_ocean


   subroutine seaice_setup_nmlrec_diagnostics(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_check_state = .false.

      namelist /diagnostics/ &
         config_check_state
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, diagnostics, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_check_state)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record diagnostics')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_check_state = $l', logicArgs=(/config_check_state/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record diagnostics.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_check_state', config_check_state)

   end subroutine seaice_setup_nmlrec_diagnostics


   subroutine seaice_setup_nmlrec_prescribed_ice(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      integer :: config_prescribed_ice_stream_year_first = -999
      integer :: config_prescribed_ice_stream_year_last = -999
      integer :: config_prescribed_ice_model_year_align = -999
      character (len=StrKIND) :: config_prescribed_ice_stream_fldvarname = 'ice_cov'
      character (len=StrKIND) :: config_prescribed_ice_stream_fldfilename = 'unset'
      character (len=StrKIND) :: config_prescribed_ice_stream_domtvarname = 'time'
      character (len=StrKIND) :: config_prescribed_ice_stream_domxvarname = 'xc'
      character (len=StrKIND) :: config_prescribed_ice_stream_domyvarname = 'yc'
      character (len=StrKIND) :: config_prescribed_ice_stream_domareaname = 'area'
      character (len=StrKIND) :: config_prescribed_ice_stream_dommaskname = 'mask'
      character (len=StrKIND) :: config_prescribed_ice_stream_domfilename = 'unset'
      character (len=StrKIND) :: config_prescribed_ice_stream_mapread = 'NOT_SET'
      logical :: config_prescribed_ice_stream_fill = .false.

      namelist /prescribed_ice/ &
         config_prescribed_ice_stream_year_first, &
         config_prescribed_ice_stream_year_last, &
         config_prescribed_ice_model_year_align, &
         config_prescribed_ice_stream_fldvarname, &
         config_prescribed_ice_stream_fldfilename, &
         config_prescribed_ice_stream_domtvarname, &
         config_prescribed_ice_stream_domxvarname, &
         config_prescribed_ice_stream_domyvarname, &
         config_prescribed_ice_stream_domareaname, &
         config_prescribed_ice_stream_dommaskname, &
         config_prescribed_ice_stream_domfilename, &
         config_prescribed_ice_stream_mapread, &
         config_prescribed_ice_stream_fill
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, prescribed_ice, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_int(dminfo, config_prescribed_ice_stream_year_first)
         call mpas_dmpar_bcast_int(dminfo, config_prescribed_ice_stream_year_last)
         call mpas_dmpar_bcast_int(dminfo, config_prescribed_ice_model_year_align)
         call mpas_dmpar_bcast_char(dminfo, config_prescribed_ice_stream_fldvarname)
         call mpas_dmpar_bcast_char(dminfo, config_prescribed_ice_stream_fldfilename)
         call mpas_dmpar_bcast_char(dminfo, config_prescribed_ice_stream_domtvarname)
         call mpas_dmpar_bcast_char(dminfo, config_prescribed_ice_stream_domxvarname)
         call mpas_dmpar_bcast_char(dminfo, config_prescribed_ice_stream_domyvarname)
         call mpas_dmpar_bcast_char(dminfo, config_prescribed_ice_stream_domareaname)
         call mpas_dmpar_bcast_char(dminfo, config_prescribed_ice_stream_dommaskname)
         call mpas_dmpar_bcast_char(dminfo, config_prescribed_ice_stream_domfilename)
         call mpas_dmpar_bcast_char(dminfo, config_prescribed_ice_stream_mapread)
         call mpas_dmpar_bcast_logical(dminfo, config_prescribed_ice_stream_fill)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record prescribed_ice')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_prescribed_ice_stream_year_first = $i', &
intArgs=(/config_prescribed_ice_stream_year_first/))
            call mpas_log_write('        config_prescribed_ice_stream_year_last = $i', &
intArgs=(/config_prescribed_ice_stream_year_last/))
            call mpas_log_write('        config_prescribed_ice_model_year_align = $i', &
intArgs=(/config_prescribed_ice_model_year_align/))
            call mpas_log_write('        config_prescribed_ice_stream_fldvarname = '&
//''//mpas_log_escape_dollars(config_prescribed_ice_stream_fldvarname))
            call mpas_log_write('        config_prescribed_ice_stream_fldfilename = '&
//''//mpas_log_escape_dollars(config_prescribed_ice_stream_fldfilename))
            call mpas_log_write('        config_prescribed_ice_stream_domtvarname = '&
//''//mpas_log_escape_dollars(config_prescribed_ice_stream_domtvarname))
            call mpas_log_write('        config_prescribed_ice_stream_domxvarname = '&
//''//mpas_log_escape_dollars(config_prescribed_ice_stream_domxvarname))
            call mpas_log_write('        config_prescribed_ice_stream_domyvarname = '&
//''//mpas_log_escape_dollars(config_prescribed_ice_stream_domyvarname))
            call mpas_log_write('        config_prescribed_ice_stream_domareaname = '&
//''//mpas_log_escape_dollars(config_prescribed_ice_stream_domareaname))
            call mpas_log_write('        config_prescribed_ice_stream_dommaskname = '&
//''//mpas_log_escape_dollars(config_prescribed_ice_stream_dommaskname))
            call mpas_log_write('        config_prescribed_ice_stream_domfilename = '&
//''//mpas_log_escape_dollars(config_prescribed_ice_stream_domfilename))
            call mpas_log_write('        config_prescribed_ice_stream_mapread = '&
//''//mpas_log_escape_dollars(config_prescribed_ice_stream_mapread))
            call mpas_log_write('        config_prescribed_ice_stream_fill = $l', logicArgs=(/config_prescribed_ice_stream_fill/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record prescribed_ice.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_prescribed_ice_stream_year_first', config_prescribed_ice_stream_year_first)
      call mpas_pool_add_config(configPool, 'config_prescribed_ice_stream_year_last', config_prescribed_ice_stream_year_last)
      call mpas_pool_add_config(configPool, 'config_prescribed_ice_model_year_align', config_prescribed_ice_model_year_align)
      call mpas_pool_add_config(configPool, 'config_prescribed_ice_stream_fldvarname', config_prescribed_ice_stream_fldvarname)
      call mpas_pool_add_config(configPool, 'config_prescribed_ice_stream_fldfilename', config_prescribed_ice_stream_fldfilename)
      call mpas_pool_add_config(configPool, 'config_prescribed_ice_stream_domtvarname', config_prescribed_ice_stream_domtvarname)
      call mpas_pool_add_config(configPool, 'config_prescribed_ice_stream_domxvarname', config_prescribed_ice_stream_domxvarname)
      call mpas_pool_add_config(configPool, 'config_prescribed_ice_stream_domyvarname', config_prescribed_ice_stream_domyvarname)
      call mpas_pool_add_config(configPool, 'config_prescribed_ice_stream_domareaname', config_prescribed_ice_stream_domareaname)
      call mpas_pool_add_config(configPool, 'config_prescribed_ice_stream_dommaskname', config_prescribed_ice_stream_dommaskname)
      call mpas_pool_add_config(configPool, 'config_prescribed_ice_stream_domfilename', config_prescribed_ice_stream_domfilename)
      call mpas_pool_add_config(configPool, 'config_prescribed_ice_stream_mapread', config_prescribed_ice_stream_mapread)
      call mpas_pool_add_config(configPool, 'config_prescribed_ice_stream_fill', config_prescribed_ice_stream_fill)

   end subroutine seaice_setup_nmlrec_prescribed_ice


   subroutine seaice_setup_nmlrec_AM_highFrequencyOutput(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_AM_highFrequencyOutput_enable = .false.
      character (len=StrKIND) :: config_AM_highFrequencyOutput_compute_interval = 'output_interval'
      character (len=StrKIND) :: config_AM_highFrequencyOutput_output_stream = 'highFrequencyOutput'
      logical :: config_AM_highFrequencyOutput_compute_on_startup = .true.
      logical :: config_AM_highFrequencyOutput_write_on_startup = .true.

      namelist /AM_highFrequencyOutput/ &
         config_AM_highFrequencyOutput_enable, &
         config_AM_highFrequencyOutput_compute_interval, &
         config_AM_highFrequencyOutput_output_stream, &
         config_AM_highFrequencyOutput_compute_on_startup, &
         config_AM_highFrequencyOutput_write_on_startup
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, AM_highFrequencyOutput, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_AM_highFrequencyOutput_enable)
         call mpas_dmpar_bcast_char(dminfo, config_AM_highFrequencyOutput_compute_interval)
         call mpas_dmpar_bcast_char(dminfo, config_AM_highFrequencyOutput_output_stream)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_highFrequencyOutput_compute_on_startup)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_highFrequencyOutput_write_on_startup)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record AM_highFrequencyOutput')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_AM_highFrequencyOutput_enable = $l', &
logicArgs=(/config_AM_highFrequencyOutput_enable/))
            call mpas_log_write('        config_AM_highFrequencyOutput_compute_interval = '&
//''//mpas_log_escape_dollars(config_AM_highFrequencyOutput_compute_interval))
            call mpas_log_write('        config_AM_highFrequencyOutput_output_stream = '&
//''//mpas_log_escape_dollars(config_AM_highFrequencyOutput_output_stream))
            call mpas_log_write('        config_AM_highFrequencyOutput_compute_on_startup = $l', &
logicArgs=(/config_AM_highFrequencyOutput_compute_on_startup/))
            call mpas_log_write('        config_AM_highFrequencyOutput_write_on_startup = $l', &
logicArgs=(/config_AM_highFrequencyOutput_write_on_startup/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record AM_highFrequencyOutput.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_AM_highFrequencyOutput_enable', config_AM_highFrequencyOutput_enable)
      call mpas_pool_add_config(configPool, 'config_AM_highFrequencyOutput_compute_interval', &
config_AM_highFrequencyOutput_compute_interval)
      call mpas_pool_add_config(configPool, 'config_AM_highFrequencyOutput_output_stream', &
config_AM_highFrequencyOutput_output_stream)
      call mpas_pool_add_config(configPool, 'config_AM_highFrequencyOutput_compute_on_startup', &
config_AM_highFrequencyOutput_compute_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_highFrequencyOutput_write_on_startup', &
config_AM_highFrequencyOutput_write_on_startup)

   end subroutine seaice_setup_nmlrec_AM_highFrequencyOutput


   subroutine seaice_setup_nmlrec_AM_temperatures(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_AM_temperatures_enable = .false.
      character (len=StrKIND) :: config_AM_temperatures_compute_interval = 'dt'
      character (len=StrKIND) :: config_AM_temperatures_output_stream = 'output'
      logical :: config_AM_temperatures_compute_on_startup = .false.
      logical :: config_AM_temperatures_write_on_startup = .false.

      namelist /AM_temperatures/ &
         config_AM_temperatures_enable, &
         config_AM_temperatures_compute_interval, &
         config_AM_temperatures_output_stream, &
         config_AM_temperatures_compute_on_startup, &
         config_AM_temperatures_write_on_startup
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, AM_temperatures, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_AM_temperatures_enable)
         call mpas_dmpar_bcast_char(dminfo, config_AM_temperatures_compute_interval)
         call mpas_dmpar_bcast_char(dminfo, config_AM_temperatures_output_stream)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_temperatures_compute_on_startup)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_temperatures_write_on_startup)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record AM_temperatures')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_AM_temperatures_enable = $l', logicArgs=(/config_AM_temperatures_enable/))
            call mpas_log_write('        config_AM_temperatures_compute_interval = '&
//''//mpas_log_escape_dollars(config_AM_temperatures_compute_interval))
            call mpas_log_write('        config_AM_temperatures_output_stream = '&
//''//mpas_log_escape_dollars(config_AM_temperatures_output_stream))
            call mpas_log_write('        config_AM_temperatures_compute_on_startup = $l', &
logicArgs=(/config_AM_temperatures_compute_on_startup/))
            call mpas_log_write('        config_AM_temperatures_write_on_startup = $l', &
logicArgs=(/config_AM_temperatures_write_on_startup/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record AM_temperatures.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_AM_temperatures_enable', config_AM_temperatures_enable)
      call mpas_pool_add_config(configPool, 'config_AM_temperatures_compute_interval', config_AM_temperatures_compute_interval)
      call mpas_pool_add_config(configPool, 'config_AM_temperatures_output_stream', config_AM_temperatures_output_stream)
      call mpas_pool_add_config(configPool, 'config_AM_temperatures_compute_on_startup', config_AM_temperatures_compute_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_temperatures_write_on_startup', config_AM_temperatures_write_on_startup)

   end subroutine seaice_setup_nmlrec_AM_temperatures


   subroutine seaice_setup_nmlrec_AM_regionalStatistics(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_AM_regionalStatistics_enable = .false.
      character (len=StrKIND) :: config_AM_regionalStatistics_compute_interval = 'output_interval'
      character (len=StrKIND) :: config_AM_regionalStatistics_output_stream = 'regionalStatisticsOutput'
      logical :: config_AM_regionalStatistics_compute_on_startup = .false.
      logical :: config_AM_regionalStatistics_write_on_startup = .false.
      real (kind=RKIND) :: config_AM_regionalStatistics_ice_extent_limit = 0.150000

      namelist /AM_regionalStatistics/ &
         config_AM_regionalStatistics_enable, &
         config_AM_regionalStatistics_compute_interval, &
         config_AM_regionalStatistics_output_stream, &
         config_AM_regionalStatistics_compute_on_startup, &
         config_AM_regionalStatistics_write_on_startup, &
         config_AM_regionalStatistics_ice_extent_limit
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, AM_regionalStatistics, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_AM_regionalStatistics_enable)
         call mpas_dmpar_bcast_char(dminfo, config_AM_regionalStatistics_compute_interval)
         call mpas_dmpar_bcast_char(dminfo, config_AM_regionalStatistics_output_stream)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_regionalStatistics_compute_on_startup)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_regionalStatistics_write_on_startup)
         call mpas_dmpar_bcast_real(dminfo, config_AM_regionalStatistics_ice_extent_limit)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record AM_regionalStatistics')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_AM_regionalStatistics_enable = $l', &
logicArgs=(/config_AM_regionalStatistics_enable/))
            call mpas_log_write('        config_AM_regionalStatistics_compute_interval = '&
//''//mpas_log_escape_dollars(config_AM_regionalStatistics_compute_interval))
            call mpas_log_write('        config_AM_regionalStatistics_output_stream = '&
//''//mpas_log_escape_dollars(config_AM_regionalStatistics_output_stream))
            call mpas_log_write('        config_AM_regionalStatistics_compute_on_startup = $l', &
logicArgs=(/config_AM_regionalStatistics_compute_on_startup/))
            call mpas_log_write('        config_AM_regionalStatistics_write_on_startup = $l', &
logicArgs=(/config_AM_regionalStatistics_write_on_startup/))
            call mpas_log_write('        config_AM_regionalStatistics_ice_extent_limit = $r', &
realArgs=(/config_AM_regionalStatistics_ice_extent_limit/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record AM_regionalStatistics.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_AM_regionalStatistics_enable', config_AM_regionalStatistics_enable)
      call mpas_pool_add_config(configPool, 'config_AM_regionalStatistics_compute_interval', &
config_AM_regionalStatistics_compute_interval)
      call mpas_pool_add_config(configPool, 'config_AM_regionalStatistics_output_stream', &
config_AM_regionalStatistics_output_stream)
      call mpas_pool_add_config(configPool, 'config_AM_regionalStatistics_compute_on_startup', &
config_AM_regionalStatistics_compute_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_regionalStatistics_write_on_startup', &
config_AM_regionalStatistics_write_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_regionalStatistics_ice_extent_limit', &
config_AM_regionalStatistics_ice_extent_limit)

   end subroutine seaice_setup_nmlrec_AM_regionalStatistics


   subroutine seaice_setup_nmlrec_AM_ridgingDiagnostics(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_AM_ridgingDiagnostics_enable = .false.
      character (len=StrKIND) :: config_AM_ridgingDiagnostics_compute_interval = 'dt'
      character (len=StrKIND) :: config_AM_ridgingDiagnostics_output_stream = 'output'
      logical :: config_AM_ridgingDiagnostics_compute_on_startup = .false.
      logical :: config_AM_ridgingDiagnostics_write_on_startup = .false.

      namelist /AM_ridgingDiagnostics/ &
         config_AM_ridgingDiagnostics_enable, &
         config_AM_ridgingDiagnostics_compute_interval, &
         config_AM_ridgingDiagnostics_output_stream, &
         config_AM_ridgingDiagnostics_compute_on_startup, &
         config_AM_ridgingDiagnostics_write_on_startup
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, AM_ridgingDiagnostics, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_AM_ridgingDiagnostics_enable)
         call mpas_dmpar_bcast_char(dminfo, config_AM_ridgingDiagnostics_compute_interval)
         call mpas_dmpar_bcast_char(dminfo, config_AM_ridgingDiagnostics_output_stream)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_ridgingDiagnostics_compute_on_startup)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_ridgingDiagnostics_write_on_startup)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record AM_ridgingDiagnostics')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_AM_ridgingDiagnostics_enable = $l', &
logicArgs=(/config_AM_ridgingDiagnostics_enable/))
            call mpas_log_write('        config_AM_ridgingDiagnostics_compute_interval = '&
//''//mpas_log_escape_dollars(config_AM_ridgingDiagnostics_compute_interval))
            call mpas_log_write('        config_AM_ridgingDiagnostics_output_stream = '&
//''//mpas_log_escape_dollars(config_AM_ridgingDiagnostics_output_stream))
            call mpas_log_write('        config_AM_ridgingDiagnostics_compute_on_startup = $l', &
logicArgs=(/config_AM_ridgingDiagnostics_compute_on_startup/))
            call mpas_log_write('        config_AM_ridgingDiagnostics_write_on_startup = $l', &
logicArgs=(/config_AM_ridgingDiagnostics_write_on_startup/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record AM_ridgingDiagnostics.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_AM_ridgingDiagnostics_enable', config_AM_ridgingDiagnostics_enable)
      call mpas_pool_add_config(configPool, 'config_AM_ridgingDiagnostics_compute_interval', &
config_AM_ridgingDiagnostics_compute_interval)
      call mpas_pool_add_config(configPool, 'config_AM_ridgingDiagnostics_output_stream', &
config_AM_ridgingDiagnostics_output_stream)
      call mpas_pool_add_config(configPool, 'config_AM_ridgingDiagnostics_compute_on_startup', &
config_AM_ridgingDiagnostics_compute_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_ridgingDiagnostics_write_on_startup', &
config_AM_ridgingDiagnostics_write_on_startup)

   end subroutine seaice_setup_nmlrec_AM_ridgingDiagnostics


   subroutine seaice_setup_nmlrec_AM_conservationCheck(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_AM_conservationCheck_enable = .false.
      character (len=StrKIND) :: config_AM_conservationCheck_compute_interval = 'dt'
      character (len=StrKIND) :: config_AM_conservationCheck_output_stream = 'conservationCheckOutput'
      logical :: config_AM_conservationCheck_compute_on_startup = .false.
      logical :: config_AM_conservationCheck_write_on_startup = .false.
      logical :: config_AM_conservationCheck_write_to_logfile = .true.

      namelist /AM_conservationCheck/ &
         config_AM_conservationCheck_enable, &
         config_AM_conservationCheck_compute_interval, &
         config_AM_conservationCheck_output_stream, &
         config_AM_conservationCheck_compute_on_startup, &
         config_AM_conservationCheck_write_on_startup, &
         config_AM_conservationCheck_write_to_logfile
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, AM_conservationCheck, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_AM_conservationCheck_enable)
         call mpas_dmpar_bcast_char(dminfo, config_AM_conservationCheck_compute_interval)
         call mpas_dmpar_bcast_char(dminfo, config_AM_conservationCheck_output_stream)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_conservationCheck_compute_on_startup)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_conservationCheck_write_on_startup)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_conservationCheck_write_to_logfile)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record AM_conservationCheck')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_AM_conservationCheck_enable = $l', &
logicArgs=(/config_AM_conservationCheck_enable/))
            call mpas_log_write('        config_AM_conservationCheck_compute_interval = '&
//''//mpas_log_escape_dollars(config_AM_conservationCheck_compute_interval))
            call mpas_log_write('        config_AM_conservationCheck_output_stream = '&
//''//mpas_log_escape_dollars(config_AM_conservationCheck_output_stream))
            call mpas_log_write('        config_AM_conservationCheck_compute_on_startup = $l', &
logicArgs=(/config_AM_conservationCheck_compute_on_startup/))
            call mpas_log_write('        config_AM_conservationCheck_write_on_startup = $l', &
logicArgs=(/config_AM_conservationCheck_write_on_startup/))
            call mpas_log_write('        config_AM_conservationCheck_write_to_logfile = $l', &
logicArgs=(/config_AM_conservationCheck_write_to_logfile/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record AM_conservationCheck.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_AM_conservationCheck_enable', config_AM_conservationCheck_enable)
      call mpas_pool_add_config(configPool, 'config_AM_conservationCheck_compute_interval', &
config_AM_conservationCheck_compute_interval)
      call mpas_pool_add_config(configPool, 'config_AM_conservationCheck_output_stream', config_AM_conservationCheck_output_stream)
      call mpas_pool_add_config(configPool, 'config_AM_conservationCheck_compute_on_startup', &
config_AM_conservationCheck_compute_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_conservationCheck_write_on_startup', &
config_AM_conservationCheck_write_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_conservationCheck_write_to_logfile', &
config_AM_conservationCheck_write_to_logfile)

   end subroutine seaice_setup_nmlrec_AM_conservationCheck


   subroutine seaice_setup_nmlrec_AM_geographicalVectors(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_AM_geographicalVectors_enable = .false.
      character (len=StrKIND) :: config_AM_geographicalVectors_compute_interval = 'dt'
      character (len=StrKIND) :: config_AM_geographicalVectors_output_stream = 'output'
      logical :: config_AM_geographicalVectors_compute_on_startup = .false.
      logical :: config_AM_geographicalVectors_write_on_startup = .false.

      namelist /AM_geographicalVectors/ &
         config_AM_geographicalVectors_enable, &
         config_AM_geographicalVectors_compute_interval, &
         config_AM_geographicalVectors_output_stream, &
         config_AM_geographicalVectors_compute_on_startup, &
         config_AM_geographicalVectors_write_on_startup
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, AM_geographicalVectors, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_AM_geographicalVectors_enable)
         call mpas_dmpar_bcast_char(dminfo, config_AM_geographicalVectors_compute_interval)
         call mpas_dmpar_bcast_char(dminfo, config_AM_geographicalVectors_output_stream)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_geographicalVectors_compute_on_startup)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_geographicalVectors_write_on_startup)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record AM_geographicalVectors')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_AM_geographicalVectors_enable = $l', &
logicArgs=(/config_AM_geographicalVectors_enable/))
            call mpas_log_write('        config_AM_geographicalVectors_compute_interval = '&
//''//mpas_log_escape_dollars(config_AM_geographicalVectors_compute_interval))
            call mpas_log_write('        config_AM_geographicalVectors_output_stream = '&
//''//mpas_log_escape_dollars(config_AM_geographicalVectors_output_stream))
            call mpas_log_write('        config_AM_geographicalVectors_compute_on_startup = $l', &
logicArgs=(/config_AM_geographicalVectors_compute_on_startup/))
            call mpas_log_write('        config_AM_geographicalVectors_write_on_startup = $l', &
logicArgs=(/config_AM_geographicalVectors_write_on_startup/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record AM_geographicalVectors.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_AM_geographicalVectors_enable', config_AM_geographicalVectors_enable)
      call mpas_pool_add_config(configPool, 'config_AM_geographicalVectors_compute_interval', &
config_AM_geographicalVectors_compute_interval)
      call mpas_pool_add_config(configPool, 'config_AM_geographicalVectors_output_stream', &
config_AM_geographicalVectors_output_stream)
      call mpas_pool_add_config(configPool, 'config_AM_geographicalVectors_compute_on_startup', &
config_AM_geographicalVectors_compute_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_geographicalVectors_write_on_startup', &
config_AM_geographicalVectors_write_on_startup)

   end subroutine seaice_setup_nmlrec_AM_geographicalVectors


   subroutine seaice_setup_nmlrec_AM_loadBalance(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_AM_loadBalance_enable = .false.
      character (len=StrKIND) :: config_AM_loadBalance_compute_interval = 'output_interval'
      character (len=StrKIND) :: config_AM_loadBalance_output_stream = 'loadBalanceOutput'
      logical :: config_AM_loadBalance_compute_on_startup = .false.
      logical :: config_AM_loadBalance_write_on_startup = .false.
      integer :: config_AM_loadBalance_nProcs = 32

      namelist /AM_loadBalance/ &
         config_AM_loadBalance_enable, &
         config_AM_loadBalance_compute_interval, &
         config_AM_loadBalance_output_stream, &
         config_AM_loadBalance_compute_on_startup, &
         config_AM_loadBalance_write_on_startup, &
         config_AM_loadBalance_nProcs
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, AM_loadBalance, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_AM_loadBalance_enable)
         call mpas_dmpar_bcast_char(dminfo, config_AM_loadBalance_compute_interval)
         call mpas_dmpar_bcast_char(dminfo, config_AM_loadBalance_output_stream)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_loadBalance_compute_on_startup)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_loadBalance_write_on_startup)
         call mpas_dmpar_bcast_int(dminfo, config_AM_loadBalance_nProcs)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record AM_loadBalance')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_AM_loadBalance_enable = $l', logicArgs=(/config_AM_loadBalance_enable/))
            call mpas_log_write('        config_AM_loadBalance_compute_interval = '&
//''//mpas_log_escape_dollars(config_AM_loadBalance_compute_interval))
            call mpas_log_write('        config_AM_loadBalance_output_stream = '&
//''//mpas_log_escape_dollars(config_AM_loadBalance_output_stream))
            call mpas_log_write('        config_AM_loadBalance_compute_on_startup = $l', &
logicArgs=(/config_AM_loadBalance_compute_on_startup/))
            call mpas_log_write('        config_AM_loadBalance_write_on_startup = $l', &
logicArgs=(/config_AM_loadBalance_write_on_startup/))
            call mpas_log_write('        config_AM_loadBalance_nProcs = $i', intArgs=(/config_AM_loadBalance_nProcs/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record AM_loadBalance.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_AM_loadBalance_enable', config_AM_loadBalance_enable)
      call mpas_pool_add_config(configPool, 'config_AM_loadBalance_compute_interval', config_AM_loadBalance_compute_interval)
      call mpas_pool_add_config(configPool, 'config_AM_loadBalance_output_stream', config_AM_loadBalance_output_stream)
      call mpas_pool_add_config(configPool, 'config_AM_loadBalance_compute_on_startup', config_AM_loadBalance_compute_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_loadBalance_write_on_startup', config_AM_loadBalance_write_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_loadBalance_nProcs', config_AM_loadBalance_nProcs)

   end subroutine seaice_setup_nmlrec_AM_loadBalance


   subroutine seaice_setup_nmlrec_AM_maximumIcePresence(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_AM_maximumIcePresence_enable = .false.
      character (len=StrKIND) :: config_AM_maximumIcePresence_compute_interval = 'dt'
      character (len=StrKIND) :: config_AM_maximumIcePresence_output_stream = 'maximumIcePresenceOutput'
      logical :: config_AM_maximumIcePresence_compute_on_startup = .false.
      logical :: config_AM_maximumIcePresence_write_on_startup = .false.
      character (len=StrKIND) :: config_AM_maximumIcePresence_start_time = '0000-00-00_00:00:00'

      namelist /AM_maximumIcePresence/ &
         config_AM_maximumIcePresence_enable, &
         config_AM_maximumIcePresence_compute_interval, &
         config_AM_maximumIcePresence_output_stream, &
         config_AM_maximumIcePresence_compute_on_startup, &
         config_AM_maximumIcePresence_write_on_startup, &
         config_AM_maximumIcePresence_start_time
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, AM_maximumIcePresence, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_AM_maximumIcePresence_enable)
         call mpas_dmpar_bcast_char(dminfo, config_AM_maximumIcePresence_compute_interval)
         call mpas_dmpar_bcast_char(dminfo, config_AM_maximumIcePresence_output_stream)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_maximumIcePresence_compute_on_startup)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_maximumIcePresence_write_on_startup)
         call mpas_dmpar_bcast_char(dminfo, config_AM_maximumIcePresence_start_time)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record AM_maximumIcePresence')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_AM_maximumIcePresence_enable = $l', &
logicArgs=(/config_AM_maximumIcePresence_enable/))
            call mpas_log_write('        config_AM_maximumIcePresence_compute_interval = '&
//''//mpas_log_escape_dollars(config_AM_maximumIcePresence_compute_interval))
            call mpas_log_write('        config_AM_maximumIcePresence_output_stream = '&
//''//mpas_log_escape_dollars(config_AM_maximumIcePresence_output_stream))
            call mpas_log_write('        config_AM_maximumIcePresence_compute_on_startup = $l', &
logicArgs=(/config_AM_maximumIcePresence_compute_on_startup/))
            call mpas_log_write('        config_AM_maximumIcePresence_write_on_startup = $l', &
logicArgs=(/config_AM_maximumIcePresence_write_on_startup/))
            call mpas_log_write('        config_AM_maximumIcePresence_start_time = '&
//''//mpas_log_escape_dollars(config_AM_maximumIcePresence_start_time))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record AM_maximumIcePresence.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_AM_maximumIcePresence_enable', config_AM_maximumIcePresence_enable)
      call mpas_pool_add_config(configPool, 'config_AM_maximumIcePresence_compute_interval', &
config_AM_maximumIcePresence_compute_interval)
      call mpas_pool_add_config(configPool, 'config_AM_maximumIcePresence_output_stream', &
config_AM_maximumIcePresence_output_stream)
      call mpas_pool_add_config(configPool, 'config_AM_maximumIcePresence_compute_on_startup', &
config_AM_maximumIcePresence_compute_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_maximumIcePresence_write_on_startup', &
config_AM_maximumIcePresence_write_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_maximumIcePresence_start_time', config_AM_maximumIcePresence_start_time)

   end subroutine seaice_setup_nmlrec_AM_maximumIcePresence


   subroutine seaice_setup_nmlrec_AM_miscellaneous(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_AM_miscellaneous_enable = .false.
      character (len=StrKIND) :: config_AM_miscellaneous_compute_interval = 'dt'
      character (len=StrKIND) :: config_AM_miscellaneous_output_stream = 'none'
      logical :: config_AM_miscellaneous_compute_on_startup = .false.
      logical :: config_AM_miscellaneous_write_on_startup = .false.

      namelist /AM_miscellaneous/ &
         config_AM_miscellaneous_enable, &
         config_AM_miscellaneous_compute_interval, &
         config_AM_miscellaneous_output_stream, &
         config_AM_miscellaneous_compute_on_startup, &
         config_AM_miscellaneous_write_on_startup
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, AM_miscellaneous, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_AM_miscellaneous_enable)
         call mpas_dmpar_bcast_char(dminfo, config_AM_miscellaneous_compute_interval)
         call mpas_dmpar_bcast_char(dminfo, config_AM_miscellaneous_output_stream)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_miscellaneous_compute_on_startup)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_miscellaneous_write_on_startup)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record AM_miscellaneous')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_AM_miscellaneous_enable = $l', logicArgs=(/config_AM_miscellaneous_enable/))
            call mpas_log_write('        config_AM_miscellaneous_compute_interval = '&
//''//mpas_log_escape_dollars(config_AM_miscellaneous_compute_interval))
            call mpas_log_write('        config_AM_miscellaneous_output_stream = '&
//''//mpas_log_escape_dollars(config_AM_miscellaneous_output_stream))
            call mpas_log_write('        config_AM_miscellaneous_compute_on_startup = $l', &
logicArgs=(/config_AM_miscellaneous_compute_on_startup/))
            call mpas_log_write('        config_AM_miscellaneous_write_on_startup = $l', &
logicArgs=(/config_AM_miscellaneous_write_on_startup/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record AM_miscellaneous.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_AM_miscellaneous_enable', config_AM_miscellaneous_enable)
      call mpas_pool_add_config(configPool, 'config_AM_miscellaneous_compute_interval', config_AM_miscellaneous_compute_interval)
      call mpas_pool_add_config(configPool, 'config_AM_miscellaneous_output_stream', config_AM_miscellaneous_output_stream)
      call mpas_pool_add_config(configPool, 'config_AM_miscellaneous_compute_on_startup', &
config_AM_miscellaneous_compute_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_miscellaneous_write_on_startup', config_AM_miscellaneous_write_on_startup)

   end subroutine seaice_setup_nmlrec_AM_miscellaneous


   subroutine seaice_setup_nmlrec_AM_areaVariables(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_AM_areaVariables_enable = .false.
      character (len=StrKIND) :: config_AM_areaVariables_compute_interval = 'dt'
      character (len=StrKIND) :: config_AM_areaVariables_output_stream = 'none'
      logical :: config_AM_areaVariables_compute_on_startup = .false.
      logical :: config_AM_areaVariables_write_on_startup = .false.

      namelist /AM_areaVariables/ &
         config_AM_areaVariables_enable, &
         config_AM_areaVariables_compute_interval, &
         config_AM_areaVariables_output_stream, &
         config_AM_areaVariables_compute_on_startup, &
         config_AM_areaVariables_write_on_startup
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, AM_areaVariables, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_AM_areaVariables_enable)
         call mpas_dmpar_bcast_char(dminfo, config_AM_areaVariables_compute_interval)
         call mpas_dmpar_bcast_char(dminfo, config_AM_areaVariables_output_stream)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_areaVariables_compute_on_startup)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_areaVariables_write_on_startup)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record AM_areaVariables')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_AM_areaVariables_enable = $l', logicArgs=(/config_AM_areaVariables_enable/))
            call mpas_log_write('        config_AM_areaVariables_compute_interval = '&
//''//mpas_log_escape_dollars(config_AM_areaVariables_compute_interval))
            call mpas_log_write('        config_AM_areaVariables_output_stream = '&
//''//mpas_log_escape_dollars(config_AM_areaVariables_output_stream))
            call mpas_log_write('        config_AM_areaVariables_compute_on_startup = $l', &
logicArgs=(/config_AM_areaVariables_compute_on_startup/))
            call mpas_log_write('        config_AM_areaVariables_write_on_startup = $l', &
logicArgs=(/config_AM_areaVariables_write_on_startup/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record AM_areaVariables.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_AM_areaVariables_enable', config_AM_areaVariables_enable)
      call mpas_pool_add_config(configPool, 'config_AM_areaVariables_compute_interval', config_AM_areaVariables_compute_interval)
      call mpas_pool_add_config(configPool, 'config_AM_areaVariables_output_stream', config_AM_areaVariables_output_stream)
      call mpas_pool_add_config(configPool, 'config_AM_areaVariables_compute_on_startup', &
config_AM_areaVariables_compute_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_areaVariables_write_on_startup', config_AM_areaVariables_write_on_startup)

   end subroutine seaice_setup_nmlrec_AM_areaVariables


   subroutine seaice_setup_nmlrec_AM_pondDiagnostics(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_AM_pondDiagnostics_enable = .false.
      character (len=StrKIND) :: config_AM_pondDiagnostics_compute_interval = 'dt'
      character (len=StrKIND) :: config_AM_pondDiagnostics_output_stream = 'none'
      logical :: config_AM_pondDiagnostics_compute_on_startup = .false.
      logical :: config_AM_pondDiagnostics_write_on_startup = .false.

      namelist /AM_pondDiagnostics/ &
         config_AM_pondDiagnostics_enable, &
         config_AM_pondDiagnostics_compute_interval, &
         config_AM_pondDiagnostics_output_stream, &
         config_AM_pondDiagnostics_compute_on_startup, &
         config_AM_pondDiagnostics_write_on_startup
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, AM_pondDiagnostics, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_AM_pondDiagnostics_enable)
         call mpas_dmpar_bcast_char(dminfo, config_AM_pondDiagnostics_compute_interval)
         call mpas_dmpar_bcast_char(dminfo, config_AM_pondDiagnostics_output_stream)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_pondDiagnostics_compute_on_startup)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_pondDiagnostics_write_on_startup)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record AM_pondDiagnostics')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_AM_pondDiagnostics_enable = $l', logicArgs=(/config_AM_pondDiagnostics_enable/))
            call mpas_log_write('        config_AM_pondDiagnostics_compute_interval = '&
//''//mpas_log_escape_dollars(config_AM_pondDiagnostics_compute_interval))
            call mpas_log_write('        config_AM_pondDiagnostics_output_stream = '&
//''//mpas_log_escape_dollars(config_AM_pondDiagnostics_output_stream))
            call mpas_log_write('        config_AM_pondDiagnostics_compute_on_startup = $l', &
logicArgs=(/config_AM_pondDiagnostics_compute_on_startup/))
            call mpas_log_write('        config_AM_pondDiagnostics_write_on_startup = $l', &
logicArgs=(/config_AM_pondDiagnostics_write_on_startup/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record AM_pondDiagnostics.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_AM_pondDiagnostics_enable', config_AM_pondDiagnostics_enable)
      call mpas_pool_add_config(configPool, 'config_AM_pondDiagnostics_compute_interval', &
config_AM_pondDiagnostics_compute_interval)
      call mpas_pool_add_config(configPool, 'config_AM_pondDiagnostics_output_stream', config_AM_pondDiagnostics_output_stream)
      call mpas_pool_add_config(configPool, 'config_AM_pondDiagnostics_compute_on_startup', &
config_AM_pondDiagnostics_compute_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_pondDiagnostics_write_on_startup', &
config_AM_pondDiagnostics_write_on_startup)

   end subroutine seaice_setup_nmlrec_AM_pondDiagnostics


   subroutine seaice_setup_nmlrec_AM_unitConversion(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_AM_unitConversion_enable = .true.
      character (len=StrKIND) :: config_AM_unitConversion_compute_interval = 'dt'
      character (len=StrKIND) :: config_AM_unitConversion_output_stream = 'none'
      logical :: config_AM_unitConversion_compute_on_startup = .false.
      logical :: config_AM_unitConversion_write_on_startup = .false.

      namelist /AM_unitConversion/ &
         config_AM_unitConversion_enable, &
         config_AM_unitConversion_compute_interval, &
         config_AM_unitConversion_output_stream, &
         config_AM_unitConversion_compute_on_startup, &
         config_AM_unitConversion_write_on_startup
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, AM_unitConversion, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_AM_unitConversion_enable)
         call mpas_dmpar_bcast_char(dminfo, config_AM_unitConversion_compute_interval)
         call mpas_dmpar_bcast_char(dminfo, config_AM_unitConversion_output_stream)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_unitConversion_compute_on_startup)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_unitConversion_write_on_startup)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record AM_unitConversion')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_AM_unitConversion_enable = $l', logicArgs=(/config_AM_unitConversion_enable/))
            call mpas_log_write('        config_AM_unitConversion_compute_interval = '&
//''//mpas_log_escape_dollars(config_AM_unitConversion_compute_interval))
            call mpas_log_write('        config_AM_unitConversion_output_stream = '&
//''//mpas_log_escape_dollars(config_AM_unitConversion_output_stream))
            call mpas_log_write('        config_AM_unitConversion_compute_on_startup = $l', &
logicArgs=(/config_AM_unitConversion_compute_on_startup/))
            call mpas_log_write('        config_AM_unitConversion_write_on_startup = $l', &
logicArgs=(/config_AM_unitConversion_write_on_startup/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record AM_unitConversion.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_AM_unitConversion_enable', config_AM_unitConversion_enable)
      call mpas_pool_add_config(configPool, 'config_AM_unitConversion_compute_interval', config_AM_unitConversion_compute_interval)
      call mpas_pool_add_config(configPool, 'config_AM_unitConversion_output_stream', config_AM_unitConversion_output_stream)
      call mpas_pool_add_config(configPool, 'config_AM_unitConversion_compute_on_startup', &
config_AM_unitConversion_compute_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_unitConversion_write_on_startup', config_AM_unitConversion_write_on_startup)

   end subroutine seaice_setup_nmlrec_AM_unitConversion


   subroutine seaice_setup_nmlrec_AM_pointwiseStats(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_AM_pointwiseStats_enable = .false.
      character (len=StrKIND) :: config_AM_pointwiseStats_compute_interval = 'dt'
      character (len=StrKIND) :: config_AM_pointwiseStats_output_stream = 'pointwiseStatsOutput'
      logical :: config_AM_pointwiseStats_compute_on_startup = .false.
      logical :: config_AM_pointwiseStats_write_on_startup = .false.

      namelist /AM_pointwiseStats/ &
         config_AM_pointwiseStats_enable, &
         config_AM_pointwiseStats_compute_interval, &
         config_AM_pointwiseStats_output_stream, &
         config_AM_pointwiseStats_compute_on_startup, &
         config_AM_pointwiseStats_write_on_startup
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, AM_pointwiseStats, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_AM_pointwiseStats_enable)
         call mpas_dmpar_bcast_char(dminfo, config_AM_pointwiseStats_compute_interval)
         call mpas_dmpar_bcast_char(dminfo, config_AM_pointwiseStats_output_stream)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_pointwiseStats_compute_on_startup)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_pointwiseStats_write_on_startup)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record AM_pointwiseStats')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_AM_pointwiseStats_enable = $l', logicArgs=(/config_AM_pointwiseStats_enable/))
            call mpas_log_write('        config_AM_pointwiseStats_compute_interval = '&
//''//mpas_log_escape_dollars(config_AM_pointwiseStats_compute_interval))
            call mpas_log_write('        config_AM_pointwiseStats_output_stream = '&
//''//mpas_log_escape_dollars(config_AM_pointwiseStats_output_stream))
            call mpas_log_write('        config_AM_pointwiseStats_compute_on_startup = $l', &
logicArgs=(/config_AM_pointwiseStats_compute_on_startup/))
            call mpas_log_write('        config_AM_pointwiseStats_write_on_startup = $l', &
logicArgs=(/config_AM_pointwiseStats_write_on_startup/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record AM_pointwiseStats.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_AM_pointwiseStats_enable', config_AM_pointwiseStats_enable)
      call mpas_pool_add_config(configPool, 'config_AM_pointwiseStats_compute_interval', config_AM_pointwiseStats_compute_interval)
      call mpas_pool_add_config(configPool, 'config_AM_pointwiseStats_output_stream', config_AM_pointwiseStats_output_stream)
      call mpas_pool_add_config(configPool, 'config_AM_pointwiseStats_compute_on_startup', &
config_AM_pointwiseStats_compute_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_pointwiseStats_write_on_startup', config_AM_pointwiseStats_write_on_startup)

   end subroutine seaice_setup_nmlrec_AM_pointwiseStats


   subroutine seaice_setup_nmlrec_AM_iceShelves(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_AM_iceShelves_enable = .false.
      character (len=StrKIND) :: config_AM_iceShelves_compute_interval = 'output_interval'
      character (len=StrKIND) :: config_AM_iceShelves_output_stream = 'iceShelvesOutput'
      logical :: config_AM_iceShelves_compute_on_startup = .true.
      logical :: config_AM_iceShelves_write_on_startup = .true.

      namelist /AM_iceShelves/ &
         config_AM_iceShelves_enable, &
         config_AM_iceShelves_compute_interval, &
         config_AM_iceShelves_output_stream, &
         config_AM_iceShelves_compute_on_startup, &
         config_AM_iceShelves_write_on_startup
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, AM_iceShelves, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_AM_iceShelves_enable)
         call mpas_dmpar_bcast_char(dminfo, config_AM_iceShelves_compute_interval)
         call mpas_dmpar_bcast_char(dminfo, config_AM_iceShelves_output_stream)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_iceShelves_compute_on_startup)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_iceShelves_write_on_startup)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record AM_iceShelves')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_AM_iceShelves_enable = $l', logicArgs=(/config_AM_iceShelves_enable/))
            call mpas_log_write('        config_AM_iceShelves_compute_interval = '&
//''//mpas_log_escape_dollars(config_AM_iceShelves_compute_interval))
            call mpas_log_write('        config_AM_iceShelves_output_stream = '&
//''//mpas_log_escape_dollars(config_AM_iceShelves_output_stream))
            call mpas_log_write('        config_AM_iceShelves_compute_on_startup = $l', &
logicArgs=(/config_AM_iceShelves_compute_on_startup/))
            call mpas_log_write('        config_AM_iceShelves_write_on_startup = $l', &
logicArgs=(/config_AM_iceShelves_write_on_startup/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record AM_iceShelves.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_AM_iceShelves_enable', config_AM_iceShelves_enable)
      call mpas_pool_add_config(configPool, 'config_AM_iceShelves_compute_interval', config_AM_iceShelves_compute_interval)
      call mpas_pool_add_config(configPool, 'config_AM_iceShelves_output_stream', config_AM_iceShelves_output_stream)
      call mpas_pool_add_config(configPool, 'config_AM_iceShelves_compute_on_startup', config_AM_iceShelves_compute_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_iceShelves_write_on_startup', config_AM_iceShelves_write_on_startup)

   end subroutine seaice_setup_nmlrec_AM_iceShelves


   subroutine seaice_setup_nmlrec_AM_icePresent(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_AM_icePresent_enable = .false.
      character (len=StrKIND) :: config_AM_icePresent_compute_interval = 'dt'
      character (len=StrKIND) :: config_AM_icePresent_output_stream = 'none'
      logical :: config_AM_icePresent_compute_on_startup = .false.
      logical :: config_AM_icePresent_write_on_startup = .false.

      namelist /AM_icePresent/ &
         config_AM_icePresent_enable, &
         config_AM_icePresent_compute_interval, &
         config_AM_icePresent_output_stream, &
         config_AM_icePresent_compute_on_startup, &
         config_AM_icePresent_write_on_startup
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, AM_icePresent, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_AM_icePresent_enable)
         call mpas_dmpar_bcast_char(dminfo, config_AM_icePresent_compute_interval)
         call mpas_dmpar_bcast_char(dminfo, config_AM_icePresent_output_stream)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_icePresent_compute_on_startup)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_icePresent_write_on_startup)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record AM_icePresent')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_AM_icePresent_enable = $l', logicArgs=(/config_AM_icePresent_enable/))
            call mpas_log_write('        config_AM_icePresent_compute_interval = '&
//''//mpas_log_escape_dollars(config_AM_icePresent_compute_interval))
            call mpas_log_write('        config_AM_icePresent_output_stream = '&
//''//mpas_log_escape_dollars(config_AM_icePresent_output_stream))
            call mpas_log_write('        config_AM_icePresent_compute_on_startup = $l', &
logicArgs=(/config_AM_icePresent_compute_on_startup/))
            call mpas_log_write('        config_AM_icePresent_write_on_startup = $l', &
logicArgs=(/config_AM_icePresent_write_on_startup/))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record AM_icePresent.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_AM_icePresent_enable', config_AM_icePresent_enable)
      call mpas_pool_add_config(configPool, 'config_AM_icePresent_compute_interval', config_AM_icePresent_compute_interval)
      call mpas_pool_add_config(configPool, 'config_AM_icePresent_output_stream', config_AM_icePresent_output_stream)
      call mpas_pool_add_config(configPool, 'config_AM_icePresent_compute_on_startup', config_AM_icePresent_compute_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_icePresent_write_on_startup', config_AM_icePresent_write_on_startup)

   end subroutine seaice_setup_nmlrec_AM_icePresent


   subroutine seaice_setup_nmlrec_AM_timeSeriesStatsDaily(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_AM_timeSeriesStatsDaily_enable = .false.
      logical :: config_AM_timeSeriesStatsDaily_compute_on_startup = .false.
      logical :: config_AM_timeSeriesStatsDaily_write_on_startup = .false.
      character (len=StrKIND) :: config_AM_timeSeriesStatsDaily_compute_interval = 'dt'
      character (len=StrKIND) :: config_AM_timeSeriesStatsDaily_output_stream = 'timeSeriesStatsDailyOutput'
      character (len=StrKIND) :: config_AM_timeSeriesStatsDaily_restart_stream = 'timeSeriesStatsDailyRestart'
      character (len=StrKIND) :: config_AM_timeSeriesStatsDaily_operation = 'avg'
      character (len=StrKIND) :: config_AM_timeSeriesStatsDaily_reference_times = 'initial_time'
      character (len=StrKIND) :: config_AM_timeSeriesStatsDaily_duration_intervals = 'repeat_interval'
      character (len=StrKIND) :: config_AM_timeSeriesStatsDaily_repeat_intervals = 'reset_interval'
      character (len=StrKIND) :: config_AM_timeSeriesStatsDaily_reset_intervals = '00-00-01_00:00:00'
      character (len=StrKIND) :: config_AM_timeSeriesStatsDaily_backward_output_offset = '00-00-01_00:00:00'

      namelist /AM_timeSeriesStatsDaily/ &
         config_AM_timeSeriesStatsDaily_enable, &
         config_AM_timeSeriesStatsDaily_compute_on_startup, &
         config_AM_timeSeriesStatsDaily_write_on_startup, &
         config_AM_timeSeriesStatsDaily_compute_interval, &
         config_AM_timeSeriesStatsDaily_output_stream, &
         config_AM_timeSeriesStatsDaily_restart_stream, &
         config_AM_timeSeriesStatsDaily_operation, &
         config_AM_timeSeriesStatsDaily_reference_times, &
         config_AM_timeSeriesStatsDaily_duration_intervals, &
         config_AM_timeSeriesStatsDaily_repeat_intervals, &
         config_AM_timeSeriesStatsDaily_reset_intervals, &
         config_AM_timeSeriesStatsDaily_backward_output_offset
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, AM_timeSeriesStatsDaily, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_AM_timeSeriesStatsDaily_enable)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_timeSeriesStatsDaily_compute_on_startup)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_timeSeriesStatsDaily_write_on_startup)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsDaily_compute_interval)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsDaily_output_stream)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsDaily_restart_stream)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsDaily_operation)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsDaily_reference_times)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsDaily_duration_intervals)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsDaily_repeat_intervals)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsDaily_reset_intervals)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsDaily_backward_output_offset)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record AM_timeSeriesStatsDaily')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_AM_timeSeriesStatsDaily_enable = $l', &
logicArgs=(/config_AM_timeSeriesStatsDaily_enable/))
            call mpas_log_write('        config_AM_timeSeriesStatsDaily_compute_on_startup = $l', &
logicArgs=(/config_AM_timeSeriesStatsDaily_compute_on_startup/))
            call mpas_log_write('        config_AM_timeSeriesStatsDaily_write_on_startup = $l', &
logicArgs=(/config_AM_timeSeriesStatsDaily_write_on_startup/))
            call mpas_log_write('        config_AM_timeSeriesStatsDaily_compute_interval = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsDaily_compute_interval))
            call mpas_log_write('        config_AM_timeSeriesStatsDaily_output_stream = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsDaily_output_stream))
            call mpas_log_write('        config_AM_timeSeriesStatsDaily_restart_stream = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsDaily_restart_stream))
            call mpas_log_write('        config_AM_timeSeriesStatsDaily_operation = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsDaily_operation))
            call mpas_log_write('        config_AM_timeSeriesStatsDaily_reference_times = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsDaily_reference_times))
            call mpas_log_write('        config_AM_timeSeriesStatsDaily_duration_intervals = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsDaily_duration_intervals))
            call mpas_log_write('        config_AM_timeSeriesStatsDaily_repeat_intervals = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsDaily_repeat_intervals))
            call mpas_log_write('        config_AM_timeSeriesStatsDaily_reset_intervals = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsDaily_reset_intervals))
            call mpas_log_write('        config_AM_timeSeriesStatsDaily_backward_output_offset = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsDaily_backward_output_offset))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record AM_timeSeriesStatsDaily.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsDaily_enable', config_AM_timeSeriesStatsDaily_enable)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsDaily_compute_on_startup', &
config_AM_timeSeriesStatsDaily_compute_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsDaily_write_on_startup', &
config_AM_timeSeriesStatsDaily_write_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsDaily_compute_interval', &
config_AM_timeSeriesStatsDaily_compute_interval)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsDaily_output_stream', &
config_AM_timeSeriesStatsDaily_output_stream)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsDaily_restart_stream', &
config_AM_timeSeriesStatsDaily_restart_stream)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsDaily_operation', config_AM_timeSeriesStatsDaily_operation)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsDaily_reference_times', &
config_AM_timeSeriesStatsDaily_reference_times)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsDaily_duration_intervals', &
config_AM_timeSeriesStatsDaily_duration_intervals)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsDaily_repeat_intervals', &
config_AM_timeSeriesStatsDaily_repeat_intervals)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsDaily_reset_intervals', &
config_AM_timeSeriesStatsDaily_reset_intervals)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsDaily_backward_output_offset', &
config_AM_timeSeriesStatsDaily_backward_output_offset)

   end subroutine seaice_setup_nmlrec_AM_timeSeriesStatsDaily


   subroutine seaice_setup_nmlrec_AM_timeSeriesStatsMonthly(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_AM_timeSeriesStatsMonthly_enable = .false.
      logical :: config_AM_timeSeriesStatsMonthly_compute_on_startup = .false.
      logical :: config_AM_timeSeriesStatsMonthly_write_on_startup = .false.
      character (len=StrKIND) :: config_AM_timeSeriesStatsMonthly_compute_interval = 'dt'
      character (len=StrKIND) :: config_AM_timeSeriesStatsMonthly_output_stream = 'timeSeriesStatsMonthlyOutput'
      character (len=StrKIND) :: config_AM_timeSeriesStatsMonthly_restart_stream = 'timeSeriesStatsMonthlyRestart'
      character (len=StrKIND) :: config_AM_timeSeriesStatsMonthly_operation = 'avg'
      character (len=StrKIND) :: config_AM_timeSeriesStatsMonthly_reference_times = 'initial_time'
      character (len=StrKIND) :: config_AM_timeSeriesStatsMonthly_duration_intervals = 'repeat_interval'
      character (len=StrKIND) :: config_AM_timeSeriesStatsMonthly_repeat_intervals = 'reset_interval'
      character (len=StrKIND) :: config_AM_timeSeriesStatsMonthly_reset_intervals = '00-01-00_00:00:00'
      character (len=StrKIND) :: config_AM_timeSeriesStatsMonthly_backward_output_offset = '00-01-00_00:00:00'

      namelist /AM_timeSeriesStatsMonthly/ &
         config_AM_timeSeriesStatsMonthly_enable, &
         config_AM_timeSeriesStatsMonthly_compute_on_startup, &
         config_AM_timeSeriesStatsMonthly_write_on_startup, &
         config_AM_timeSeriesStatsMonthly_compute_interval, &
         config_AM_timeSeriesStatsMonthly_output_stream, &
         config_AM_timeSeriesStatsMonthly_restart_stream, &
         config_AM_timeSeriesStatsMonthly_operation, &
         config_AM_timeSeriesStatsMonthly_reference_times, &
         config_AM_timeSeriesStatsMonthly_duration_intervals, &
         config_AM_timeSeriesStatsMonthly_repeat_intervals, &
         config_AM_timeSeriesStatsMonthly_reset_intervals, &
         config_AM_timeSeriesStatsMonthly_backward_output_offset
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, AM_timeSeriesStatsMonthly, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_AM_timeSeriesStatsMonthly_enable)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_timeSeriesStatsMonthly_compute_on_startup)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_timeSeriesStatsMonthly_write_on_startup)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsMonthly_compute_interval)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsMonthly_output_stream)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsMonthly_restart_stream)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsMonthly_operation)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsMonthly_reference_times)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsMonthly_duration_intervals)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsMonthly_repeat_intervals)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsMonthly_reset_intervals)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsMonthly_backward_output_offset)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record AM_timeSeriesStatsMonthly')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_AM_timeSeriesStatsMonthly_enable = $l', &
logicArgs=(/config_AM_timeSeriesStatsMonthly_enable/))
            call mpas_log_write('        config_AM_timeSeriesStatsMonthly_compute_on_startup = $l', &
logicArgs=(/config_AM_timeSeriesStatsMonthly_compute_on_startup/))
            call mpas_log_write('        config_AM_timeSeriesStatsMonthly_write_on_startup = $l', &
logicArgs=(/config_AM_timeSeriesStatsMonthly_write_on_startup/))
            call mpas_log_write('        config_AM_timeSeriesStatsMonthly_compute_interval = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsMonthly_compute_interval))
            call mpas_log_write('        config_AM_timeSeriesStatsMonthly_output_stream = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsMonthly_output_stream))
            call mpas_log_write('        config_AM_timeSeriesStatsMonthly_restart_stream = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsMonthly_restart_stream))
            call mpas_log_write('        config_AM_timeSeriesStatsMonthly_operation = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsMonthly_operation))
            call mpas_log_write('        config_AM_timeSeriesStatsMonthly_reference_times = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsMonthly_reference_times))
            call mpas_log_write('        config_AM_timeSeriesStatsMonthly_duration_intervals = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsMonthly_duration_intervals))
            call mpas_log_write('        config_AM_timeSeriesStatsMonthly_repeat_intervals = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsMonthly_repeat_intervals))
            call mpas_log_write('        config_AM_timeSeriesStatsMonthly_reset_intervals = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsMonthly_reset_intervals))
            call mpas_log_write('        config_AM_timeSeriesStatsMonthly_backward_output_offset = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsMonthly_backward_output_offset))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record AM_timeSeriesStatsMonthly.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsMonthly_enable', config_AM_timeSeriesStatsMonthly_enable)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsMonthly_compute_on_startup', &
config_AM_timeSeriesStatsMonthly_compute_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsMonthly_write_on_startup', &
config_AM_timeSeriesStatsMonthly_write_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsMonthly_compute_interval', &
config_AM_timeSeriesStatsMonthly_compute_interval)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsMonthly_output_stream', &
config_AM_timeSeriesStatsMonthly_output_stream)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsMonthly_restart_stream', &
config_AM_timeSeriesStatsMonthly_restart_stream)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsMonthly_operation', &
config_AM_timeSeriesStatsMonthly_operation)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsMonthly_reference_times', &
config_AM_timeSeriesStatsMonthly_reference_times)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsMonthly_duration_intervals', &
config_AM_timeSeriesStatsMonthly_duration_intervals)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsMonthly_repeat_intervals', &
config_AM_timeSeriesStatsMonthly_repeat_intervals)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsMonthly_reset_intervals', &
config_AM_timeSeriesStatsMonthly_reset_intervals)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsMonthly_backward_output_offset', &
config_AM_timeSeriesStatsMonthly_backward_output_offset)

   end subroutine seaice_setup_nmlrec_AM_timeSeriesStatsMonthly


   subroutine seaice_setup_nmlrec_AM_timeSeriesStatsClimatology(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_AM_timeSeriesStatsClimatology_enable = .false.
      logical :: config_AM_timeSeriesStatsClimatology_compute_on_startup = .false.
      logical :: config_AM_timeSeriesStatsClimatology_write_on_startup = .false.
      character (len=StrKIND) :: config_AM_timeSeriesStatsClimatology_compute_interval = '00-00-00_01:00:00'
      character (len=StrKIND) :: config_AM_timeSeriesStatsClimatology_output_stream = 'timeSeriesStatsClimatologyOutput'
      character (len=StrKIND) :: config_AM_timeSeriesStatsClimatology_restart_stream = 'timeSeriesStatsClimatologyRestart'
      character (len=StrKIND) :: config_AM_timeSeriesStatsClimatology_operation = 'avg'
      character (len=StrKIND) :: config_AM_timeSeriesStatsClimatology_reference_times = &
'00-03-01_00:00:00;00-06-01_00:00:00;00-09-01_00:00:00;00-12-01_00:00:00'
      character (len=StrKIND) :: config_AM_timeSeriesStatsClimatology_duration_intervals = &
'00-03-00_00:00:00;00-03-00_00:00:00;00-03-00_00:00:00;00-03-00_00:00:00'
      character (len=StrKIND) :: config_AM_timeSeriesStatsClimatology_repeat_intervals = &
'01-00-00_00:00:00;01-00-00_00:00:00;01-00-00_00:00:00;01-00-00_00:00:00'
      character (len=StrKIND) :: config_AM_timeSeriesStatsClimatology_reset_intervals = &
'1000-00-00_00:00:00;1000-00-00_00:00:00;1000-00-00_00:00:00;1000-00-00_00:00:00'
      character (len=StrKIND) :: config_AM_timeSeriesStatsClimatology_backward_output_offset = '00-03-00_00:00:00'

      namelist /AM_timeSeriesStatsClimatology/ &
         config_AM_timeSeriesStatsClimatology_enable, &
         config_AM_timeSeriesStatsClimatology_compute_on_startup, &
         config_AM_timeSeriesStatsClimatology_write_on_startup, &
         config_AM_timeSeriesStatsClimatology_compute_interval, &
         config_AM_timeSeriesStatsClimatology_output_stream, &
         config_AM_timeSeriesStatsClimatology_restart_stream, &
         config_AM_timeSeriesStatsClimatology_operation, &
         config_AM_timeSeriesStatsClimatology_reference_times, &
         config_AM_timeSeriesStatsClimatology_duration_intervals, &
         config_AM_timeSeriesStatsClimatology_repeat_intervals, &
         config_AM_timeSeriesStatsClimatology_reset_intervals, &
         config_AM_timeSeriesStatsClimatology_backward_output_offset
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, AM_timeSeriesStatsClimatology, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_AM_timeSeriesStatsClimatology_enable)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_timeSeriesStatsClimatology_compute_on_startup)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_timeSeriesStatsClimatology_write_on_startup)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsClimatology_compute_interval)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsClimatology_output_stream)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsClimatology_restart_stream)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsClimatology_operation)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsClimatology_reference_times)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsClimatology_duration_intervals)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsClimatology_repeat_intervals)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsClimatology_reset_intervals)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsClimatology_backward_output_offset)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record AM_timeSeriesStatsClimatology')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_AM_timeSeriesStatsClimatology_enable = $l', &
logicArgs=(/config_AM_timeSeriesStatsClimatology_enable/))
            call mpas_log_write('        config_AM_timeSeriesStatsClimatology_compute_on_startup = $l', &
logicArgs=(/config_AM_timeSeriesStatsClimatology_compute_on_startup/))
            call mpas_log_write('        config_AM_timeSeriesStatsClimatology_write_on_startup = $l', &
logicArgs=(/config_AM_timeSeriesStatsClimatology_write_on_startup/))
            call mpas_log_write('        config_AM_timeSeriesStatsClimatology_compute_interval = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsClimatology_compute_interval))
            call mpas_log_write('        config_AM_timeSeriesStatsClimatology_output_stream = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsClimatology_output_stream))
            call mpas_log_write('        config_AM_timeSeriesStatsClimatology_restart_stream = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsClimatology_restart_stream))
            call mpas_log_write('        config_AM_timeSeriesStatsClimatology_operation = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsClimatology_operation))
            call mpas_log_write('        config_AM_timeSeriesStatsClimatology_reference_times = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsClimatology_reference_times))
            call mpas_log_write('        config_AM_timeSeriesStatsClimatology_duration_intervals = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsClimatology_duration_intervals))
            call mpas_log_write('        config_AM_timeSeriesStatsClimatology_repeat_intervals = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsClimatology_repeat_intervals))
            call mpas_log_write('        config_AM_timeSeriesStatsClimatology_reset_intervals = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsClimatology_reset_intervals))
            call mpas_log_write('        config_AM_timeSeriesStatsClimatology_backward_output_offset = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsClimatology_backward_output_offset))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record AM_timeSeriesStatsClimatology.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsClimatology_enable', &
config_AM_timeSeriesStatsClimatology_enable)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsClimatology_compute_on_startup', &
config_AM_timeSeriesStatsClimatology_compute_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsClimatology_write_on_startup', &
config_AM_timeSeriesStatsClimatology_write_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsClimatology_compute_interval', &
config_AM_timeSeriesStatsClimatology_compute_interval)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsClimatology_output_stream', &
config_AM_timeSeriesStatsClimatology_output_stream)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsClimatology_restart_stream', &
config_AM_timeSeriesStatsClimatology_restart_stream)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsClimatology_operation', &
config_AM_timeSeriesStatsClimatology_operation)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsClimatology_reference_times', &
config_AM_timeSeriesStatsClimatology_reference_times)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsClimatology_duration_intervals', &
config_AM_timeSeriesStatsClimatology_duration_intervals)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsClimatology_repeat_intervals', &
config_AM_timeSeriesStatsClimatology_repeat_intervals)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsClimatology_reset_intervals', &
config_AM_timeSeriesStatsClimatology_reset_intervals)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsClimatology_backward_output_offset', &
config_AM_timeSeriesStatsClimatology_backward_output_offset)

   end subroutine seaice_setup_nmlrec_AM_timeSeriesStatsClimatology


   subroutine seaice_setup_nmlrec_AM_timeSeriesStatsCustom(configPool, unitNumber, dminfo)
      use mpas_log, only : mpas_log_write, mpas_log_escape_dollars
      implicit none
      type (mpas_pool_type), intent(inout) :: configPool
      integer, intent(in) :: unitNumber
      type (dm_info), intent(in) :: dminfo
      type (mpas_pool_type), pointer :: recordPool
      integer :: ierr

      logical :: config_AM_timeSeriesStatsCustom_enable = .false.
      logical :: config_AM_timeSeriesStatsCustom_compute_on_startup = .false.
      logical :: config_AM_timeSeriesStatsCustom_write_on_startup = .false.
      character (len=StrKIND) :: config_AM_timeSeriesStatsCustom_compute_interval = '00-00-00_01:00:00'
      character (len=StrKIND) :: config_AM_timeSeriesStatsCustom_output_stream = 'timeSeriesStatsCustomOutput'
      character (len=StrKIND) :: config_AM_timeSeriesStatsCustom_restart_stream = 'timeSeriesStatsCustomRestart'
      character (len=StrKIND) :: config_AM_timeSeriesStatsCustom_operation = 'avg'
      character (len=StrKIND) :: config_AM_timeSeriesStatsCustom_reference_times = 'initial_time'
      character (len=StrKIND) :: config_AM_timeSeriesStatsCustom_duration_intervals = 'repeat_interval'
      character (len=StrKIND) :: config_AM_timeSeriesStatsCustom_repeat_intervals = 'reset_interval'
      character (len=StrKIND) :: config_AM_timeSeriesStatsCustom_reset_intervals = '00-00-07_00:00:00'
      character (len=StrKIND) :: config_AM_timeSeriesStatsCustom_backward_output_offset = '00-00-01_00:00:00'

      namelist /AM_timeSeriesStatsCustom/ &
         config_AM_timeSeriesStatsCustom_enable, &
         config_AM_timeSeriesStatsCustom_compute_on_startup, &
         config_AM_timeSeriesStatsCustom_write_on_startup, &
         config_AM_timeSeriesStatsCustom_compute_interval, &
         config_AM_timeSeriesStatsCustom_output_stream, &
         config_AM_timeSeriesStatsCustom_restart_stream, &
         config_AM_timeSeriesStatsCustom_operation, &
         config_AM_timeSeriesStatsCustom_reference_times, &
         config_AM_timeSeriesStatsCustom_duration_intervals, &
         config_AM_timeSeriesStatsCustom_repeat_intervals, &
         config_AM_timeSeriesStatsCustom_reset_intervals, &
         config_AM_timeSeriesStatsCustom_backward_output_offset
      if (dminfo % my_proc_id == IO_NODE) then
! Rewinding before each read leads to errors when the code is built with
! the NAG Fortran compiler. If building with NAG, be kind and don't rewind.
         rewind(unitNumber)
         read(unitNumber, AM_timeSeriesStatsCustom, iostat=ierr)
      end if
      call mpas_dmpar_bcast_int(dminfo, ierr)

      if (ierr <= 0) then
         call mpas_dmpar_bcast_logical(dminfo, config_AM_timeSeriesStatsCustom_enable)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_timeSeriesStatsCustom_compute_on_startup)
         call mpas_dmpar_bcast_logical(dminfo, config_AM_timeSeriesStatsCustom_write_on_startup)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsCustom_compute_interval)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsCustom_output_stream)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsCustom_restart_stream)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsCustom_operation)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsCustom_reference_times)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsCustom_duration_intervals)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsCustom_repeat_intervals)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsCustom_reset_intervals)
         call mpas_dmpar_bcast_char(dminfo, config_AM_timeSeriesStatsCustom_backward_output_offset)
         if (ierr < 0) then
            call mpas_log_write('*** Encountered an issue while attempting to read namelist record AM_timeSeriesStatsCustom')
            call mpas_log_write('    The following values will be used for variables in this record:')
            call mpas_log_write(' ')
            call mpas_log_write('        config_AM_timeSeriesStatsCustom_enable = $l', &
logicArgs=(/config_AM_timeSeriesStatsCustom_enable/))
            call mpas_log_write('        config_AM_timeSeriesStatsCustom_compute_on_startup = $l', &
logicArgs=(/config_AM_timeSeriesStatsCustom_compute_on_startup/))
            call mpas_log_write('        config_AM_timeSeriesStatsCustom_write_on_startup = $l', &
logicArgs=(/config_AM_timeSeriesStatsCustom_write_on_startup/))
            call mpas_log_write('        config_AM_timeSeriesStatsCustom_compute_interval = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsCustom_compute_interval))
            call mpas_log_write('        config_AM_timeSeriesStatsCustom_output_stream = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsCustom_output_stream))
            call mpas_log_write('        config_AM_timeSeriesStatsCustom_restart_stream = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsCustom_restart_stream))
            call mpas_log_write('        config_AM_timeSeriesStatsCustom_operation = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsCustom_operation))
            call mpas_log_write('        config_AM_timeSeriesStatsCustom_reference_times = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsCustom_reference_times))
            call mpas_log_write('        config_AM_timeSeriesStatsCustom_duration_intervals = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsCustom_duration_intervals))
            call mpas_log_write('        config_AM_timeSeriesStatsCustom_repeat_intervals = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsCustom_repeat_intervals))
            call mpas_log_write('        config_AM_timeSeriesStatsCustom_reset_intervals = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsCustom_reset_intervals))
            call mpas_log_write('        config_AM_timeSeriesStatsCustom_backward_output_offset = '&
//''//mpas_log_escape_dollars(config_AM_timeSeriesStatsCustom_backward_output_offset))
            call mpas_log_write(' ')
         end if
      else if (ierr > 0) then
         call mpas_log_write('Error while reading namelist record AM_timeSeriesStatsCustom.', MPAS_LOG_CRIT)
      end if

      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsCustom_enable', config_AM_timeSeriesStatsCustom_enable)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsCustom_compute_on_startup', &
config_AM_timeSeriesStatsCustom_compute_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsCustom_write_on_startup', &
config_AM_timeSeriesStatsCustom_write_on_startup)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsCustom_compute_interval', &
config_AM_timeSeriesStatsCustom_compute_interval)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsCustom_output_stream', &
config_AM_timeSeriesStatsCustom_output_stream)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsCustom_restart_stream', &
config_AM_timeSeriesStatsCustom_restart_stream)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsCustom_operation', config_AM_timeSeriesStatsCustom_operation)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsCustom_reference_times', &
config_AM_timeSeriesStatsCustom_reference_times)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsCustom_duration_intervals', &
config_AM_timeSeriesStatsCustom_duration_intervals)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsCustom_repeat_intervals', &
config_AM_timeSeriesStatsCustom_repeat_intervals)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsCustom_reset_intervals', &
config_AM_timeSeriesStatsCustom_reset_intervals)
      call mpas_pool_add_config(configPool, 'config_AM_timeSeriesStatsCustom_backward_output_offset', &
config_AM_timeSeriesStatsCustom_backward_output_offset)

   end subroutine seaice_setup_nmlrec_AM_timeSeriesStatsCustom



end module seaice_core_interface
